{"meta":{"title":"嵌入式小菜鸡","subtitle":"","description":"","author":"Huihang Lai","url":"http://yoursite.com","root":"/"},"pages":[{"title":"所有分类","date":"2020-02-09T13:43:15.028Z","updated":"2020-02-09T13:43:15.028Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-02-09T13:43:29.323Z","updated":"2020-02-09T13:43:29.323Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-02-09T13:43:22.220Z","updated":"2020-02-09T13:43:22.220Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-02-09T14:28:09.857Z","updated":"2020-02-09T14:28:09.857Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"03-makefile","slug":"03-makefile","date":"2020-02-04T15:11:23.000Z","updated":"2020-02-09T14:44:28.600Z","comments":true,"path":"2020/02/04/03-makefile/","link":"","permalink":"http://yoursite.com/2020/02/04/03-makefile/","excerpt":"","text":"MakefileVPATH的用法 VPATH：虚路径 在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录里。所以，当make需要去寻找文件的依赖关系时，你可以在文件前加上路径，但最好的方法时把一个路径告诉make，让make自动去寻找。 Makefile文件中的特殊变量”VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件，到所指定的目录中去找寻文件了。 VPATH = src:../headers 上面的定义指定两个目录，&quot;src&quot;和&quot;../headers&quot;, make会按照这个顺序进行搜索，目录由”冒号”分隔。(当然，当前目录永远是最高优先搜索的地方)嵌套的Makefile","categories":[{"name":"MakeFile","slug":"MakeFile","permalink":"http://yoursite.com/categories/MakeFile/"}],"tags":[{"name":"MakeFile","slug":"MakeFile","permalink":"http://yoursite.com/tags/MakeFile/"}]},{"title":"02-makefile","slug":"02-makefile","date":"2020-02-04T13:31:22.000Z","updated":"2020-02-09T14:44:19.487Z","comments":true,"path":"2020/02/04/02-makefile/","link":"","permalink":"http://yoursite.com/2020/02/04/02-makefile/","excerpt":"","text":"Makefilemake使用 直接运行make 选项 -C &#8195; dir读入指定目录下的Makefile -f &#8195; file读入 -i &#8195; 忽略所有的命令执行错误 -I &#8195; dir指定被包含的Makefile所在目录 -n &#8195; 只打印要执行的命令，但不执行这些命令 -p &#8195; 显示make变量数据库和隐含规则 -s &#8195; 在执行命令时不显示命令 -w &#8195; 如果make在执行过程中改变目录，打印当前目录名 makefile可以include + 文件名来引用其他文件中的内容Makefile的隐含规则 隐含规则1：编译c程序的隐含规则 “&lt;n&gt;.o”的目标的依赖目标会自动推导为”&lt;n&gt;.c”，并且其生成命令是”$(CC) -c $(CPPFLAGS) $(CFLAGS)” 隐含规则2：链接Object文件的隐含规则 “&lt;n&gt;”目标依赖于”&lt;n&gt;.o”，通过运行c的编译器来运行连接程序生成(一般是”ld”)，其生成命令是：”$(CC) $(LDFLAGS) &lt;n&gt;.o” $(LOADLIBES) $(LDLIBS)。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件(由不同的源文件生成)的也有效","categories":[{"name":"MakeFile","slug":"MakeFile","permalink":"http://yoursite.com/categories/MakeFile/"}],"tags":[{"name":"MakeFile","slug":"MakeFile","permalink":"http://yoursite.com/tags/MakeFile/"}]},{"title":"01-makefile","slug":"01-makefile","date":"2020-02-04T10:27:54.000Z","updated":"2020-02-09T14:44:33.217Z","comments":true,"path":"2020/02/04/01-makefile/","link":"","permalink":"http://yoursite.com/2020/02/04/01-makefile/","excerpt":"","text":"MakefileMake简介 工程管理器，顾名思义，是指管理较多得文件 Make工程管理器也就是个自动编译管理器，这里得自动是指它能够根据文件时间戳自动发现更新过得文件而减少编译得工作量，同时，它通过读入Makefile文件得内容来执行大量得编译工作。 Make将只编译改动的代码文件，而不用完全编译Makefile基本结构 Makefile是Make读入的唯一配置文件 由make工具创建的目标体(target)，通常是目标文件或可执行文件 要创建的目标体所依赖的文件(dependency_file) 创建每个目标体时需要运行的命令(command) 注意：命令行前面必须是一个”TAB键”，否则编译错误 Makefile格式 12target : dependency_files&lt;TAB&gt; command 例子 12hello : hello.c hello.h gcc -c hello.c -o hello.o 更复杂的例子 123456sunq : kang.o yul.o gcc kang.o yul.o -o sunqkang.o : kang.c kang.h gcc -Wall -O -g -c kang.c -o kang.oyul : yul.c gcc -Wall -O -g -c yul.c -o yul.o 注释： -WALL表示允许发出gcc所有有用的报警信息 -c只是编译不链接，生成目标文件”.o” -o file:表示把输出文件输出到file里创建和使用变量 创建变量的目的： 用来代替一个文本字符串： 系列文件的名字 传递给编译器的参数 需要运行的程序 需要查找源代码的目录 你需要输出信息的目录 你想做的其他事情 变量定义的两种方式 递归展开方式VAR=var 简单方式VAR:=var 变量使用$(VAR) 用$则用$$来表示 类似于编程语言中的宏定义 刚才的例子： 12345foo=$(bar)bar=$(ugh)ugh=Huh?$(foo)的值为?echo $(foo)来进行查看 优点：它可以向后引用变量 缺点：不能对该变量进行任何扩展 用?=定义变量&#8195;dir:=/foo/bar&#8195;FOO?=bar&#8195;FOO是? FOO之前没被定义过则被定义为bar 预定义变量 AR &#8195; 库文件维护程序的名称，默认值为ar CC &#8195; C编译器的名称，默认值为cc。CPP&#8195;C预编译器的名称，默认值为$(CC) -E CXX &#8195; C++编译器的名称，默认值为g++ FC &#8195; FORTRAN编译器的名称，默认值为f77 RM &#8195; 文件删除程序的名称，默认值为rm -f 自动变量 $* &#8195; 不包含扩展名的目标文件名称 $+ &#8195; 所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件 $&lt; &#8195; 第一个依赖文件的名称 $? &#8195; 所有时间戳比目标文件晚的依赖文件，并以空格分开 $@ &#8195; 目标文件的完整名称 $^ &#8195; 所有不重复的目标依赖文件，以空格分开 $% &#8195; 如果目标是归档成员，则改变量表示目标的归档成员名称 刚才的例子： 123456789OBJS = kang.o yul.oCC = gccCFLAGS = -Wall -O -gsunq : $(OBJS) $(CC) $^ -o $@kang.o : kang.c kang.h $(CC) $(CFLAGS) -c $&lt; -o $@yul.o : yul.c yul.h $(CC) $(CFLAGS) -c $&lt; -o $@ 环境变量 make在启动时会自动读取系统当前已经定义了的环境变量，而且会创建与之具有相同名称和数值的变量 如果用户在Makefile中定义了相同名称的变量，那么用户自定义变量将会覆盖同名的环境变量","categories":[{"name":"MakeFile","slug":"MakeFile","permalink":"http://yoursite.com/categories/MakeFile/"}],"tags":[{"name":"MakeFile","slug":"MakeFile","permalink":"http://yoursite.com/tags/MakeFile/"}]}]}