{"meta":{"title":"NULL的Blog","subtitle":"","description":"","author":"Huihang Lai","url":"http://yoursite.com","root":"/"},"pages":[{"title":"所有分类","date":"2020-02-10T15:18:14.484Z","updated":"2020-02-09T13:43:15.028Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-02-09T14:28:09.857Z","updated":"2020-02-09T14:28:09.857Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-02-09T13:43:22.220Z","updated":"2020-02-09T13:43:22.220Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-02-09T13:43:29.323Z","updated":"2020-02-09T13:43:29.323Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"Lx Y","slug":"Lx Y","date":"2020-03-05T07:15:16.000Z","updated":"2020-03-05T14:13:03.909Z","comments":true,"path":"2020/03/05/Lx Y/","link":"","permalink":"http://yoursite.com/2020/03/05/Lx%20Y/","excerpt":"","text":"关于工作教师事业编： 滨江区教师招聘(中学，小学，幼儿园，有编制): 根据2020年杭州市滨江教育局所属事业单位面向毕业生和在职教师直接考核招聘教师公告，对于应届生的招聘要求如下：12345678910111213141516(一)全日制2020届毕业生 1.具有本科及以上学历、学士及以上学位，并且获得过国家奖学金、省级师范生技能大赛一等奖等奖项或省级及以上优秀毕业生、优秀学生(党员)、优秀学生(党、团)干部等荣誉称号的毕业生。 2.具有研究生学历、博士学位的毕业生。 3.具有研究生学历、硕士学位，符合下列五类条件之一： (1)国家“一流大学”建设高校毕业生。 (2)国家“一流学科”建设高校和浙江省重点建设师范类高校毕业生，并且本科毕业于国家“双一流”建设高校或浙江省重点建设高校。 (3)国家“一流学科”建设高校和浙江省重点建设师范类高校毕业生，并且大学期间获得过校级优秀毕业生、优秀学生(党员)、优秀学生(党、团)干部等荣誉称号，或综合(专业)成绩排名前50%。 (4)普通高校毕业生，并且大学期间获得过校级优秀毕业生、优秀学生(党员)、优秀学生(党、团)干部等荣誉称号，或综合(专业)成绩排名前20%。 (5)普通高校学前教育方向毕业生。 4.具有本科学历、学士学位，符合下列三类条件之一： (1)国家“一流大学”建设高校毕业生，并且获得校级优秀毕业生、优秀学生(党员)、优秀学生(党、团)干部等荣誉称号，或综合(专业)成绩排名前50%。 (2)国家“一流学科”建设高校和浙江省重点建设师范类高校毕业生，并且获得校级优秀毕业生、优秀学生(党员)、优秀学生(党、团)干部等荣誉称号，或综合(专业)成绩排名前20%。 (3)普通师范类高校或浙江省内高校毕业生，获得校级优秀毕业生、优秀学生(党员)、优秀学生(党、团)干部等荣誉称号，且综合(专业)成绩排名前10%。 5.教育部直属师范大学免(公)费师范生。 注：上述条件并没有包括海外研究生的要求，但是根据公示的录取名单里面是有海外研究生被录取。 报名时间：2019年5月10日至11日（上午8:30—11:00，下午13:00—16:00） 报名时间：2019年7月23日至8月5日（上午9：00-11：00，下午13：30-16：00，双休日除外） 报名时间：2019年12月17日至12月30日(上午9：00-11：00，下午13：30-16：00，双休日除外) 根据公告公示,总录取人数为20人(包括海外研究生),因为分三次招聘此次是12月份招聘的人数，一年总的招聘人数为67人。 统计过后报录比基本上1:5 萧山区教师招聘(中学，小学，幼儿园，有编制): 根据杭州市萧山区面向2020届研究生和优秀本科生招聘公告，对于应届生的招聘如下：12345678910111213一）对象：面向2020届全日制普通高校毕业生。“985”、“211”院校毕业生户籍不限，省级重点师范院校毕业生户籍或生源地（即参加高考时的户籍地）为浙江省。 下列第1至4种对象可同时报考一、二类岗位，第5种对象只能报考二类岗位。1. 具有研究生学历、硕士及以上学位的“985”、“211”院校毕业生；2. 具有研究生学历、硕士及以上学位的省级重点师范院校毕业生；3. 具有本科学历、学士学位的“985”、“211”院校毕业生；4. 具有本科学历、学士学位的省级重点师范院校重点批（即高考录取为一本）毕业生，并具备下列条件之一：校级及以上优秀毕业生或优秀学生（团）干部，综合（专业）成绩排名前20%，校级二等及以上奖学金，浙江师范大学初阳学院毕业生。5. 具有本科学历、学士学位的省级重点师范院校重点批（即高考录取为一本）毕业生，并具备下列条件之一：综合（专业）成绩排名前30%，校级三等及以上奖学金。2019年毕业并已获得教育部留学服务中心认证的研究生，且本科符合上述对象条件的人员也可报考。（二）身心健康：遵纪守法，热爱教育事业，有良好的社会公德和职业道德，具有适应岗位要求的身体条件。（三）年龄在28周岁以下（1992年7月1日后出生）。（四）学历、学位与专业：具体岗位要求详见《杭州市萧山区面向2020届研究生和优秀本科生招聘计划表》（附件），报考学历专业须与招聘学科相符，2020年7月底前须获得相应的学历、学位证书。注：跟滨江区的要求稍有差别，这边对于海外研究生的本科也有要求。 报名时间：11月4日9：00时至11月11日17:00。 初审地址：浙江师范大学，杭州师范大学 非事业编以及其他 滨江区高中教师招聘(一般通过各个部署师范高校以及省内师范院校校招得到，有无编制看学校)： 详情点击此链接，此链接为浙江师范大学2019秋招企业以及学校列表。 详情点击此链接，此链接为杭州师范大学2019年秋招企业以及学校列表。 其他培训机构(不建议,虽然工资很高) 民办学校 高校的辅导员(还没到招聘时间) 外企： 如brother等日企 欧美企业 公务员(三不限难度大) 家里安排一下(稳稳的幸福) 教师资格证考试 根据2019年下半年考试安排： 笔试报名时间：2019年9月3日-6日 笔试考试时间：2019年11月2日 笔试成绩查询：2019年12月10日左右 面试考试时间：2020年1月4日-5日 今年不出意外还是同样的时间 教师资格证分三门科目： 综合素质 教育知识与能力 学科知识与教学能力(你应该没有问题) 三门课可以分开考，也可以一次性通过，分开考的话之前考的课有效期2年，建议一次性考出，前两门主要都是需要记忆的东西，对你来说问题也不大。 总结建议尽快写论文，早做准备，做多手准备。以上只是我的建议。。。 End Powered by www.hhlai.xyz","categories":[],"tags":[]},{"title":"01-My bootloader","slug":"01-My bootloader","date":"2020-03-01T08:16:40.000Z","updated":"2020-03-10T07:53:25.795Z","comments":true,"path":"2020/03/01/01-My bootloader/","link":"","permalink":"http://yoursite.com/2020/03/01/01-My%20bootloader/","excerpt":"","text":"My bootloader最简单的bootloader的编写步骤 初始化硬件：关看门狗，设置时钟，设置SDRAM，初始化nand flash 如果bootloader比较大，要把它重定位到SDRAM 把内核从nand flash读到SDRAM 设置“要传给内核的参数” 跳转执行内核 创建start.S 关看门狗 123ldr r0, =0x53000000 ;伪汇编指令，0x53000000不能放到立即数中mov r1, #0;str r1, [r0] ;将r1的值存在r0的地址中 设置时钟 12345678910111213#define S3C2440_MPLL_200MHZ ((0x5c&lt;&lt;12)|(0x01&lt;&lt;4)|(0x02))ldr r0, =0x4c000014mov r1, #0x03 ;分频系数为3str r1, [r0];改变CPU的总线模式从\"fast bus mode\"到\"asynchronous\"mrc p15, 0, r1, c1, c0, 0 ;读出控制寄存器orr r1, r1, #0xc0000000 ;设置为\"asynchronous bus mode\"mcr p15, 0, r1, c1, c0, 0 ;写入控制寄存器ldr r0, =0x4c000004ldr r1, =S3c2440_NPLL_200MHZstr r1, [r0] 初始化SDRAM 12345678910111213141516171819202122#define MEN_CTL_BASE 0x48000000 ldr r0, =MEM_CTL_BASE adr r1, sdram_config ;伪汇编指令 得到当前地址 add r3, r0, #(13*4)1. ldr r2, [r1], #4 ;从r1所指地方取一个值存到r2，然后让r1+4 str r2, [r0], #4 cmp r0, r3 bne 1sdram_config: .long 0x22011110 .long 0x00000700 .long 0x00000700 .long 0x00000700 .long 0x00000700 .long 0x00000700 .long 0x00000700 .long 0x00018005 重定位：把bootloader本身的代码从flash复制到它的链接地址去 norflash： nandflash： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146ldr sp, =0x34000000 ;栈往下增长bl nand_init mov r0, #0ldr r1, =_start ;_start = 0x33f80000ldr r2, =__bss_startsub r2, r2, r1bl copy_code_to_sdram ;执行C语言函数，之前需要设置栈bl clean_bss#define NFCONF (*((volatile unsigned long *)0x4E000000))#define NFCONF (*((volatile unsigned long *)0x4E000004))#define NFCMMD (*((volatile unsigned char *)0x4E000008))#define NFADDR (*((volatile unsigned char *)0x4E00000C))#define NFDATA (*((volatile unsigned char *)0x4E000010))#define NFSTAT (*((volatile unsigned char *)0x4E000020)) //nandflash 寄存器int isBootFromNorFlash(void)&#123; volatile int *p = (volatile int *)0; int val; val = *p; *p = 0x12345678; //利用norflash不能写的特性 if(*p == 0x12345678) &#123; //写成功，是nand启动 *p = val; return 0; &#125; else &#123; return 1; &#125;&#125;void copy_code_to_sdram(unsigned char *src, unsigned char *dest, unsigned int length)&#123; int i = 0; //如果是NOR启动 if(isBootFromNorFlash()) &#123; while(i &lt; len) &#123; dest[i] = src[i]; i++; &#125; &#125; else &#123; //nand_init(); nand_read(src, dest, len); &#125;&#125;void clean_bss(void) &#123; extern int __bss_start, __bss_end; int *p = &amp;__bss_start; for(; p &lt; &amp;__bss_end; p++) *p = 0;&#125;void nand_init(void)&#123;//时间参数,见之后的时序图#define TACLS 0#define TWRPH0 1#define TWRPH1 0 //设置时序 s3c2440nand-&gt;NFCONF = (TACLS&lt;&lt;12) | (TWRPH0&lt;&lt;8) | (TWRPH1&lt;&lt;4); //使能nand flash控制器，初始化ECC，禁止片选 NFCONT = (1&lt;&lt;4) | (1&lt;&lt;1) | (1&lt;&lt;0);&#125;void nand_select(void)&#123; NFCONT &amp;= ~(1 &lt;&lt; 1);&#125;void nand_deselect(void)&#123; NFCONT |= (1 &lt;&lt; 1);&#125;void nand_cmd(unsigned char cmd)&#123; volatile int i; NFCMMD = cmd; for(i=0; i&lt;10; i++); //延时一小会&#125;void nand_addr(unsigned int addr)&#123; unsigned int col = addr / 2048; unsigned int page = add % 2048; volatile int i; NFADDR = col &amp; 0xff; for(i=0; i&lt;10; i++); NFADDR = (col &gt;&gt; 8) &amp; 0xff; for(i=0; i&lt;10; i++); NFADDR = page &amp; 0xff; for(i=0; i&lt;10; i++); NFADDR = (page &gt;&gt; 8) &amp; 0xff; for(i=0; i&lt;10; i++); NFADDR = (page &gt;&gt; 16) &amp; 0xff; for(i=0; i&lt;10; i++);&#125;void nand_wait_ready()&#123; while(!(NFSTAT &amp; 1));//如果等于0一直循环&#125;unsigned char nand_data(void)&#123; return NFDATA;&#125;void nand_read(unsigned int addr, unsigned char *buf,unsigned int len)&#123; //写：写页数据，生成ECC，ECC➡️OOB(out of bank) //读：读OOB，算出ECC，与之前的ECC比较 //将一整页读入页寄存器 int col = addr / 2048; int i = 0; //1.选中 nand_select(); while(i &lt; len) &#123; //2.发出读命令00h nand_cmd(0x00); //3.发出地址(分5步发出) nand_cmd(addr); //4.发出读命令30h nand_cmd(0x30); //5.判断状态 nand_wait_ready(); //6.读数据 for(; col &lt; 2048 &amp;&amp; i &lt; len; col++) &#123; buf[i] = nand_data(); i++; addr++; &#125; col = 0; &#125; //取消选中&#125; 时序图：nandflash结构：读操作： 12345678910111213141516//u-boot的链接脚本：SECTION&#123; . = 0x33f80000; .text : &#123; *(.text) &#125; . = ALIGN(4); .rodata : (*(.rodata*)) . = ALIGN(4); .data &#123; *(.data) &#125; . = ALIGN(4); __bss_start = .; .bss : &#123; *(.bss) *(COMMON) &#125; __bss_end = .;&#125; 执行main 12ldr lr, =haltldr pc, =main 创建main12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970setup_start_tag()&#123; params = (struct tag *) 0x30000100;//双方约定的存放参数的起始地址 params-&gt;hdr,tag = ATAG_CORE; params-&gt;hdr.size= tag_size(tag_core); params-&gt;u.core.flags = 0; params-&gt;u.core.pagesize = 0; params-&gt;u.core.rooedev = 0; params = tag_next (params);&#125;setup_memory_tags()&#123; params-&gt;hdr.tag = ATAG_MEM; params-&gt;hdr.size = tag_size(tag_mem32); params-&gt;u.mem.start = 0x30000000; params-&gt;u.mem.size = 64*1024*1024; params = tag_next(params);&#125;int strlen(char *str)&#123; int i = 0; while(str[i]) &#123; i++; &#125; return i;&#125;void strcpy(char *dest, char *src)&#123; char *tmp = dest; while((*dest++ = *src++) != '\\0')&#125;setup_commandline_tag()&#123; int len = strlen(cmdline) + 1; params-&gt;hdr.tag = ATAG_CMDLINE; params-&gt;hdr.size = (sizeof(struct tag_header) + len + 3) &gt;&gt; 2; //向4取整 strcpy(params-&gt;u.cmdline.cmdline,p); params = tag_next(params);&#125;setup_end_tag()&#123; params-&gt;hdr.tag = ATAG_NONE; params-&gt;hdr.size = 0;&#125;void main(void)&#123; void (*theKernel)(int zero, int arch, unsigned int params); //0.帮内核设置串口：内核启动时会从串口打印一些信息，但是内核一开始没有初始化串口 uart0_init(); //1.从nandflash把内核读入内存 puts(\"copy kernel\");//向串口发送调试信息 nand_read(0x60000+64, 0x30008000, 0x200000); //2m //2.设置参数 setup_start_tag(); setup_memory_tags(); setup_commandline_tag(\"noinitrd root=/dev/mtdblock3 init=/linuxrc console\"); setup_end_tag(); //3.跳转执行 theKernel = (void (*)(int,int,unsigned int))0x30008000; theKernel(0,362,0x30000100); // mov pc, #0x30008000 // ldr r1, =362 // ldr r2, =0x30000100 // mov pc, #0x30008000&#125;","categories":[{"name":"My bootloader","slug":"My-bootloader","permalink":"http://yoursite.com/categories/My-bootloader/"}],"tags":[{"name":"bootloader","slug":"bootloader","permalink":"http://yoursite.com/tags/bootloader/"}]},{"title":"U-boot","slug":"U-boot","date":"2020-02-28T06:35:16.000Z","updated":"2020-03-05T14:14:47.637Z","comments":true,"path":"2020/02/28/U-boot/","link":"","permalink":"http://yoursite.com/2020/02/28/U-boot/","excerpt":"","text":"U-boot分析嵌入式系统的启动过程 运行bootloader — BIOS 加载linux内核 — windows 挂载根文件系统 — C盘D盘 运行应用程序 — 应用程序 事实上u-boot是一个单片机程序 U-boot编译过程 解压缩 打补丁 &emsp;patch -p &lt;补丁文件 配置 &emsp;make 100sk24x0_config 编译 &emsp;make 启动内核 从FLASH读出内核 放到SDRAM 启动内核 因此u-boot的功能必须有 读flash+写flash内核(为了开发方便) 写flash 网卡 usb 初始化SDRAM 初始化时钟 启动串口 启动内核 读出内核从flash 初始化SDRAM 初始化时钟 关看门狗 通过Makefile分析u-boot u-boot启动的第一个文件：cpu/arm920T/start.s 链接地址 board/你的板子的名字/u-boot.lds 通过设置TEXT_BASE的内容我们可以将代码段在不同的内存地址上运行 u-boot具体初始化过程 u-boot的第一阶段硬件初始化(注：硬件初始化只针对2440开发版) 将CPU模式设置为SVC32(管理模式) 1234mrs r0, cpsrbic r0, r0, #0x1forr r0, r0, #0xd3msr cpsr r0 关看门狗 1234#define pWTCON 0x15300000 ldr r0, =pWTCON mov r1, #0x0 str r1, [r0] 屏蔽中断 123456789#define INTMSK 0x4A000008#define INTSUBMSK 0x4A00001C mov r1, #0xffffffff ldr r0, =INTMSK str r1, [r0]#if defined(CONFIG_S3C2410) ldr r1, =0x3ff ldr r0, =INTSUBMSK str r1, [r0] 初始化时钟 1234#define CLKDIVN 0x4C000014 ldr r0, =CLKDIVN mov r1, #3 str r1, [r0] 初始化SDRAM 12345678910relocate: adr r0, _start ldr r1, _TEXT_BASE cmp r0, r1 beq stack_setup ldr r2, _armboot_start ldr r3, _bss_start sub r2, r3, r2 add r2, r0, r2 设置栈 123456789stack_setup: ldr r0, _TEXT_BASE sub r0, r0, #CONFIG_SYS_MALLOC_LEN sub r0, r0, #CONFIG_SYS_GBL_DATA_SIZE#ifdef CONFIG_USE_IRQ sub r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)#endif sub sp, r0, #12 vic sp, sp, #7 将flash拷到SDRAM 1234567分为从nor flash启动还是从nand flash启动从nor flash直接复制从nand flash启动要进行初始化如何判断是从nor还是nand flash启动？对于norflash 必须通过一定的命令序列才能写数据。所以可以根据这点差别来分辨是从nor还是nand启动向地址0写入一个数据，然后读出来，如果没有改变的话就是nor flash。 清空BSS段(初始值为0的静态变量或全局变量，或者未初始化的静态变量或全局变量) 1234clear_bss: ldr r0, _bss_start ldr r1, _bss_end mov r2, #0x00000000 //clear u-boot的第二阶段，启动内核(c语言实现) 从flash中读出内核 读flash flash_init()函数实现对norflash的初始化 nand_init()函数实现对nandflash的初始化 nand_read函数将kernel分区中的内容读到0x30007FC0地址中(分区由我们自己在flash中指定划分，分区名字不重要，分区名代表起始地址与分区大小)1nand read.jffs2 0x30007FC0 kernel; 启动内核 设置启动参数 跳到入口地址 s=getenv(&quot;bootcmd&quot;) run_command(s) flash上存在的内核：UImage(头部+真正的内核) UImage的头部有加载地址，当do_bootm后面跟的地址与头部的加载地址不同，将内核移到加载地址执行.因此do_bootm后面的地址不一定非要很准确，只要不破坏结构即可。do_bootm(地址);","categories":[{"name":"U-boot","slug":"U-boot","permalink":"http://yoursite.com/categories/U-boot/"}],"tags":[{"name":"bootloader","slug":"bootloader","permalink":"http://yoursite.com/tags/bootloader/"}]},{"title":"03-计算机网络","slug":"03-计算机网络","date":"2020-02-14T09:39:19.000Z","updated":"2020-02-14T09:40:41.765Z","comments":true,"path":"2020/02/14/03-计算机网络/","link":"","permalink":"http://yoursite.com/2020/02/14/03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"计算机网络TCP编程API socket()函数1234#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol) 参数： domin AF_INET AF_INET6 AF_UNIX AF_NETLINK AF_PACKET type SOCK_STREAM &emsp; 流式套接字，唯一对应于TCP SOCK_DGRAM &emsp; 数据报套接字，唯一对应着UDP SOCK_RAW:&emsp; 原始套接字 protocol 一般填0，原始套接字编程时需填充 返回值： 成功时返回文件描述符，出错时返回为-1 bind()函数 1234#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct socketaddr *addr, socklen_t addrlen); 参数 sockfd &emsp; 通过socket()函数拿到的fd addr &emsp; struct sockaddr的结构体变量的地址 如果是IPv6的编程，要使用struct sockaddr_in6结构体，通常更通用的方法可以通过struct sockarrd_storage来编程 addrlen &emsp; 地址长度 listen()函数 1234#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog); 参数 sockfd &emsp; 通过socket()函数拿到的fd backlog &emsp; 同时允许几路客户端进行正在连接的过程(正在三次握手)，一般位5，测试得知，ARM最大为8 内核中服务器的套接字fd会维护2个链表 正在三次握手的客户端链表(数量=2*backlog+1) 已经建立好连接的客户端链表(已经完成3次握手分配好了newfd) 返回值 成功时返回为0，出错时返回-1 accept()函数 阻塞等待客户端连接请求1234#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 参数 sockfd：经过前面socket()创建并通过bind()，listen()设置过的fd 返回值 成功时返回已经建立好连接的新的newfd.","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"02-计算机网络","slug":"02-计算机网络","date":"2020-02-14T09:39:14.000Z","updated":"2020-03-01T07:55:03.448Z","comments":true,"path":"2020/02/14/02-计算机网络/","link":"","permalink":"http://yoursite.com/2020/02/14/02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"计算机网络Socket 是一个编程借口：唯一应用层与传输层中间的接口 是一种特殊的文件描述符(对它执行IO的操作函数，比如read()，write()) 并不仅限于TCP/IP协议 面向连接(TCP/IP) 无连接(UDP和IPX) Socket类型 流式套接字(SOCK_STREAM)：唯一对应着TCP 提供了一个面向连接，可靠的数据传输服务，数据无差错，无重复的发送且按发送顺序接受，内设置流量控制，避免数据流淹没慢的接收方，数据被看作是字节流，无长度限制 数据报套接字(SOCK_DGRAM)：唯一对应着UDP 提供无链接服务。数据包以独立数据包的形式被发送，不提供无差错保证，数据可能丢失或重复，顺序发送，可能乱序接收。 原始套接字(SOCK_RAW)：跨过了传输层，直接到网络层 可以对较低层次协议如IP ICMP直接访问 IP地址 IP地址分为IPv4和IPv6 IPv4:采用32位的整数来表示 IPv6:采用128位的整数来表示 mobile IPv6:local IP(本地注册的IP)，roam IP(漫游IP) IPv4地址： 点分形式：192.168.2.43 特殊IP地址： 局域网IP：192.XXX.XXX.XXX 10.XXX.XXX.XXX 广播地址： XXX.XXX.XXX.255 255.255.255.255(全局广播) 组播IP：224.XXX.XXX.XXX~239.XXX.XXX.XXX 端口号 16位数字(1-65535) 众所周知端口：1～1023(FTP：21，SSH：22，HTTP：80，HTTPS：469) 保留端口：1024～5000(不建议使用) 可以使用的：5000～65535 为了区分一台主机接收到的数据包应该交给哪个任务来处理 TCP端口和UDP端口是相互独立的(都可以用1456) 网络里面的通信是由IP+端口号来决定的 字节序 字节序是指不同的CPU访问内存中的多字节数据时，存在大小端问题 如CPU访问的字符串，则不存在大小端问题 小端序(little-endian) &emsp;-低序字节存储在低字节低对低 大端序(big-endian) &emsp;-低序字节存储在高字节低对高 一般来说： X86/ARM：小端 PowerPc/MIPS，ARM作为路由器时，大端模式 ``网络传输的时候采用大端模式 本地字节序，网络字节序 把给定系统所采用的字节序称为主机字节序。 为了避免不同类别主机之间在数据交换时由于对于字节序不同而导致的差错，引入了网络字节序 主机字节序到网络字节序 u_long htonl (u_long hostlong); u_short htons (u_short short); 网络字节序到主机字节序 u_long ntohl (u_long hostlong); u_short ntohs (u_short short); IP地址转换函数 in_addr_t inet_addr(const char *cp); cp：点分形式的IP地址，结果是32位整数(内部包含了字节序的转换，默认是网络字节序的模式) 仅适用于IPv4 当出错时，返回-1 此函数不能用于255.255.255.255(全位1跟-1区分不开) inet_pton()/inet_ntop(int af, const char* src, void* dst); 适应于IPv4和IPv6 能正确的处理255.255.255.255的转换问题 参数： af：地址协议族(AF_INET或AF_INET^) src:是一个指针(填写点分形式的IP地址) dst:转换的结果给到dst","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"01-计算机网络","slug":"01-计算机网络","date":"2020-02-14T09:36:48.000Z","updated":"2020-02-14T09:39:34.714Z","comments":true,"path":"2020/02/14/01-计算机网络/","link":"","permalink":"http://yoursite.com/2020/02/14/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"计算机网络OSI七层模型 物理层 数据链路层 网络层 传输层 会话层 表示层 应用层网络采用分层的思想 每一层实现不同的功能，对上层的数据做透明传输 每一层向上层提供服务，同时使用下层提供的服务各层典型的协议 网络借口与物理层 MAC地址：48位全球唯一，网络设备的身份标识 ARP/RARP： ARP：IP地址–&gt;MAC地址 RARP：MAC地址–&gt;IP地址 PPP协议：拨号协议(GPRS/3G/4G) 网络层 IP：Internet protocol(分为IPv4和IPv6) ICMP：Internet控制管理协议，ping命令属于ICMP，端到端 IGMP：Internet分组管理协议，广播，组播 传输层 TCP(Transfer control protocol)提供面向连接的，一对一的可靠数据传输的协议即数据无误，数据无丢失，数据无失序，数据无重复到达的通信 UDP(user Datagram protocol)提供不可靠无链接的尽力传输协议是不可靠的无链接协议，在数据发送前，不需要连接，所以可以进行高效率的数据传输 SCTP：可靠传输，是TCP的增强版，它能实现多主机，多链路的通信 应用层 网页访问协议：HTTP/HTTPS 邮件发送接受协议：POP3(收)/SMTP(发)，IMAP(可接受邮件的一部分) FTP Talent/SSH：远程登陆 嵌入式相关： NTP：网络时钟协议 SNMP：简单网络管理协议 RTP/RTSP：用传输音视频的协议，用于安防监控，事实上这个协议是TCP+UDP来实现的","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"IIC协议时序分析","slug":"IIC","date":"2020-02-12T02:52:02.000Z","updated":"2020-02-12T06:28:09.343Z","comments":true,"path":"2020/02/12/IIC/","link":"","permalink":"http://yoursite.com/2020/02/12/IIC/","excerpt":"","text":"IIC协议时序分析IIC简介IIC（Inter-Integrated Circuit）其实是IICBus简称，所以中文应该叫集成电路总线，它是一种串行通信总线，使用多主从架构，由飞利浦公司在1980年代为了让主板、嵌入式系统或手机用以连接低速周边设备而发展。 IIC组成IIC串行总线一般有两根信号线，一根是双向的数据线SDA，另一根是时钟线SCL。所有接到IIC总线设备上的串行数据SDA都接到总线的SDA上，各设备的时钟线SCL接到总线的SCL上。空闲状态：SCL高电平 SDA高电平 IIC具体协议时序开始停止信号代码实现： 1234567891011121314151617181920212223242526272829303132333435363738void IIC_Start(void)&#123; I2C2_SDA_H; //拉高数据线 I2C2_SCL_H; //拉高时钟线 I2C2_delay();//现在延时为16us， 5 I2C2_SDA_L; //产生下降沿 I2C2_delay(); I2C2_SCL_L;//拉低时钟线，钳住I2C总线，准备发数据或者接受数据&#125;void IIC_Stop(void)&#123; I2C2_SCL_L; I2C2_delay(); I2C2_SDA_L; //停止，CLK上升沿 I2C2_delay(); I2C2_SCL_H; //拉高时钟线 I2C2_delay(); I2C2_SDA_H; //拉高数据线，结束信号 I2C2_delay();&#125; 数据传输 每一个字节必须保证是8位长度。数据传输时，先传送最高位(MSB)，每一个被传送的字节后面都必须跟随一位应答位，即一帧共有9位。 代码实现： 123456789101112131415161718192021222324252627282930313233void write_byte(unsigned char dat)&#123; unsigned char i = 0; for(i = 0; i &lt; 8; i++) &#123; dat = dat&lt;&lt;1; I2C2_SCL_L; delay(); SDA = CY; //类似于8086的PSW的CF位 即左移data溢出位进入CY delay(); I2C2_SCL_H; delay(); &#125; I2C2_SCL_L; delay(); I2C2_SDA_H; delay();&#125;unsigned char read_byte()&#123; unsigned char i = 0, dat; I2C2_SCL_L; delay(); I2C2_SDA_H; for(i = 0; i &lt; 8; i++) &#123; I2C2_SCL_H; delay(); dat = (dat&lt;&lt;1) | SDA; I2C2_SCL_L; delay(); &#125; return dat;&#125; 应答当IIC主机(不一定是发送端还是接收端)将8位数据或命令传出后，会将SDA信号设置为输入，等待从机应答(等待SDA由高电平拉为低电平)若从机正确应答，表示数据或命令传输成功，否则传输失败。注意：应答信号是数据接收方发送给数据发送方的。代码实现： 12345678910111213141516171819void Respons()&#123; I2C2_SDA_L; delay(); I2C2_SCL_H; delay(); I2C2_SCL_L; delay();&#125;void NoRespons()&#123; I2C2_SDA_H; delay(); I2C2_SCL_H; delay(); I2C2_SCL_L; delay();&#125;","categories":[{"name":"总线协议","slug":"总线协议","permalink":"http://yoursite.com/categories/%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"IIC","slug":"IIC","permalink":"http://yoursite.com/tags/IIC/"}]},{"title":"04-shell","slug":"04-shell","date":"2020-02-10T08:15:17.000Z","updated":"2020-02-10T08:18:50.901Z","comments":true,"path":"2020/02/10/04-shell/","link":"","permalink":"http://yoursite.com/2020/02/10/04-shell/","excerpt":"","text":"shell基础-函数hell函数调用 函数调用格式： 方式1：1value_name=`function_name [arg1 arg2...]` 方式2：12function_name [arg1 arg2...]echo $? 例子：1234567891011grep_user()&#123; R=`grep \"$1\" /etc/passwd | wc -l` echo $S return $R&#125;echo -n \"input username:\"read USERgrep_user $USERecho \"-$?-\" 函数变量的作用域 全局作用域：在脚本得其他任何地方都能够访问该变量 局部作用域：只能在声明变量得作用域内访问 声明局部变量得格式：1local variable_name=value 全部变量得声明 1variable_name=value","categories":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/categories/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"03-shell","slug":"03-shell","date":"2020-02-10T08:15:13.000Z","updated":"2020-02-10T08:18:24.763Z","comments":true,"path":"2020/02/10/03-shell/","link":"","permalink":"http://yoursite.com/2020/02/10/03-shell/","excerpt":"","text":"shell基础-循环语句循环语句for的用法 当循环次数已知或确定时，使用for循环语句来多次执行一条或一组命令。 1234for 变量名 in 单词表 do 命令表 done 也可以使用类语法来实现for循环 1234for ((I = 1; i &lt;= 10; I++))do echo \"I=$I\"done 循环语句while的用法 while语句先测试其后的命令或表达式的值，如果为真，就执行一次循环体中的命令，然后再测试该命令或表达式的值，执行循环体，知道该命令或表达式为假时退出循环. 1234while 命令或表达式 do 命令表 done 例子： 1234567891011121314151617181920#！/bin/bashI=0while [ $I -lt 5 ]do I=`expr $I + 1` echo -n \"input score:\" read S case `expr $S / 10` in 10|9) echo \"A\" ;; 6|7|8) echo \"B\" ;; *) echo \"C\" ;; esacdone 循环控制语句 break break n&#8195;则跳出n层 continue continue语句则马上转到最近一层循环语句的下一轮循环上 continue&#8195;n则转到最近n层循环语句的下一轮循环上","categories":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/categories/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"02-shell","slug":"02-shell","date":"2020-02-09T15:16:28.000Z","updated":"2020-02-10T08:12:06.562Z","comments":true,"path":"2020/02/09/02-shell/","link":"","permalink":"http://yoursite.com/2020/02/09/02-shell/","excerpt":"","text":"shell基础-分支语句条件语句 条件语句123if 表达式 then 命令表fi 如果表达式为真，则执行命令表中的命令；否则退出if语句，即执行`fi后面的语句 if和fi时条件语句的语句括号，`必须成对使用 命令表中的命令可以是一条，也可以时若干条1234567#！/bin/bashif[ $# -ne 1]then echo \"usage:$0 filename\" exitfi 1234if 表达式then 命令表1else 命令表2fi 如果表达式为真，则执行命令表1中的命令，再退出if语句，否则执行命令表2中的语句，再退出if语句12345678910111213#！/bin/bashif [ -d $1 ]then echo \"$1 is a directory\" exitelse if [ -f $1 ] then echo \"$1 is a common file\" else echo \"unknown\" fifi 多路分支语句 多路分支语句 多路分支语句case用于多重条件测试，语法结构清晰自然 12345678910case 字符串变量 in 模式1) 命令表1 ;; 模式2 | 模式3) 命令表2 ...... 模式n) 命令表nesac 双分号等同于c语言中的break","categories":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/categories/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"01-shell","slug":"01-shell","date":"2020-02-09T15:16:17.000Z","updated":"2020-02-10T08:12:23.010Z","comments":true,"path":"2020/02/09/01-shell/","link":"","permalink":"http://yoursite.com/2020/02/09/01-shell/","excerpt":"","text":"shell脚本基础echo命令： echo &quot;字符串&quot; echo -n “字符串”&#8195;表示不换行 echo $?&#8195; 表示上一条语句的执行结果，0表示真，非0表示假 expr命令：算术运算命令expr主要用于简单的整数运算，包括(+),(-),(*),(/)和求模(%)等操作： 123$ expr 12 + 5 \\* 3$ expr 3 - 8 / 2$ A=expr 12 + 5 \\* 3 注:算数运算两边必须加空格，赋值语句两边不能加空格 test命令：test语句可测试三种对象 字符串 整数 文件属性 字符串模式 s1 = s2&#8195;测试两个字符串的内容是否完全一样 s1 ！= s2&#8195; 测试两个字符串的内容是否有差异 -z s1&#8195; 测试s1字符串的长度是否为0 -n s1&#8195; 测试s1字符串的长度是否不为0 整数 a -eq b&#8195; 测试a与b是否相等 a -ne b&#8195; 测试a与b是否不相等 a -gt b&#8195; 测试a是否大于b a -ge b&#8195; 测试a是否大于等于b a -lt b&#8195; 测试a是否小于b a -le b&#8195; 测试a是否小于等于b 文件属性 -d name&#8195; 测试name是否为一个目录 -e name&#8195; 测试一个文件是否存在 -f name&#8195; 测试name是否为普通文件 -L name&#8195; 测试name是否为符号链接 -r name&#8195; 测试name文件是否存在且为可读 -w name&#8195; 测试name文件是否存在且为可写 -x name&#8195; 测试name文件是否存在且为可执行 -s name&#8195; 测试name文件是否存在且其长度不为0 f1 -nt f2&#8195; 测试文件f1是否比文件f2更新 f1 -ot f2&#8195; 测试文件f1是否比文件f2更旧","categories":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/categories/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"03-makefile","slug":"03-makefile","date":"2020-02-04T15:11:23.000Z","updated":"2020-02-12T05:53:08.649Z","comments":true,"path":"2020/02/04/03-makefile/","link":"","permalink":"http://yoursite.com/2020/02/04/03-makefile/","excerpt":"","text":"MakefileVPATH的用法 VPATH：虚路径 在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录里。所以，当make需要去寻找文件的依赖关系时，你可以在文件前加上路径，但最好的方法时把一个路径告诉make，让make自动去寻找。 Makefile文件中的特殊变量”VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件，到所指定的目录中去找寻文件了。 VPATH = src:../headers 上面的定义指定两个目录，&quot;src&quot;和&quot;../headers&quot;, make会按照这个顺序进行搜索，目录由”冒号”分隔。(当然，当前目录永远是最高优先搜索的地方)","categories":[{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/categories/makefile/"}],"tags":[{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/tags/makefile/"}]},{"title":"02-makefile","slug":"02-makefile","date":"2020-02-04T13:31:22.000Z","updated":"2020-02-10T15:26:32.485Z","comments":true,"path":"2020/02/04/02-makefile/","link":"","permalink":"http://yoursite.com/2020/02/04/02-makefile/","excerpt":"","text":"Makefilemake使用 直接运行make 选项 -C &#8195; dir读入指定目录下的Makefile -f &#8195; file读入 -i &#8195; 忽略所有的命令执行错误 -I &#8195; dir指定被包含的Makefile所在目录 -n &#8195; 只打印要执行的命令，但不执行这些命令 -p &#8195; 显示make变量数据库和隐含规则 -s &#8195; 在执行命令时不显示命令 -w &#8195; 如果make在执行过程中改变目录，打印当前目录名 makefile可以include + 文件名来引用其他文件中的内容Makefile的隐含规则 隐含规则1：编译c程序的隐含规则 “&lt;n&gt;.o”的目标的依赖目标会自动推导为”&lt;n&gt;.c”，并且其生成命令是”$(CC) -c $(CPPFLAGS) $(CFLAGS)” 隐含规则2：链接Object文件的隐含规则 “&lt;n&gt;”目标依赖于”&lt;n&gt;.o”，通过运行c的编译器来运行连接程序生成(一般是”ld”)，其生成命令是：”$(CC) $(LDFLAGS) &lt;n&gt;.o” $(LOADLIBES) $(LDLIBS)。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件(由不同的源文件生成)的也有效","categories":[{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/categories/makefile/"}],"tags":[{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/tags/makefile/"}]},{"title":"01-makefile","slug":"01-makefile","date":"2020-02-04T10:27:54.000Z","updated":"2020-02-10T15:26:30.415Z","comments":true,"path":"2020/02/04/01-makefile/","link":"","permalink":"http://yoursite.com/2020/02/04/01-makefile/","excerpt":"","text":"MakefileMake简介 工程管理器，顾名思义，是指管理较多得文件 Make工程管理器也就是个自动编译管理器，这里得自动是指它能够根据文件时间戳自动发现更新过得文件而减少编译得工作量，同时，它通过读入Makefile文件得内容来执行大量得编译工作。 Make将只编译改动的代码文件，而不用完全编译Makefile基本结构 Makefile是Make读入的唯一配置文件 由make工具创建的目标体(target)，通常是目标文件或可执行文件 要创建的目标体所依赖的文件(dependency_file) 创建每个目标体时需要运行的命令(command) 注意：命令行前面必须是一个”TAB键”，否则编译错误 Makefile格式 12target : dependency_files&lt;TAB&gt; command 例子 12hello : hello.c hello.h gcc -c hello.c -o hello.o 更复杂的例子 123456sunq : kang.o yul.o gcc kang.o yul.o -o sunqkang.o : kang.c kang.h gcc -Wall -O -g -c kang.c -o kang.oyul : yul.c gcc -Wall -O -g -c yul.c -o yul.o 注释： -WALL表示允许发出gcc所有有用的报警信息 -c只是编译不链接，生成目标文件”.o” -o file:表示把输出文件输出到file里创建和使用变量 创建变量的目的： 用来代替一个文本字符串： 系列文件的名字 传递给编译器的参数 需要运行的程序 需要查找源代码的目录 你需要输出信息的目录 你想做的其他事情 变量定义的两种方式 递归展开方式VAR=var 简单方式VAR:=var 变量使用$(VAR) 用$则用$$来表示 类似于编程语言中的宏定义 刚才的例子： 12345foo=$(bar)bar=$(ugh)ugh=Huh?$(foo)的值为?echo $(foo)来进行查看 优点：它可以向后引用变量 缺点：不能对该变量进行任何扩展 用?=定义变量&#8195;dir:=/foo/bar&#8195;FOO?=bar&#8195;FOO是? FOO之前没被定义过则被定义为bar 预定义变量 AR &#8195; 库文件维护程序的名称，默认值为ar CC &#8195; C编译器的名称，默认值为cc。CPP&#8195;C预编译器的名称，默认值为$(CC) -E CXX &#8195; C++编译器的名称，默认值为g++ FC &#8195; FORTRAN编译器的名称，默认值为f77 RM &#8195; 文件删除程序的名称，默认值为rm -f 自动变量 $* &#8195; 不包含扩展名的目标文件名称 $+ &#8195; 所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件 $&lt; &#8195; 第一个依赖文件的名称 $? &#8195; 所有时间戳比目标文件晚的依赖文件，并以空格分开 $@ &#8195; 目标文件的完整名称 $^ &#8195; 所有不重复的目标依赖文件，以空格分开 $% &#8195; 如果目标是归档成员，则改变量表示目标的归档成员名称 刚才的例子： 123456789OBJS = kang.o yul.oCC = gccCFLAGS = -Wall -O -gsunq : $(OBJS) $(CC) $^ -o $@kang.o : kang.c kang.h $(CC) $(CFLAGS) -c $&lt; -o $@yul.o : yul.c yul.h $(CC) $(CFLAGS) -c $&lt; -o $@ 环境变量 make在启动时会自动读取系统当前已经定义了的环境变量，而且会创建与之具有相同名称和数值的变量 如果用户在Makefile中定义了相同名称的变量，那么用户自定义变量将会覆盖同名的环境变量","categories":[{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/categories/makefile/"}],"tags":[{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/tags/makefile/"}]}]}