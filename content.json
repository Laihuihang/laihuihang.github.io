{"meta":{"title":"嵌入式小菜鸡","subtitle":"","description":"","author":"Huihang Lai","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2020-02-09T14:28:09.857Z","updated":"2020-02-09T14:28:09.857Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"","date":"2020-02-09T13:43:29.323Z","updated":"2020-02-09T13:43:29.323Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-02-09T13:43:22.220Z","updated":"2020-02-09T13:43:22.220Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-02-10T15:18:14.484Z","updated":"2020-02-09T13:43:15.028Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"IIC","slug":"IIC","date":"2020-02-12T02:52:02.000Z","updated":"2020-02-12T06:08:50.658Z","comments":true,"path":"2020/02/12/IIC/","link":"","permalink":"http://yoursite.com/2020/02/12/IIC/","excerpt":"","text":"IIC协议时序分析IIC简介IIC（Inter-Integrated Circuit）其实是IICBus简称，所以中文应该叫集成电路总线，它是一种串行通信总线，使用多主从架构，由飞利浦公司在1980年代为了让主板、嵌入式系统或手机用以连接低速周边设备而发展。 IIC组成IIC串行总线一般有两根信号线，一根是双向的数据线SDA，另一根是时钟线SCL。所有接到IIC总线设备上的串行数据SDA都接到总线的SDA上，各设备的时钟线SCL接到总线的SCL上。空闲状态：SCL高电平 SDA高电平 IIC具体协议时序起始：SCL高 SDA出现下降沿代码实现： 1234567891011121314151617void IIC_Start(void)&#123; I2C2_SDA_H; //拉高数据线 I2C2_SCL_H; //拉高时钟线 I2C2_delay();//现在延时为16us， 5 I2C2_SDA_L; //产生下降沿 I2C2_delay(); I2C2_SCL_L;//拉低时钟线，钳住I2C总线，准备发数据或者接受数据&#125; 终止：SCL高 SDA出现上升沿代码实现： 123456789101112131415161718192021void IIC_Stop(void)&#123; I2C2_SCL_L; I2C2_delay(); I2C2_SDA_L; //停止，CLK上升沿 I2C2_delay(); I2C2_SCL_H; //拉高时钟线 I2C2_delay(); I2C2_SDA_H; //拉高数据线，结束信号 I2C2_delay();&#125; 数据传输 每一个字节必须保证是8位长度。数据传输时，先传送最高位(MSB)，每一个被传送的字节后面都必须跟随一位应答位，即一帧共有9位。 代码实现： 123456789101112131415161718192021222324252627282930313233void write_byte(unsigned char dat)&#123; unsigned char i = 0; for(i = 0; i &lt; 8; i++) &#123; dat = dat&lt;&lt;1; I2C2_SCL_L; delay(); SDA = CY; //类似于8086的PSW的CF位 即左移data溢出位进入CY delay(); I2C2_SCL_H; delay(); &#125; I2C2_SCL_L; delay(); I2C2_SDA_H; delay();&#125;unsigned char read_byte()&#123; unsigned char i = 0, dat; I2C2_SCL_L; delay(); I2C2_SDA_H; for(i = 0; i &lt; 8; i++) &#123; I2C2_SCL_H; delay(); dat = (dat&lt;&lt;1) | SDA; I2C2_SCL_L; delay(); &#125; return dat;&#125; 应答当IIC主机(不一定是发送端还是接收端)将8位数据或命令传出后，会将SDA信号设置为输入，等待从机应答(等待SDA由高电平拉为低电平)若从机正确应答，表示数据或命令传输成功，否则传输失败。注意：应答信号是数据接收方发送给数据发送方的。代码实现： 12345678910111213141516171819void Respons()&#123; I2C2_SDA_L; delay(); I2C2_SCL_H; delay(); I2C2_SCL_L; delay();&#125;void NoRespons()&#123; I2C2_SDA_H; delay(); I2C2_SCL_H; delay(); I2C2_SCL_L; delay();&#125;","categories":[{"name":"总线协议","slug":"总线协议","permalink":"http://yoursite.com/categories/%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"IIC","slug":"IIC","permalink":"http://yoursite.com/tags/IIC/"}]},{"title":"04-shell","slug":"04-shell","date":"2020-02-10T08:15:17.000Z","updated":"2020-02-10T08:18:50.901Z","comments":true,"path":"2020/02/10/04-shell/","link":"","permalink":"http://yoursite.com/2020/02/10/04-shell/","excerpt":"","text":"shell基础-函数hell函数调用 函数调用格式： 方式1：1value_name=`function_name [arg1 arg2...]` 方式2：12function_name [arg1 arg2...]echo $? 例子：1234567891011grep_user()&#123; R=`grep \"$1\" /etc/passwd | wc -l` echo $S return $R&#125;echo -n \"input username:\"read USERgrep_user $USERecho \"-$?-\" 函数变量的作用域 全局作用域：在脚本得其他任何地方都能够访问该变量 局部作用域：只能在声明变量得作用域内访问 声明局部变量得格式：1local variable_name=value 全部变量得声明 1variable_name=value","categories":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/categories/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"03-shell","slug":"03-shell","date":"2020-02-10T08:15:13.000Z","updated":"2020-02-10T08:18:24.763Z","comments":true,"path":"2020/02/10/03-shell/","link":"","permalink":"http://yoursite.com/2020/02/10/03-shell/","excerpt":"","text":"shell基础-循环语句循环语句for的用法 当循环次数已知或确定时，使用for循环语句来多次执行一条或一组命令。 1234for 变量名 in 单词表 do 命令表 done 也可以使用类语法来实现for循环 1234for ((I = 1; i &lt;= 10; I++))do echo \"I=$I\"done 循环语句while的用法 while语句先测试其后的命令或表达式的值，如果为真，就执行一次循环体中的命令，然后再测试该命令或表达式的值，执行循环体，知道该命令或表达式为假时退出循环. 1234while 命令或表达式 do 命令表 done 例子： 1234567891011121314151617181920#！/bin/bashI=0while [ $I -lt 5 ]do I=`expr $I + 1` echo -n \"input score:\" read S case `expr $S / 10` in 10|9) echo \"A\" ;; 6|7|8) echo \"B\" ;; *) echo \"C\" ;; esacdone 循环控制语句 break break n&#8195;则跳出n层 continue continue语句则马上转到最近一层循环语句的下一轮循环上 continue&#8195;n则转到最近n层循环语句的下一轮循环上","categories":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/categories/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"02-shell","slug":"02-shell","date":"2020-02-09T15:16:28.000Z","updated":"2020-02-10T08:12:06.562Z","comments":true,"path":"2020/02/09/02-shell/","link":"","permalink":"http://yoursite.com/2020/02/09/02-shell/","excerpt":"","text":"shell基础-分支语句条件语句 条件语句123if 表达式 then 命令表fi 如果表达式为真，则执行命令表中的命令；否则退出if语句，即执行`fi后面的语句 if和fi时条件语句的语句括号，`必须成对使用 命令表中的命令可以是一条，也可以时若干条1234567#！/bin/bashif[ $# -ne 1]then echo \"usage:$0 filename\" exitfi 1234if 表达式then 命令表1else 命令表2fi 如果表达式为真，则执行命令表1中的命令，再退出if语句，否则执行命令表2中的语句，再退出if语句12345678910111213#！/bin/bashif [ -d $1 ]then echo \"$1 is a directory\" exitelse if [ -f $1 ] then echo \"$1 is a common file\" else echo \"unknown\" fifi 多路分支语句 多路分支语句 多路分支语句case用于多重条件测试，语法结构清晰自然 12345678910case 字符串变量 in 模式1) 命令表1 ;; 模式2 | 模式3) 命令表2 ...... 模式n) 命令表nesac 双分号等同于c语言中的break","categories":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/categories/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"01-shell","slug":"01-shell","date":"2020-02-09T15:16:17.000Z","updated":"2020-02-10T08:12:23.010Z","comments":true,"path":"2020/02/09/01-shell/","link":"","permalink":"http://yoursite.com/2020/02/09/01-shell/","excerpt":"","text":"shell脚本基础echo命令： echo &quot;字符串&quot; echo -n “字符串”&#8195;表示不换行 echo $?&#8195; 表示上一条语句的执行结果，0表示真，非0表示假 expr命令：算术运算命令expr主要用于简单的整数运算，包括(+),(-),(*),(/)和求模(%)等操作： 123$ expr 12 + 5 \\* 3$ expr 3 - 8 / 2$ A=expr 12 + 5 \\* 3 注:算数运算两边必须加空格，赋值语句两边不能加空格 test命令：test语句可测试三种对象 字符串 整数 文件属性 字符串模式 s1 = s2&#8195;测试两个字符串的内容是否完全一样 s1 ！= s2&#8195; 测试两个字符串的内容是否有差异 -z s1&#8195; 测试s1字符串的长度是否为0 -n s1&#8195; 测试s1字符串的长度是否不为0 整数 a -eq b&#8195; 测试a与b是否相等 a -ne b&#8195; 测试a与b是否不相等 a -gt b&#8195; 测试a是否大于b a -ge b&#8195; 测试a是否大于等于b a -lt b&#8195; 测试a是否小于b a -le b&#8195; 测试a是否小于等于b 文件属性 -d name&#8195; 测试name是否为一个目录 -e name&#8195; 测试一个文件是否存在 -f name&#8195; 测试name是否为普通文件 -L name&#8195; 测试name是否为符号链接 -r name&#8195; 测试name文件是否存在且为可读 -w name&#8195; 测试name文件是否存在且为可写 -x name&#8195; 测试name文件是否存在且为可执行 -s name&#8195; 测试name文件是否存在且其长度不为0 f1 -nt f2&#8195; 测试文件f1是否比文件f2更新 f1 -ot f2&#8195; 测试文件f1是否比文件f2更旧","categories":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/categories/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"03-makefile","slug":"03-makefile","date":"2020-02-04T15:11:23.000Z","updated":"2020-02-12T05:53:08.649Z","comments":true,"path":"2020/02/04/03-makefile/","link":"","permalink":"http://yoursite.com/2020/02/04/03-makefile/","excerpt":"","text":"MakefileVPATH的用法 VPATH：虚路径 在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录里。所以，当make需要去寻找文件的依赖关系时，你可以在文件前加上路径，但最好的方法时把一个路径告诉make，让make自动去寻找。 Makefile文件中的特殊变量”VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件，到所指定的目录中去找寻文件了。 VPATH = src:../headers 上面的定义指定两个目录，&quot;src&quot;和&quot;../headers&quot;, make会按照这个顺序进行搜索，目录由”冒号”分隔。(当然，当前目录永远是最高优先搜索的地方)","categories":[{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/categories/makefile/"}],"tags":[{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/tags/makefile/"}]},{"title":"02-makefile","slug":"02-makefile","date":"2020-02-04T13:31:22.000Z","updated":"2020-02-10T15:26:32.485Z","comments":true,"path":"2020/02/04/02-makefile/","link":"","permalink":"http://yoursite.com/2020/02/04/02-makefile/","excerpt":"","text":"Makefilemake使用 直接运行make 选项 -C &#8195; dir读入指定目录下的Makefile -f &#8195; file读入 -i &#8195; 忽略所有的命令执行错误 -I &#8195; dir指定被包含的Makefile所在目录 -n &#8195; 只打印要执行的命令，但不执行这些命令 -p &#8195; 显示make变量数据库和隐含规则 -s &#8195; 在执行命令时不显示命令 -w &#8195; 如果make在执行过程中改变目录，打印当前目录名 makefile可以include + 文件名来引用其他文件中的内容Makefile的隐含规则 隐含规则1：编译c程序的隐含规则 “&lt;n&gt;.o”的目标的依赖目标会自动推导为”&lt;n&gt;.c”，并且其生成命令是”$(CC) -c $(CPPFLAGS) $(CFLAGS)” 隐含规则2：链接Object文件的隐含规则 “&lt;n&gt;”目标依赖于”&lt;n&gt;.o”，通过运行c的编译器来运行连接程序生成(一般是”ld”)，其生成命令是：”$(CC) $(LDFLAGS) &lt;n&gt;.o” $(LOADLIBES) $(LDLIBS)。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件(由不同的源文件生成)的也有效","categories":[{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/categories/makefile/"}],"tags":[{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/tags/makefile/"}]},{"title":"01-makefile","slug":"01-makefile","date":"2020-02-04T10:27:54.000Z","updated":"2020-02-10T15:26:30.415Z","comments":true,"path":"2020/02/04/01-makefile/","link":"","permalink":"http://yoursite.com/2020/02/04/01-makefile/","excerpt":"","text":"MakefileMake简介 工程管理器，顾名思义，是指管理较多得文件 Make工程管理器也就是个自动编译管理器，这里得自动是指它能够根据文件时间戳自动发现更新过得文件而减少编译得工作量，同时，它通过读入Makefile文件得内容来执行大量得编译工作。 Make将只编译改动的代码文件，而不用完全编译Makefile基本结构 Makefile是Make读入的唯一配置文件 由make工具创建的目标体(target)，通常是目标文件或可执行文件 要创建的目标体所依赖的文件(dependency_file) 创建每个目标体时需要运行的命令(command) 注意：命令行前面必须是一个”TAB键”，否则编译错误 Makefile格式 12target : dependency_files&lt;TAB&gt; command 例子 12hello : hello.c hello.h gcc -c hello.c -o hello.o 更复杂的例子 123456sunq : kang.o yul.o gcc kang.o yul.o -o sunqkang.o : kang.c kang.h gcc -Wall -O -g -c kang.c -o kang.oyul : yul.c gcc -Wall -O -g -c yul.c -o yul.o 注释： -WALL表示允许发出gcc所有有用的报警信息 -c只是编译不链接，生成目标文件”.o” -o file:表示把输出文件输出到file里创建和使用变量 创建变量的目的： 用来代替一个文本字符串： 系列文件的名字 传递给编译器的参数 需要运行的程序 需要查找源代码的目录 你需要输出信息的目录 你想做的其他事情 变量定义的两种方式 递归展开方式VAR=var 简单方式VAR:=var 变量使用$(VAR) 用$则用$$来表示 类似于编程语言中的宏定义 刚才的例子： 12345foo=$(bar)bar=$(ugh)ugh=Huh?$(foo)的值为?echo $(foo)来进行查看 优点：它可以向后引用变量 缺点：不能对该变量进行任何扩展 用?=定义变量&#8195;dir:=/foo/bar&#8195;FOO?=bar&#8195;FOO是? FOO之前没被定义过则被定义为bar 预定义变量 AR &#8195; 库文件维护程序的名称，默认值为ar CC &#8195; C编译器的名称，默认值为cc。CPP&#8195;C预编译器的名称，默认值为$(CC) -E CXX &#8195; C++编译器的名称，默认值为g++ FC &#8195; FORTRAN编译器的名称，默认值为f77 RM &#8195; 文件删除程序的名称，默认值为rm -f 自动变量 $* &#8195; 不包含扩展名的目标文件名称 $+ &#8195; 所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件 $&lt; &#8195; 第一个依赖文件的名称 $? &#8195; 所有时间戳比目标文件晚的依赖文件，并以空格分开 $@ &#8195; 目标文件的完整名称 $^ &#8195; 所有不重复的目标依赖文件，以空格分开 $% &#8195; 如果目标是归档成员，则改变量表示目标的归档成员名称 刚才的例子： 123456789OBJS = kang.o yul.oCC = gccCFLAGS = -Wall -O -gsunq : $(OBJS) $(CC) $^ -o $@kang.o : kang.c kang.h $(CC) $(CFLAGS) -c $&lt; -o $@yul.o : yul.c yul.h $(CC) $(CFLAGS) -c $&lt; -o $@ 环境变量 make在启动时会自动读取系统当前已经定义了的环境变量，而且会创建与之具有相同名称和数值的变量 如果用户在Makefile中定义了相同名称的变量，那么用户自定义变量将会覆盖同名的环境变量","categories":[{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/categories/makefile/"}],"tags":[{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/tags/makefile/"}]}]}