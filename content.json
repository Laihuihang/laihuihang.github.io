{"meta":{"title":"NULL的Blog","subtitle":"","description":"","author":"Huihang Lai","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2020-02-09T14:28:09.857Z","updated":"2020-02-09T14:28:09.857Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-02-10T15:18:14.484Z","updated":"2020-02-09T13:43:15.028Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-02-09T13:43:29.323Z","updated":"2020-02-09T13:43:29.323Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-02-09T13:43:22.220Z","updated":"2020-02-09T13:43:22.220Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"前中后序遍历","slug":"前中后序遍历","date":"2020-09-03T16:05:57.000Z","updated":"2020-09-04T10:41:00.363Z","comments":true,"path":"2020/09/04/前中后序遍历/","link":"","permalink":"http://yoursite.com/2020/09/04/%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"递归众所周知，前中后序用递归方法来实现非常的简洁易懂，但是在面试中面试官大概率不会让你用递归算法来实现前中后序遍历，第一步我们先通过简单的递归来实现前中后序遍历。 前序遍历12345678void trackback(TreeNode* root, vector&lt;int&gt;&amp; vec)&#123; if(root == NULL) return; vec.push_back(root-&gt;val); trackback(root-&gt;left); trackback(root-&gt;right);&#125; 中序遍历123456789void trackback(TreeNode* root, vector&lt;int&gt;&amp; vec)&#123; if(root == NULL) return; trackback(root-&gt;left); vec.push_back(root-&gt;val); trackback(root-&gt;right);&#125; 后序遍历12345678void trackback(TreeNode* root, vector&lt;int&gt;&amp; vec)&#123; if(root == NULL) return; trackback(root-&gt;left); trackback(root-&gt;right); vec.push_back(root-&gt;val);&#125; 迭代当使用迭代来进行前中后序遍历时，前序跟中序很难有统一的写法，主要是由于前序跟中序遍历处理顺序与访问顺序不一致，前序遍历先访问的元素是中间节点，要处理的节点也是中间节点，但是中序遍历是一层一层向下访问，直到到达树左面的最底层，再开始处理节点。 前序遍历12345678910111213141516vector&lt;int&gt; preOrder(TreeNode* root)&#123; vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; st; st.push(root); while(!st.empty()) &#123; TreeNode* cur = st.top(); st.pop(); if(cur) ret.push_back(cur-&gt;val); else continue; st.push(cur-&gt;left); st.push(cur-&gt;right); &#125; return ret;&#125; 中序遍历12345678910111213141516171819202122void inOrder(TreeNode* root)&#123; vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; st; TreeNode* cur = root; while(cur != NULL || !st.empty()) &#123; if(cur != NULL) &#123; st.push(cur); cur = cur-&gt;left; &#125; else &#123; cur = st.top(); st.pop(); ret.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; &#125; return ret;&#125; 后序遍历1234567891011121314151617vector&lt;int&gt; postOrder(TreeNode* root)&#123; vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; st; st.push(root); while(!st.empty()) &#123; TreeNode* cur = st.top(); st.pop(); if(cur) ret.push_back(cur-&gt;val); else continue; st.push(cur-&gt;left); st.push(cur-&gt;right); &#125; reverse(ret.begin(), ret.end()); return ret;&#125; 统一写法最后给出一种统一的写法来实现前中后序遍历，解决方法是通过将访问的节点放入栈中，把要处理的节点也放入栈中，但是要做标记，标记就是要处理的节点放入栈之后，紧接着放入空指针作为标记。 前序遍历1234567891011121314151617181920212223242526void preOrder(TreeNode* root)&#123; vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; st; if(root != NULL) st.push(root); while(!st.empty()) &#123; TreeNode* cur = st.top(); if(cur != NULL) &#123; st.pop(); if(cur-&gt;right) st.push(cur-&gt;right);//右 if(cur-&gt;left) st.push(cur-&gt;left);//左 st.push(cur);//中 st.push(NULL); &#125; else &#123; st.pop(); cur = st.top(); st.pop(); ret.push_back(cur-&gt;val); &#125; &#125; return ret;&#125; 中序遍历1234567891011121314151617181920212223242526void inOrder(TreeNode* root)&#123; vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; st; if(root != NULL) st.push(root); while(!st.empty()) &#123; TreeNode* cur = st.top(); if(cur != NULL) &#123; st.pop(); if(cur-&gt;right) st.push(cur-&gt;right);//右 st.push(cur);//中 st.push(NULL); if(cur-&gt;left) st.push(cur-&gt;left);//左 &#125; else &#123; st.pop(); cur = st.top(); st.pop(); ret.push_back(cur-&gt;val); &#125; &#125; return ret;&#125; 后序遍历1234567891011121314151617181920212223242526void postrder(TreeNode* root)&#123; vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; st; if(root != NULL) st.push(root); while(!st.empty()) &#123; TreeNode* cur = st.top(); if(cur != NULL) &#123; st.pop(); t.push(cur);//中 st.push(NULL); if(cur-&gt;right) st.push(cur-&gt;right);//右 if(cur-&gt;left) st.push(cur-&gt;left);//左 &#125; else &#123; st.pop(); cur = st.top(); st.pop(); ret.push_back(cur-&gt;val); &#125; &#125; return ret;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"前中后序遍历","slug":"前中后序遍历","permalink":"http://yoursite.com/tags/%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"}]},{"title":"乘法快速幂","slug":"乘法快速幂","date":"2020-08-12T08:59:43.000Z","updated":"2020-08-12T09:01:09.929Z","comments":true,"path":"2020/08/12/乘法快速幂/","link":"","permalink":"http://yoursite.com/2020/08/12/%E4%B9%98%E6%B3%95%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"乘法快速幂","slug":"乘法快速幂","permalink":"http://yoursite.com/tags/%E4%B9%98%E6%B3%95%E5%BF%AB%E9%80%9F%E5%B9%82/"}]},{"title":"n数之和","slug":"n数之和","date":"2020-08-03T08:48:35.000Z","updated":"2020-08-03T13:26:49.704Z","comments":true,"path":"2020/08/03/n数之和/","link":"","permalink":"http://yoursite.com/2020/08/03/n%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"leetcode上除了有2Sum问题还有3Sum，4Sum。。。等问题，对于这种问题有什么比较好的思路呢？我们从最简单的2Sum问题说起。 2Sum问题leetcode第一题，题目如下：这道题目的思路很简单，先对数组进行排序，然后利用双指针从两端向中间收敛即可得到正确答案，代码如下： 12345678910111213141516171819202122vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target)&#123; sort(nums.begin(),nums.end()); int left = 0, right = nums.size()-1; while(left &lt; right) &#123; int sum = nums[left] + nums[right]; if(sum &lt; target) &#123; left++; &#125; else if(sum &gt; target) &#123; right--; &#125; else &#123; return vector&lt;int&gt;&#123;left,right&#125;; &#125; &#125; return vector&lt;int&gt;&#123;&#125;;&#125; 该题只需求出一对数字即可，但是当题目改成求nums中所有元素和为target的元素对，且不能出现重复时，题目的思路还是排序+双指针，不过现在需要去重。代码如下： 1234567891011121314151617181920212223242526272829vector&lt;vector&lt;int&gt;&gt; twoSum(vector&lt;int&gt;&amp; nums, int target)&#123; sort(nums.begin(),nums.end()); vector&lt;vector&lt;int&gt;&gt; ret; int left = 0, right = nums.size()-1; while(left &lt; right) &#123; int sum = nums[left] + nums[right]; int cur_left = nums[left], cur_right = nums[right]; if(sum &lt; target) &#123; left++; &#125; else if(sum &gt; target) &#123; right--; &#125; else &#123; ret.push_back(vector&lt;int&gt;&#123;left,right&#125;); /* 去重，跳过左右相同的数字 */ while(left &lt; right &amp;&amp; nums[left] == cur_left) left++; while(left &lt; right &amp;&amp; nums[right] == cur_right) right--; &#125; &#125; return ret;&#125; 前两个if判断语句也可以做一些优化： 12345678910111213141516171819202122232425262728293031vector&lt;vector&lt;int&gt;&gt; twoSum(vector&lt;int&gt;&amp; nums, int target)&#123; sort(nums.begin(),nums.end()); vector&lt;vector&lt;int&gt;&gt; ret; int left = 0, right = nums.size()-1; while(left &lt; right) &#123; int sum = nums[left] + nums[right]; int cur_left = nums[left], cur_right = nums[right]; if(sum &lt; target) &#123; while(left &lt; right &amp;&amp; nums[left] == cur_left) left++; &#125; else if(sum &gt; target) &#123; while(left &lt; right &amp;&amp; nums[right] == cur_right) right--; &#125; else &#123; ret.push_back(vector&lt;int&gt;&#123;left,right&#125;); /* 去重，跳过左右相同的数字 */ while(left &lt; right &amp;&amp; nums[left] == cur_left) left++; while(left &lt; right &amp;&amp; nums[right] == cur_right) right--; &#125; &#125; return ret;&#125; 3Sum问题leetcode15题： 思路是穷举，对于第一个数字，nums中的每一个元素都有可能，当确定第一个数字之后，后面两个数字可以使用2Sum解决。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950vector&lt;vector&lt;int&gt;&gt; twoSum(vector&lt;int&gt;&amp; nums, int start, nt target)&#123; /* 左指针改成start开始，其他不变 */ vector&lt;vector&lt;int&gt;&gt; ret; int left = start, right = nums.size()-1; while(left &lt; right) &#123; int sum = nums[left] + nums[right]; int cur_left = nums[left], cur_right = nums[right]; if(sum &lt; target) &#123; while(left &lt; right &amp;&amp; nums[left] == cur_left) left++; &#125; else if(sum &gt; target) &#123; while(left &lt; right &amp;&amp; nums[right] == cur_right) right--; &#125; else &#123; ret.push_back(vector&lt;int&gt;&#123;left,right&#125;); /* 去重，跳过左右相同的数字 */ while(left &lt; right &amp;&amp; nums[left] == cur_left) left++; while(left &lt; right &amp;&amp; nums[right] == cur_right) right--; &#125; &#125; return ret;&#125;vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt; nums, int target)&#123; sort(nums.begin(),nums.end()); vector&lt;vector&lt;int&gt;&gt; ret; for(int i=0; i&lt;nums.size(); i++) &#123; vector&lt;vector&lt;int&gt;&gt; curs = twoSum(nums, i+1, target-nums[i]); for(vector&lt;int&gt;&amp; cur : curs) &#123; /* cur中为twoSum的结果，加上nums[i]为threeSum的结果 */ cur.push_back(nums[i]); ret.push_back(cur); &#125; /* 跳过第一个重复情况 */ while(i &lt; nums.size()-1 &amp;&amp; nums[i] == nums[i+1]) i++; &#125; return ret;&#125; 关键点在于第一个数不重复 fourSum问题leetcode18题：4Sum就是穷举第一个数字，然后调用3Sum函数计算剩下的三个数： 12345678910111213141516171819vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target)&#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; ret; for(int i=0; i&lt;nums.size(); i++) &#123; vector&lt;vector&lt;int&gt;&gt; curs = threeSum(nums, i+1, target-nums[i]); for(vector&lt;int&gt; cur : curs) &#123; cur.push_back(nums[i]); res.push_back(cur); &#125; /* 去重 */ while(i &lt; nums.size()-1 &amp;&amp; nums[i] == nums[i+1]) i++; &#125; return ret;&#125; nSum问题遵从上面的思想，nSum = nums[i] + n-1Sum; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950vector&lt;vector&lt;int&gt;&gt; nSum(vector&lt;int&gt;&amp; nums, int m, int start, int target)&#123; int length = nums.size(); vector&lt;vector&lt;int&gt;&gt; res; if(n &lt; 2 || length &lt; n) return res; /* 2Sum的操作 */ if(n == 2) &#123; int left = start, right = lenght-1; while(left &lt; right) &#123; int sum = nums[left] + nums[right]; int cur_left = nums[left], cur_right = nums[right]; if(sum &lt; target) &#123; while(left &lt; right &amp;&amp; nums[left] == cur_left) left++; &#125; else if(sum &gt; target) &#123; while(left &lt; right &amp;&amp; nums[right] == cur_right) right--; &#125; else &#123; res.push_back(vector&lt;int&gt;&#123;left,right&#125;); while(left &lt; right &amp;&amp; nums[left] == cur_left) left++; while(left &lt; right &amp;&amp; nums[right] == cur_right) right--; &#125; &#125; &#125; /* n比2大，递归计算 */ else &#123; for(int i=start; i&lt;length; i++) &#123; vector&lt;vector&lt;int&gt;&gt; curs = nSum(nums, n-1, i+1, target-nums[i]); for(vector&lt;int&gt;&amp; cur : curs) &#123; cur.push_back(nums[i]); ret.push_back(cur); &#125; while(i &lt; length-1 &amp;&amp; nums[i] == nums[i+1]) i++; &#125; &#125; return ret;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"n数之和","slug":"n数之和","permalink":"http://yoursite.com/tags/n%E6%95%B0%E4%B9%8B%E5%92%8C/"}]},{"title":"滑动窗口","slug":"滑动窗口","date":"2020-03-27T09:02:47.000Z","updated":"2020-03-27T09:29:03.778Z","comments":true,"path":"2020/03/27/滑动窗口/","link":"","permalink":"http://yoursite.com/2020/03/27/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"滑动窗口滑动窗口一般需要用到双指针来进行求解。问题问法主要有如下几种： 给两个字符串，一长一短，问其中短的是否在长的中满足一定的条件存在，例如： 求长的的最短子串，该子串必须涵盖短的的所有字符 短的的 anagram 在长的中出现的所有位置 … 给一个字符串或者数组，问这个字符串的子串或者子数组是否满足一定的条件，例如： 含有少于 k 个不同字符的最长子串 所有字符都只出现一次的最长子串 … 除此之外，还有一些其他的问法，但是不变的是，这类题目脱离不开主串（主数组）和子串（子数组）的关系，要求的时间复杂度往往是 O(n) ，空间复杂度往往是常数级的。之所以是滑动窗口，是因为，遍历的时候，两个指针一前一后夹着的子串（子数组）类似一个窗口，这个窗口大小和范围会随着前后指针的移动发生变化。 解题思路根据前面的描述，滑动窗口就是这类题目的重点，换句话说，窗口的移动就是重点！模版： 123456789101112131415161718192021222324252627282930313233343536373839404142int slidingWindowTemplate(vector&lt;int&gt; a, ...) &#123; // 输入参数有效性判断 if (...) &#123; ... &#125; // 申请一个散列，用于记录窗口中具体元素的个数情况 // 这里用数组的形式呈现，也可以考虑其他数据结构 vector&lt;int&gt; hash; // 预处理(可省), 一般情况是改变 hash ... // l 表示左指针 // count 记录当前的条件，具体根据题目要求来定义 // result 用来存放结果 int l = 0, count = ..., result = ...; for (int r = 0; r &lt; A.length; ++r) &#123; // 更新新元素在散列中的数量 hash[A[r]]--; // 根据窗口的变更结果来改变条件值 if (hash[A[r]] == ...) &#123; count++; &#125; // 如果当前条件不满足，移动左指针直至条件满足为止 while (count &gt; K || ...) &#123; ... if (...) &#123; count--; &#125; hash[A[l]]++; l++; &#125; // 更新结果 results = ... &#125; return results;&#125; 具体题目描述：给定一个字符串s和一个非空字符串p，找到s中所有是p的字母异位词的子串，返回这些子串的起始索引。字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100 。解析：首先窗口是固定的，窗口长度就是输入参数中第二个字符串的长度，也就是说，右指针移动到某个位置后，左指针必须跟着一同移动，且每次移动都是一格，模版中 count 用来记录窗口内满足条件的元素，直到 count 和窗口长度相等即可更新答案。代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; // 输入参数有效性判断 if (s.length() &lt; p.length()) &#123; return new ArrayList&lt;Integer&gt;(); &#125; // 申请一个散列，用于记录窗口中具体元素的个数情况 // 这里用数组的形式呈现，也可以考虑其他数据结构 char[] sArr = s.toCharArray(); char[] pArr = p.toCharArray(); int[] hash = new int[26]; for (int i = 0; i &lt; pArr.length; ++i) &#123; hash[pArr[i] - 'a']++; &#125; // l 表示左指针 // count 记录当前的条件，具体根据题目要求来定义 // result 用来存放结果 List&lt;Integer&gt; results = new ArrayList&lt;&gt;(); int l = 0, count = 0, pLength = p.length(); for (int r = 0; r &lt; sArr.length; ++r) &#123; // 更新新元素在散列中的数量 hash[sArr[r] - 'a']--; // 根据窗口的变更结果来改变条件值 if (hash[sArr[r] - 'a'] &gt;= 0) &#123; count++; &#125; // 如果当前条件不满足，移动左指针直至条件满足为止 if (r &gt; pLength - 1) &#123; hash[sArr[l] - 'a']++; if (hash[sArr[l] - 'a'] &gt; 0) &#123; count--; &#125; l++; &#125; // 更新结果 if (count == pLength) &#123; results.add(l); &#125; &#125; return results;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://yoursite.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"动态规划","slug":"动态规划","date":"2020-03-27T07:54:32.000Z","updated":"2020-03-27T07:54:57.047Z","comments":true,"path":"2020/03/27/动态规划/","link":"","permalink":"http://yoursite.com/2020/03/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"动态规划","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"回溯","slug":"回溯","date":"2020-03-20T08:08:37.000Z","updated":"2020-03-27T07:46:42.565Z","comments":true,"path":"2020/03/20/回溯/","link":"","permalink":"http://yoursite.com/2020/03/20/%E5%9B%9E%E6%BA%AF/","excerpt":"","text":"回溯算法详解解决回溯问题，实际上是一个决策树遍历的过程，你只需要思考三个问题： 路径：也就是已经做出的选择。 选择列表：也就是你当前可以做的选择。 结束条件：也就是到达决策树底层，无法再做选择的条件。 直接看回溯算法的框架: 12345678910result = []def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 其核心是for循环里面的递归，在递归调用之前做选择，递归之后撤销选择 全排列问题比如给三个数1，2，3，我们肯定不会无规律得找，一般是这样：先固定第一位为1，然后第二位可以是2，那么第三位只能是3，然后可以把第二位设置成3，那么第三位只能是2，然后只能变化第一位，为2，再依次穷举。根据之前的描述，我们可以画出如下的回溯树：只要从根节点开始遍历这棵树，记录路径上的数字，其实就是所有的全排列。我们不妨把这棵树称为回溯算法的决策树。因为在每个节点上你都是在做决策。比如在红色节点上：现在你就在做决策，你可以选择1那条树枝，你也可以选择3那条树枝，因为2树枝在你身后了，因此不能选。现在可以解答开头的几个名词：[2] 就是「路径」，记录你已经做过的选择；[1,3] 就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候。我们定义的 backtrack 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列。多叉树的遍历框架如下： 123456void traverse(TreeNode root) &#123; for (TreeNode child : root.childern) // 前序遍历需要的操作 traverse(child); // 后序遍历需要的操作&#125; 而所谓的前序遍历和后序遍历，他们只是两个很有用的时间点，我给你画张图你就明白了：前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行。全排列问题的代码： 1234567891011121314151617181920212223242526272829303132List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();/* 主函数，输入一组不重复的数字，返回它们的全排列 */List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; // 记录「路径」 LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); backtrack(nums, track); return res;&#125;// 路径：记录在 track 中// 选择列表：nums 中不存在于 track 的那些元素// 结束条件：nums 中的元素全都在 track 中出现void backtrack(int[] nums, LinkedList&lt;Integer&gt; track) &#123; // 触发结束条件 if (track.size() == nums.length) &#123; res.add(new LinkedList(track)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; // 排除不合法的选择 if (track.contains(nums[i])) continue; // 做选择 track.add(nums[i]); // 进入下一层决策树 backtrack(nums, track); // 取消选择 track.removeLast(); &#125;&#125; 我们这里稍微做了些变通，没有显式记录「选择列表」，而是通过 nums 和 track 推导出当前的选择列表： N皇后问题问题：给你一个 N×N 的棋盘，让你放置 N 个皇后，使得它们不能互相攻击。皇后可以攻击同一行，同一列，以及每一条斜线。这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。代码： 123456789101112131415161718192021222324252627282930313233vector&lt;vector&lt;string&gt;&gt; res;/* 输入棋盘边长 n，返回所有合法的放置 */vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; // '.' 表示空，'Q' 表示皇后，初始化空棋盘。 vector&lt;string&gt; board(n, string(n, '.')); backtrack(board, 0); return res;&#125;// 路径：board 中小于 row 的那些行都已经成功放置了皇后// 选择列表：第 row 行的所有列都是放置皇后的选择// 结束条件：row 超过 board 的最后一行void backtrack(vector&lt;string&gt;&amp; board, int row) &#123; // 触发结束条件 if (row == board.size()) &#123; res.push_back(board); return; &#125; int n = board[row].size(); for (int col = 0; col &lt; n; col++) &#123; // 排除不合法选择 if (!isValid(board, row, col)) continue; // 做选择 board[row][col] = 'Q'; // 进入下一行决策 backtrack(board, row + 1); // 撤销选择 board[row][col] = '.'; &#125;&#125; 这部分主要代码，其实跟全排列问题差不多，isValid 函数的实现也很简单： 12345678910111213141516171819202122/* 是否可以在 board[row][col] 放置皇后？ */bool isValid(vector&lt;string&gt;&amp; board, int row, int col) &#123; int n = board.size(); // 检查列是否有皇后互相冲突 for (int i = 0; i &lt; n; i++) &#123; if (board[i][col] == 'Q') return false; &#125; // 检查右上方是否有皇后互相冲突 for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123; if (board[i][j] == 'Q') return false; &#125; // 检查左上方是否有皇后互相冲突 for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) &#123; if (board[i][j] == 'Q') return false; &#125; return true;&#125; 函数backtrack依然像个在决策树上游走的指针，通过row和col就可以表示函数遍历到的位置，通过isValid函数可以将不符合条件的情况剪枝：如果直接给你这么一大段解法代码，可能是懵逼的。但是现在明白了回溯算法的框架套路，还有啥难理解的呢？无非是改改做选择的方式，排除不合法选择的方式而已，只要框架存于心，你面对的只剩下小问题了。当N = 8时，就是八皇后问题，数学大佬高斯穷尽一生都没有数清楚八皇后问题到底有几种可能的放置方法，但是我们的算法只需要一秒就可以算出来所有可能的结果。不过真的不怪高斯。这个问题的复杂度确实非常高，看看我们的决策树，虽然有isValid函数剪枝，但是最坏时间复杂度仍然是O(N^(N+1))，而且无法优化。如果N = 10的时候，计算就已经很耗时了。有的时候，我们并不想得到所有合法的答案，只想要一个答案，怎么办呢？比如解数独的算法，找所有解法复杂度太高，只要找到一种解法就可以。代码： 1234567891011121314151617181920// 函数找到一个答案后就返回 truebool backtrack(vector&lt;string&gt;&amp; board, int row) &#123; // 触发结束条件 if (row == board.size()) &#123; res.push_back(board); return true; &#125; ... for (int col = 0; col &lt; n; col++) &#123; ... board[row][col] = 'Q'; if (backtrack(board, row + 1)) return true; board[row][col] = '.'; &#125; return false;&#125; 总结回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：代码： 12345def backtrack(...): for 选择 in 选择列表: 做选择 backtrack(...) 撤销选择 某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"回溯","slug":"回溯","permalink":"http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"RTOS","slug":"RTOS","date":"2020-03-16T08:13:33.000Z","updated":"2020-04-05T13:50:40.894Z","comments":true,"path":"2020/03/16/RTOS/","link":"","permalink":"http://yoursite.com/2020/03/16/RTOS/","excerpt":"","text":"MY RTOS这篇文章参考FREE RTOS的源码以及野火的FREE RTOS的书，只实现了支持多优先级的任务调度。 数据结构 RTOS基本的数据类型是双向链表，通过许多不同的双向链表，我们可以实现对多优先级的支持，链表节点数据结构定义如下： 123456789struct xLIST_ITEM&#123; TickType_t xItemValue; /* 辅助值，用于帮助节点做顺序排列 */ struct xLIST_ITEM * pxNext; /* 指向链表下一个节点 */ struct xLIST_ITEM * pxPrevious; /* 指向链表前一个节点 */ void * pvOwner; /* 指向拥有该节点的内核对象，通常是TCB */ void * pvContainer; /* 指向该节点所在的链表 */&#125;;typedef struct xLIST_ITEM ListItem_t; /* 节点数据类型重定义 */ 链表节点ListItem_t总共有5个成员，但是初始化的时候只需将pvContainer初始化为空即可，表示该节点还没有插入到任何链表： 123456/*链表节点初始化*/void vListInitialiseItem( ListItem_t * const pxItem )&#123; /* 初始化该节点所在的链表为空，表示节点还没有插入任何链表 */ pxItem-&gt;pvContainer = NULL;&#125; 链表根节点，因为双向链表结尾相连，头即是尾巴，尾即是头： 1234567struct xMINI_LIST_ITEM&#123; TickType_t xItemValue; /* 链表节点计数器 */ struct xLIST_ITEM * pxNext; /* 链表节点索引指针 */ struct xLIST_ITEM * pxPrevious; /* 链表最后一个节点 */&#125;;typedef struct xMINI_LIST_ITEM MiniListItem_t; /* 精简节点数据类型重定义 */ 链表操作 链表根节点的初始化： 123456789101112131415void vListInitialise( List_t * const pxList )&#123; /* 将链表索引指针指向最后一个节点 */ pxList-&gt;pxIndex = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd ); /* 将链表最后一个节点的辅助排序的值设置为最大，确保该节点就是链表的最后节点 */ pxList-&gt;xListEnd.xItemValue = portMAX_DELAY; /* 将最后一个节点的pxNext和pxPrevious指针均指向节点自身，表示链表为空 */ pxList-&gt;xListEnd.pxNext = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd ); pxList-&gt;xListEnd.pxPrevious = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd ); /* 初始化链表节点计数器的值为0，表示链表为空 */ pxList-&gt;uxNumberOfItems = ( UBaseType_t ) 0U;&#125; 将普通的链表插入根节点的尾部(一开始初始化的时候只有根节点)： 123456789101112131415void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )&#123; ListItem_t * const pxIndex = pxList-&gt;pxIndex; pxNewListItem-&gt;pxNext = pxIndex; pxNewListItem-&gt;pxPrevious = pxIndex-&gt;pxPrevious; pxIndex-&gt;pxPrevious-&gt;pxNext = pxNewListItem; pxIndex-&gt;pxPrevious = pxNewListItem; /* 记住该节点所在的链表 */ pxNewListItem-&gt;pvContainer = ( void * ) pxList; /* 链表节点计数器++ */ ( pxList-&gt;uxNumberOfItems )++;&#125; 节点按升序排列插入到链表 12345678910111213141516171819202122232425262728293031323334void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )&#123; ListItem_t *pxIterator; /* 获取节点的排序辅助值 */ const TickType_t xValueOfInsertion = pxNewListItem-&gt;xItemValue; /* 寻找节点要插入的位置 */ if( xValueOfInsertion == portMAX_DELAY ) &#123; pxIterator = pxList-&gt;xListEnd.pxPrevious; &#125; else &#123; for( pxIterator = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd ); pxIterator-&gt;pxNext-&gt;xItemValue &lt;= xValueOfInsertion; pxIterator = pxIterator-&gt;pxNext ) &#123; /* 没有事情可做，不断迭代只为了找到节点要插入的位置 */ &#125; &#125; /* 根据升序排列，将节点插入 */ pxNewListItem-&gt;pxNext = pxIterator-&gt;pxNext; pxNewListItem-&gt;pxNext-&gt;pxPrevious = pxNewListItem; pxNewListItem-&gt;pxPrevious = pxIterator; pxIterator-&gt;pxNext = pxNewListItem; /* 记住该节点所在的链表 */ pxNewListItem-&gt;pvContainer = ( void * ) pxList; /* 链表节点计数器++ */ ( pxList-&gt;uxNumberOfItems )++;&#125; 将节点从链表删除 123456789101112131415161718192021222324UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )&#123; /* 获取节点所在的链表 */ List_t * const pxList = ( List_t * ) pxItemToRemove-&gt;pvContainer; /* 将指定的节点从链表删除 */ pxItemToRemove-&gt;pxNext-&gt;pxPrevious = pxItemToRemove-&gt;pxPrevious; pxItemToRemove-&gt;pxPrevious-&gt;pxNext = pxItemToRemove-&gt;pxNext; /* 调整链表的节点索引指针 */ if( pxList-&gt;pxIndex == pxItemToRemove ) &#123; pxList-&gt;pxIndex = pxItemToRemove-&gt;pxPrevious; &#125; /* 初始化该节点所在的链表为空，表示节点还没有插入任何链表 */ pxItemToRemove-&gt;pvContainer = NULL; /* 链表节点计数器-- */ ( pxList-&gt;uxNumberOfItems )--; /* 返回链表中剩余节点的个数 */ return pxList-&gt;uxNumberOfItems;&#125; 链表的宏函数 12345678910111213141516171819202122232425262728293031323334353637383940414243/* 初始化节点的拥有者 */#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner ) ( ( pxListItem )-&gt;pvOwner = ( void * ) ( pxOwner ) )/* 获取节点拥有者 */#define listGET_LIST_ITEM_OWNER( pxListItem ) ( ( pxListItem )-&gt;pvOwner )/* 初始化节点排序辅助值 */#define listSET_LIST_ITEM_VALUE( pxListItem, xValue ) ( ( pxListItem )-&gt;xItemValue = ( xValue ) )/* 获取节点排序辅助值 */#define listGET_LIST_ITEM_VALUE( pxListItem ) ( ( pxListItem )-&gt;xItemValue )/* 获取链表根节点的节点计数器的值 */#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList ) ( ( ( pxList )-&gt;xListEnd ).pxNext-&gt;xItemValue )/* 获取链表的入口节点 */#define listGET_HEAD_ENTRY( pxList ) ( ( ( pxList )-&gt;xListEnd ).pxNext )/* 获取节点的下一个节点 */#define listGET_NEXT( pxListItem ) ( ( pxListItem )-&gt;pxNext )/* 获取链表的最后一个节点 */#define listGET_END_MARKER( pxList ) ( ( ListItem_t const * ) ( &amp;( ( pxList )-&gt;xListEnd ) ) )/* 判断链表是否为空 */#define listLIST_IS_EMPTY( pxList ) ( ( BaseType_t ) ( ( pxList )-&gt;uxNumberOfItems == ( UBaseType_t ) 0 ) )/* 当前链表长度 */#define listCURRENT_LIST_LENGTH( pxList ) ( ( pxList )-&gt;uxNumberOfItems )/* 获取链表第一个节点的OWNER，即TCB */#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList ) \\&#123; \\ List_t * const pxConstList = ( pxList ); \\ /* 节点索引指向链表第一个节点 */\\ ( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext; \\ /* 这个操作有啥用？ */ \\ if( ( void * ) ( pxConstList )-&gt;pxIndex == ( void * ) &amp;( ( pxConstList )-&gt;xListEnd ) ) \\ &#123; \\ ( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext; \\ &#125; \\ /* 获取节点的OWNER，即TCB */ \\ ( pxTCB ) = ( pxConstList )-&gt;pxIndex-&gt;pvOwner; \\&#125; 任务创建 在多任务系统中，每个任务都是独立的，互不干扰的，因此要给每个任务分配独立的栈空间，这个栈空间通常是一个预先定义好的全局数组，也可以是动态分配的一段内存空间，但它们都存在于RAM中。 在多任务系统中，任务的执行是由系统调度的。系统为了顺利的调度任务，为每个任务都额外定义了一个任务控制块(TCB)，这个任务控制块就相当于任务的身份证，里面存有任务的所有信息，比如任务的栈指针，任务名称，任务的形参等。有了这个任务控制块之后，以后系统对任务的全部操作都可以通过这个任务控制块来实现。 任务控制块声明：123456789101112 typedef struct tskTaskControlBlock&#123; volatile StackType_t *pxTopOfStack; /* 栈顶 */ ListItem_t xStateListItem; /* 任务节点 */ StackType_t *pxStack; /* 任务栈起始地址 */ /* 任务名称，字符串形式 */ char pcTaskName[ configMAX_TASK_NAME_LEN ]; TickType_t xTicksToDelay; &#125;TCB_T; xTaskCreateStatic()函数1234567891011121314151617181920212223242526 TaskHandle_t xTaskCreateStatic( TaskFunction_t pxTaskCode, /* 任务代码块 */ const char * const pcName, /* 任务名称 */ const uint32_t ulStackDepth, /* 栈深度 */ void * const pvParameters, /* 任务形参 */ StackType_t * const puxStackBuffer, /* 任务栈起始地址 */ TCB_t * const pxTaskBuffer ) /* 任务控制块指针 */&#123; TCB_t *pxNewTCB; TaskHandle_t xReturn; if( ( pxTaskBuffer != NULL ) &amp;&amp; ( puxStackBuffer != NULL ) ) &#123; pxNewTCB = ( TCB_t * ) pxTaskBuffer; pxNewTCB-&gt;pxStack = ( StackType_t * ) puxStackBuffer; /* 创建新的任务 */ prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, &amp;xReturn, pxNewTCB); &#125; else &#123; xReturn = NULL; &#125; /* 返回任务句柄，如果任务创建成功，此时xReturn应该指向任务控制块 */ return xReturn;&#125; prvInitialiseNewTask()函数(真正的任务创建函数)1234567891011121314151617181920212223242526272829303132333435363738394041424344 static void prvInitialiseNewTask( TaskFunction_t pxTaskCode, /* 任务入口 */ const char * const pcName, /* 任务名称 */ const uint32_t ulStackDepth, /* 任务栈大小 */ void * const pvParameters, /* 任务形参 */ TaskHandle_t * const pxCreatedTask, /* 任务句柄 */ TCB_t *pxNewTCB ) /* 任务栈起始地址 */&#123; StackType_t *pxTopOfStack; UBaseType_t x; /* 获取栈顶地址 */ pxTopOfStack = pxNewTCB-&gt;pxStack + ( ulStackDepth - ( uint32_t ) 1 ); //pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /* 向下做8字节对齐 */ pxTopOfStack = ( StackType_t * ) ( ( ( uint32_t ) pxTopOfStack ) &amp; ( ~( ( uint32_t ) 0x0007 ) ) ); /* 将任务的名字存储在TCB中 */ for( x = ( UBaseType_t ) 0; x &lt; ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ ) &#123; pxNewTCB-&gt;pcTaskName[ x ] = pcName[ x ]; if( pcName[ x ] == 0x00 ) &#123; break; &#125; &#125; /* 任务名字的长度不能超过configMAX_TASK_NAME_LEN */ pxNewTCB-&gt;pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\\0'; /* 初始化任务栈 */ vListInitialiseItem( &amp;( pxNewTCB-&gt;xStateListItem ) ); /* 初始化TCB中的xStateListItem节点 */ listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xStateListItem ), pxNewTCB ); /* 初始化任务栈 */ pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters ); /* 让任务句柄指向任务控制块 */ if( ( void * ) pxCreatedTask != NULL ) &#123; *pxCreatedTask = ( TaskHandle_t ) pxNewTCB; &#125;&#125; pxPortInitialiseStack()函数(初始化任务栈函数)12345678910111213141516 StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )&#123; /* 异常发生时，自动加载到CPU寄存器的内容 */ pxTopOfStack--; *pxTopOfStack = portINITIAL_XPSR; /* xPSR的bit24必须置1 */ pxTopOfStack--; *pxTopOfStack = ( ( StackType_t ) pxCode ) &amp; portSTART_ADDRESS_MASK; /* PC，即任务入口函数 */ pxTopOfStack--; *pxTopOfStack = ( StackType_t ) prvTaskExitError; /* LR，函数返回地址 */ pxTopOfStack -= 5; /* R12, R3, R2 and R1 默认初始化为0 */ *pxTopOfStack = ( StackType_t ) pvParameters; /* 异常发生时，手动加载到CPU寄存器的内容 */ pxTopOfStack -= 8; return pxTopOfStack;&#125; 栈分布图：异常发生时，CPU自动从栈中加载到CPU寄存器的内容。包括8个寄存器，分别为R0、R1、R2、R3、R12、R14、R15和xPSR的位24，且顺序不能变。xPSR的bit24必须置1，即0x01000000。任务的返回地址，通常任务是不会返回的，如果返回了就跳转到prvTaskExitError，该函数是一个无限循环。R12, R3, R2 and R1 默认初始化为0。异常发生时，需要手动加载到CPU寄存器的内容，总共有8个，分别为R4、R5、R6、R7、R8、R9、R10和R11，默认初始化为0。 任务创建完后我们需要把任务添加到就绪列表里面，表示任务已经就绪，系统随时可以调度。 12/* 任务就绪列表 */List_t pxReadyTasksLists[ configMAX_PRIORITIES ]; 就绪列表实际上就是一个List_t类型的数组，数组的大小由决定最大任务优先级的宏configMAX_PRIORITIES决定，configMAX_PRIORITIES在FreeRTOSConfig.h中默认定义为5，最大支持256个优先级。数组的下标对应了任务的优先级，同一优先级的任务统一插入到就绪列表的同一条链表中。空就绪列表如下图： 就绪列表初始化12345678910void prvInitialiseTaskLists( void )&#123; UBaseType_t uxPriority; for( uxPriority = ( UBaseType_t ) 0U; uxPriority &lt; ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ ) &#123; vListInitialise( &amp;( pxReadyTasksLists[ uxPriority ] ) ); &#125;&#125; 就绪列表初始化之后： 将任务插入到就绪列表任务控制块里面有一个xStateListItem成员，数据类型为ListItem_t，我们将任务插入到就绪列表里面，就是通过将任务控制块的xStateListItem这个节点插入到就绪列表中来实现的。如果把就绪列表比作是晾衣架，任务是衣服，那xStateListItem就是晾衣架上面的钩子，每个任务都自带晾衣架钩子，就是为了把自己挂在各种不同的链表中。12345678910111213141516171819202122232425/* 初始化与任务相关的列表，如就绪列表 */prvInitialiseTaskLists();Task1_Handle = /* 任务句柄 */xTaskCreateStatic((TaskFunction_t)Task1_Entry, (char *)\"Task1\", (uint32_t)TASK1_STACK_SIZE , (void *) NULL, (StackType_t *)Task1Stack, (TCB_t *)&amp;Task1TCB );/* 将任务添加到就绪列表 */vListInsertEnd( &amp;( pxReadyTasksLists[1] ), &amp;( ((TCB_t *)(&amp;Task1TCB))-&gt;xStateListItem ) );Task2_Handle = /* 任务句柄 */xTaskCreateStatic((TaskFunction_t)Task2_Entry, /* 任务入口 */ (char *)\"Task2\", /* 任务名称，字符串形式 */ (uint32_t)TASK2_STACK_SIZE , /* 任务栈大小，单位为字 */ (void *) NULL, /* 任务形参 */ (StackType_t *)Task2Stack, /* 任务栈起始地址 */ (TCB_t *)&amp;Task2TCB ); /* 任务控制块 *//* 将任务添加到就绪列表 */vListInsertEnd( &amp;( pxReadyTasksLists[2] ), &amp;( ((TCB_t *)(&amp;Task2TCB))-&gt;xStateListItem ) ); 任务插入到就绪列表示意图： 实现任务调度器调度器是操作系统的核心，其主要功能就是实现任务的切换，即从就绪列表里面找到优先级最高的任务，然后去执行该任务。从代码上来看，调度器无非也就是由几个全局变量和一些可以实现任务切换的函数组成。 vTaskStartScheduler()函数1234567891011void vTaskStartScheduler( void )&#123; /* 手动指定第一个运行的任务 */ pxCurrentTCB = &amp;Task1TCB; //pxCurrentTCB是一个全局指针 /* 启动调度器 */ if ( xPortStartScheduler() != pdFALSE ) &#123; /* 调度器启动成功，则不会返回，即不会来到这里 */ &#125;&#125; xPortStartScheduler()函数1234567891011121314151617181920212223/** 在Cortex-M中，内核外设SCB中SHPR3寄存器用于设置SysTick和PendSV的异常优先级* System handler priority register 3 (SCB_SHPR3) SCB_SHPR3：0xE000 ED20* Bits 31:24 PRI_15[7:0]: Priority of system handler 15, SysTick exception* Bits 23:16 PRI_14[7:0]: Priority of system handler 14, PendSV#define portNVIC_SYSPRI2_REG (*(( volatile uint32_t *) 0xe000ed20))#define portNVIC_PENDSV_PRI (((uint32_t) configKERNEL_INTERRUPT_PRIORITY ) &lt;&lt; 16UL)#define portNVIC_SYSTICK_PRI (((uint32_t) configKERNEL_INTERRUPT_PRIORITY ) &lt;&lt; 24UL )BaseType_t xPortStartScheduler( void )&#123; /* 配置PendSV 和 SysTick 的中断优先级为最低 */ portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI; portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI; /* 启动第一个任务，不再返回 */ prvStartFirstTask(); /* 不应该运行到这里 */ return 0;&#125;*/ 配置PendSV和SysTick的中断优先级为最低，SysTick和PendSV都会涉及到系统调度，系统调度的优先级要低于系统的其它硬件中断优先级，即优先相应系统中的外部硬件中断，所以SysTick和PendSV的中断优先级配置为最低。 prvStartFirstTask()函数(开始第一个任务)123456789101112131415161718192021222324252627282930__asm void prvStartFirstTask( void )&#123; PRESERVE8 /* 在Cortex-M中，0xE000ED08是SCB_VTOR这个寄存器的地址， 里面存放的是向量表的起始地址，即MSP的地址 */ ldr r0, =0xE000ED08 ldr r0, [r0] ldr r0, [r0] /* 设置主堆栈指针msp的值 */ msr msp, r0 /* 使能全局中断 */ cpsie i cpsie f dsb isb /* 调用SVC去启动第一个任务 */ svc 0 nop nop /* * CPSID I ;PRIMASK=1 ;关中断 * CPSIE I ;PRIMASK=0 ;开中断 * CPSID F ;FAULTMASK=1 ;关异常 * CPSIE F ;FAULTMASK=0 ;开异常 */&#125; Cortex M内核中断屏蔽寄存器组描述 PRIMASK ： 这是个只有单一比特的寄存器。 在它被置 1 后，就关掉所有可屏蔽的异常，只剩下 NMI 和硬 FAULT可以响应。它的缺省值是 0，表示没有关中断。 FAULTMASK ： 这是个只有 1 个位的寄存器。当它置 1 时，只有 NMI 才能响应，所有其它的异常，甚至是硬 FAULT，也通通闭嘴。它的缺省值也是 0，表示没有关异常。 BASEPRI ： 这个寄存器最多有 9 位（ 由表达优先级的位数决定）。它定义了被屏蔽优先级的阈值。当它被设成某个值后，所有优先级号大于等于此值的中断都被关（优先级号越大，优先级越低）。但若被设成 0，则不关闭任何中断， 0 也是缺省值。 vPortSVCHandler()函数（任务压栈）SVC想要成功被响应，其函数名必须与向量注册表名一样，在启动文件向量表中，SVC的中断服务函数注册的名称是SVC_Handler，在rtos中SVC中断服务函数的名字是vPortSVCHandler()，为了能顺利响应SVC中断，我们定义一个宏定义。12345678910111213141516171819#define vPortSVCHandler SVC_Handler__asm void vPortSVCHandler( void )&#123; extern pxCurrentTCB; PRESERVE8 //字节对齐 ldr r3, =pxCurrentTCB //加载currentTCB地址到r3 ldr r1, [r3] //加载currentTCB到r1 ldr r0, [r1] //\bcurrentTCB第一个值为栈顶指针，因此r0为栈顶指针 ldmia r0!, &#123;r4-r11&#125; //r0为基地址，将栈中向上增长的8个字的内容加载到CPU寄存器r4~r11，同时r0也会跟着自增。 msr psp, r0 //将新的栈顶指针更新到psp isb mov r0, #0 //r0清零 msr basepri, r0 //设置basepri为0，即打开所有中断 orr r14, #0xd//从SVC中断服务退出前，通过向r14寄存器最后4位按位或上0x0D，使得硬件在退出时使用进程堆栈指针PSP完成出栈操作并返回后进入任务模式 bx r14 //异常返回，这个时候出栈使用的是PSP指针，自动将栈中的剩下内容加载到CPU寄存器： xPSR，PC（任务入口地址），R14，R12，R3，R2，R1，R0（任务的形参）同时PSP的值也将更新，即指向任务栈的栈顶。&#125; 第一个任务启动成功后，psp的指向： 任务切换任务切换就是在就绪列表中寻找优先级最高的就绪任务，然后去执行该任务。 taskYIELD()函数123456789101112131415 #define taskYIELD() portYIELD() /* 中断控制状态寄存器：0xe000ed04 * Bit 28 PENDSVSET: PendSV 悬起位 */ #define portNVIC_INT_CTRL_REG (*(( volatile uint32_t *) 0xe000ed04)) #define portNVIC_PENDSVSET_BIT ( 1UL &lt;&lt; 28UL ) #define portSY_FULL_READ_WRITE ( 15 ) #define portYIELD() \\ &#123; \\/* 触发PendSV，产生上下文切换 */ \\portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; (1) \\__dsb( portSY_FULL_READ_WRITE ); \\__isb( portSY_FULL_READ_WRITE ); \\ &#125; portYIELD的实现实际就是将PendSV的悬起位置置为1，当没有其它中断运行的时候响应PendSV中断，去执行我们写好的PendSV中断服务函数，在里面实现任务切换。 xPortPendSVHandler()函数：切换任务的地方1234567891011121314151617181920212223242526272829303132333435__asm void xPortPendSVHandler( void&#123; extern pxCurrentTCB; extern vTaskSwitchContext; //上下文切换函数 PRESERVE8 mrs r0, psp //将psp的值存储到r0。当进入PendSVC Handler时，上一个任务运行的环境即： xPSR，PC（任务入口地址），R14，R12，R3，R2，R1，R0（任务的形参）这些CPU寄存器的值会自动存储到任务的栈中。剩下的r4~r11需要手动保存，同时PSP会自动更新（在更新之前PSP指向任务栈的栈顶）。 isb //指令同步隔离。最严格：它会清洗流水线，以保证所有它前面的指令都执行完毕之后，才执行它后面的指令。 ldr r3, =pxCurrentTCB //加载pxCurrentTCB的地址到r3 ldr r2, [r3] //加载currentTCB到r2 stmdb r0!, &#123;r4-r11&#125; //以r0作为基址（指针先递减，再操作，STMDB的DB表示 Decrease Befor），将CPU寄存器r4~r11的值存储到任务栈，同时更新r0的值， str r0, [r2] //将r0的值存储到r2指向的内容，r2等于pxCurrentTCB。具体为将r0的值存储到上一个任务的栈顶指针pxTopOfStack， //上下文切换中的上文保存就完成了。 stmdb sp!, &#123;r3, r14&#125; //将R3和R14临时压入堆栈 mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY msr basepri, r0 //关中断，进入临界段 dsb isb bl vTaskSwitchContext //调用函数 mov r0, #0 //退出临界段，开中断，直接往BASEPRI写0。 msr basepri, r0 ldmia sp!, &#123;r3, r14&#125; //从主堆栈中恢复寄存器r3和r14的值，此时的sp使用的是MSP。 ldr r1, [r3] //加载r3指向的内容到r1。r3存放的是pxCurrentTCB的地址，即让r1等于pxCurrentTCB。pxCurrentTCB在上面的vTaskSwitchContext函数中被更新，指向了下一个将要运行的任务的TCB。 ldr r0, [r1] //r0的值为下一个任务的栈顶指针 ldmia r0!, &#123;r4-r11&#125; //将下一个要运行的任务的任务栈的内容加载到CPU寄存器r4~r11 msr psp, r0 //更新psp的值，等下异常退出时，会以psp作为基地址，将任务栈中剩下的内容自动加载到CPU寄存器。 isb bx r14 nop&#125; vTaskSwitchContext()函数123456789101112void vTaskSwitchContext( void )&#123; /* 两个任务轮流切换 */ if ( pxCurrentTCB == &amp;Task1TCB ) &#123; pxCurrentTCB = &amp;Task2TCB; &#125; else &#123; pxCurrentTCB = &amp;Task1TCB; &#125;&#125; 临界段保护临界段的定义就是在执行的时候不能被中断的代码，在对全局变量操作的时候，我们必须开启临界段保护，因为在同一时刻只能有一个线程能够改变他的值，类似unix中的读写锁。freertos对临界段的保护最终还是回到对中断的开和关的控制。为了实现快速开关中断，Cortex-M内核专门设置了一条 CPS 指令，有 4 种用法：1234CPSID I ;PRIMASK=1 ;关中断CPSIE I ;PRIMASK=0 ;开中断CPSID F ;FAULTMASK=1 ;关异常CPSIE F ;FAULTMASK=0 ;开异常 Cortex M内核 中断屏蔽寄存器组描述见上一节三个寄存器，分别是：PRIMASK，FAULTMASK，BASEPRI。在FreeRTOS中，对中断的开和关是通过操作BASEPRI寄存器来实现的，即大于等于BASEPRI的值的中断会被屏蔽，小于BASEPRI的值的中断则不会被屏蔽，不受FreeRTOS管理。用户可以设置BASEPRI的值来选择性的给一些非常紧急的中断留一条后路。 关中断 123456789101112131415161718192021222324252627/* 不带返回值的关中断函数，不能嵌套，不能在中断里面使用 */#define portDISABLE_INTERRUPTS() vPortRaiseBASEPRI()void vPortRaiseBASEPRI( void )&#123; uint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY; __asm &#123; msr basepri, ulNewBASEPRI dsb isb &#125;&#125;/* 带返回值的关中断函数，可以嵌套，可以在中断里面使用 */#define portSET_INTERRUPT_MASK_FROM_ISR() ulPortRaiseBASEPRI()ulPortRaiseBASEPRI( void )&#123; uint32_t ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY; __asm &#123; mrs ulReturn, basepri msr basepri, ulNewBASEPRI dsb isb &#125;&#125; 开中断","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"RTOS","slug":"RTOS","permalink":"http://yoursite.com/tags/RTOS/"}]},{"title":"C++面试知识点","slug":"C++面试知识点","date":"2020-03-14T15:55:29.201Z","updated":"2020-03-16T10:32:08.093Z","comments":true,"path":"2020/03/14/C++面试知识点/","link":"","permalink":"http://yoursite.com/2020/03/14/C++%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"注：此文章原地址 📖 Github &emsp;&emsp; | &emsp;&emsp; 📚 Docsify 💡 关于 📚 本仓库是面向 C/C++ 技术方向校招求职者、初学者的基础知识总结，包括语言、程序库、数据结构、算法、系统、网络、链接装载库等知识及面试经验、招聘、内推等信息。 💡 侧边目录支持方式：📚 Docsify 文档、Github + TOC 导航（TOC预览.png） 📄 保存为 PDF 方式：使用 Chrome 浏览器打开 📚 Docsify 文档 页面，缩起左侧目录-右键 - 打印 - 选择目标打印机是另存为PDF - 保存（打印预览.png） 🙏 仓库内容如有错误或改进欢迎 issue 或 pr，建议或讨论可在 #12 提出。由于本人水平有限，仓库中的知识点有来自本人原创、读书笔记、书籍、博文等，非原创均已标明出处，如有遗漏，请 issue 提出。本仓库遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。 🍭 广告与打赏：个人茶余饭后独立开发的一个虚拟形象扮演软件 《Avalive》。打赏请点 支持赞助。 📑 目录 ➕ C/C++ ⭐️ Effective 📦 STL 〽️ 数据结构 ⚡️ 算法 ❓ Problems 💻 操作系统 ☁️ 计算机网络 🌩 网络编程 💾 数据库 📏 设计模式 ⚙️ 链接装载库 📚 书籍 🔱 C/C++ 发展方向 💯 复习刷题网站 📝 面试题目经验 📆 招聘时间岗位 👍 内推 👬 贡献者 🍭 支持赞助 📜 License ➕ C/C++const作用 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。 const 的指针与引用 指针 指向常量的指针（pointer to const） 自身是常量的指针（常量指针，const pointer） 引用 指向常量的引用（reference to const） 没有 const reference，因为引用本身就是 const pointer （为了方便记忆可以想成）被 const 修饰（在 const 后面）的值不可改变，如下文使用例子中的 p2、p3 使用const 使用 123456789101112131415161718192021222324252627282930313233343536373839404142// 类class A&#123;private: const int a; // 常对象成员，只能在初始化列表赋值public: // 构造函数 A() : a(0) &#123; &#125;; A(int x) : a(x) &#123; &#125;; // 初始化列表 // const可用于对重载函数的区分 int getValue(); // 普通成员函数 int getValue() const; // 常成员函数，不得修改类中的任何数据成员的值&#125;;void function()&#123; // 对象 A b; // 普通对象，可以调用全部成员函数、更新常成员变量 const A a; // 常对象，只能调用常成员函数 const A *p = &amp;a; // 指针变量，指向常对象 const A &amp;q = a; // 指向常对象的引用 // 指针 char greeting[] = \"Hello\"; char* p1 = greeting; // 指针变量，指向字符数组变量 const char* p2 = greeting; // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变） char* const p3 = greeting; // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变） const char* const p4 = greeting; // 自身是常量的指针，指向字符数组常量&#125;// 函数void function1(const int Var); // 传递过来的参数在函数内不可变void function2(const char* Var); // 参数指针所指内容为常量void function3(char* const Var); // 参数指针为常量void function4(const int&amp; Var); // 引用参数在函数内为常量// 函数返回值const int function5(); // 返回一个常数const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6();int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7(); static作用 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。 this 指针 this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）； this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &amp;this）。 在以下场景中，经常需要显式引用 this 指针： 为实现对象的链式引用； 为避免对同一对象进行赋值操作； 在实现一些数据结构时，如 list。 inline 内联函数特征 相当于把内联函数里面的内容写在调用内联函数处； 相当于不用执行进入函数的步骤，直接执行函数体； 相当于宏，却比宏多了类型检查，真正具有函数特性； 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数； 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。 使用inline 使用 12345678910111213141516171819// 声明1（加 inline，建议使用）inline int functionName(int first, int second,...);// 声明2（不加 inline）int functionName(int first, int second,...);// 定义inline int functionName(int first, int second,...) &#123;/****/&#125;;// 类内定义，隐式内联class A &#123; int doA() &#123; return 0; &#125; // 隐式内联&#125;// 类外定义，需要显式内联class A &#123; int doA();&#125;inline int A::doA() &#123; return 0; &#125; // 需要显式内联 编译器对 inline 函数的处理步骤 将 inline 函数体复制到 inline 函数调用点处； 为所用 inline 函数中的局部变量分配内存空间； 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。 优缺点优点 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。 内联函数在运行时可调试，而宏定义不可以。 缺点 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。 inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。 虚函数（virtual）可以是内联函数（inline）吗？ Are “inline virtual” member functions ever actually “inlined”? 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。 inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。 虚函数内联使用 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt; using namespace std;class Base&#123;public: inline virtual void who() &#123; cout &lt;&lt; \"I am Base\\n\"; &#125; virtual ~Base() &#123;&#125;&#125;;class Derived : public Base&#123;public: inline void who() // 不写inline时隐式内联 &#123; cout &lt;&lt; \"I am Derived\\n\"; &#125;&#125;;int main()&#123; // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 Base b; b.who(); // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。 Base *ptr = new Derived(); ptr-&gt;who(); // 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。 delete ptr; ptr = nullptr; system(\"pause\"); return 0;&#125; volatile1volatile int i = 10; volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。 volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值） const 可以是 volatile （如只读的状态寄存器） 指针可以是 volatile assert()断言，是宏，而非函数。assert 宏的原型定义在 &lt;assert.h&gt;（C）、&lt;cassert&gt;（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include &lt;assert.h&gt; 之前。 assert() 使用 1234#define NDEBUG // 加上这行，则 assert 不可用#include &lt;assert.h&gt;assert( p != NULL ); // assert 不可用 sizeof() sizeof 对数组，得到整个数组所占空间大小。 sizeof 对指针，得到指针本身所占空间大小。 #pragma pack(n)设定结构体、联合以及类成员变量以 n 字节方式对齐 #pragma pack(n) 使用 1234567891011#pragma pack(push) // 保存对齐状态#pragma pack(4) // 设定为 4 字节对齐struct test&#123; char m1; double m4; int m3;&#125;;#pragma pack(pop) // 恢复对齐状态 位域1Bit mode: 2; // mode 占 2 位 类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。 位域在内存中的布局是与机器有关的 位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定 取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域 extern “C” 被 extern 限定的函数或变量是 extern 类型的 被 extern &quot;C&quot; 修饰的变量和函数是按照 C 语言方式编译和链接的 extern &quot;C&quot; 的作用是让 C++ 编译器将 extern &quot;C&quot; 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。 extern “C” 使用 123456789#ifdef __cplusplusextern \"C\" &#123;#endifvoid *memset(void *, int, size_t);#ifdef __cplusplus&#125;#endif struct 和 typedef structC 中1234// ctypedef struct Student &#123; int age; &#125; S; 等价于 123456// cstruct Student &#123; int age; &#125;;typedef struct Student S; 此时 S 等价于 struct Student，但两个标识符名称空间不相同。 另外还可以定义与 struct Student 不冲突的 void Student() {}。 C++ 中由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。 一、如果在类标识符空间定义了 struct Student {...};，使用 Student me; 时，编译器将搜索全局标识符表，Student 未找到，则在类标识符内搜索。 即表现为可以使用 Student 也可以使用 struct Student，如下： 123456// cppstruct Student &#123; int age; &#125;;void f( Student me ); // 正确，\"struct\" 关键字可省略 二、若定义了与 Student 同名函数之后，则 Student 只代表函数，不代表结构体，如下： 12345678910111213typedef struct Student &#123; int age; &#125; S;void Student() &#123;&#125; // 正确，定义后 \"Student\" 只代表此函数//void S() &#123;&#125; // 错误，符号 \"S\" 已经被定义为一个 \"struct Student\" 的别名int main() &#123; Student(); struct Student me; // 或者 \"S me\"; return 0;&#125; C++ 中 struct 和 class总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。 区别 最本质的一个区别就是默认的访问控制 默认的继承访问权限。struct 是 public 的，class 是 private 的。 struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。 union 联合联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点： 默认访问控制符为 public 可以含有构造函数、析构函数 不能含有引用类型的成员 不能继承自其他类，不能作为基类 不能含有虚函数 匿名 union 在定义所在作用域可直接访问 union 成员 匿名 union 不能包含 protected 成员或 private 成员 全局匿名联合必须是静态（static）的 union 使用 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;union UnionTest &#123; UnionTest() : i(10) &#123;&#125;; int i; double d;&#125;;static union &#123; int i; double d;&#125;;int main() &#123; UnionTest u; union &#123; int i; double d; &#125;; std::cout &lt;&lt; u.i &lt;&lt; std::endl; // 输出 UnionTest 联合的 10 ::i = 20; std::cout &lt;&lt; ::i &lt;&lt; std::endl; // 输出全局静态匿名联合的 20 i = 30; std::cout &lt;&lt; i &lt;&lt; std::endl; // 输出局部匿名联合的 30 return 0;&#125; C 实现 C++ 类C 实现 C++ 的面向对象特性（封装、继承、多态） 封装：使用函数指针把属性与方法封装到结构体中 继承：结构体嵌套 多态：父类与子类方法的函数指针不同 Can you write object-oriented code in C? [closed] explicit（显式）关键字 explicit 修饰构造函数时，可以防止隐式转换和复制初始化 explicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外 explicit 使用 123456789101112131415161718192021222324252627282930313233343536373839404142struct A&#123; A(int) &#123; &#125; operator bool() const &#123; return true; &#125;&#125;;struct B&#123; explicit B(int) &#123;&#125; explicit operator bool() const &#123; return true; &#125;&#125;;void doA(A a) &#123;&#125;void doB(B b) &#123;&#125;int main()&#123; A a1(1); // OK：直接初始化 A a2 = 1; // OK：复制初始化 A a3&#123; 1 &#125;; // OK：直接列表初始化 A a4 = &#123; 1 &#125;; // OK：复制列表初始化 A a5 = (A)1; // OK：允许 static_cast 的显式转换 doA(1); // OK：允许从 int 到 A 的隐式转换 if (a1); // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换 bool a6（a1）; // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换 bool a7 = a1; // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换 bool a8 = static_cast&lt;bool&gt;(a1); // OK ：static_cast 进行直接初始化 B b1(1); // OK：直接初始化 B b2 = 1; // 错误：被 explicit 修饰构造函数的对象不可以复制初始化 B b3&#123; 1 &#125;; // OK：直接列表初始化 B b4 = &#123; 1 &#125;; // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化 B b5 = (B)1; // OK：允许 static_cast 的显式转换 doB(1); // 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换 if (b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换 bool b6(b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换 bool b7 = b1; // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换 bool b8 = static_cast&lt;bool&gt;(b1); // OK：static_cast 进行直接初始化 return 0;&#125; friend 友元类和友元函数 能访问私有成员 破坏封装性 友元关系不可传递 友元关系的单向性 友元声明的形式及数量不受限制 usingusing 声明一条 using 声明 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如： 1using namespace_name::name; 构造函数的 using 声明在 C++11 中，派生类能够重用其直接基类定义的构造函数。 12345class Derived : Base &#123;public: using Base::Base; /* ... */&#125;; 如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数： 1Derived(parms) : Base(args) &#123; &#125; using 指示using 指示 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如： 1using namespace_name name; 尽量少使用 using 指示 污染命名空间 一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它只导入了指定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。 using 使用 尽量少使用 using 指示 1using namespace std; 应该多使用 using 声明 123int x;std::cin &gt;&gt; x ;std::cout &lt;&lt; x &lt;&lt; std::endl; 或者 123456using std::cin;using std::cout;using std::endl;int x;cin &gt;&gt; x;cout &lt;&lt; x &lt;&lt; endl; :: 范围解析运算符分类 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的 :: 使用 1234567891011121314151617181920212223int count = 11; // 全局（::）的 countclass A &#123;public: static int count; // 类 A 的 count（A::count）&#125;;int A::count = 21;void fun()&#123; int count = 31; // 初始化局部的 count 为 31 count = 32; // 设置局部的 count 的值为 32&#125;int main() &#123; ::count = 12; // 测试 1：设置全局的 count 的值为 12 A::count = 22; // 测试 2：设置类 A 的 count 为 22 fun(); // 测试 3 return 0;&#125; enum 枚举类型限定作用域的枚举类型1enum class open_modes &#123; input, output, append &#125;; 不限定作用域的枚举类型12enum color &#123; red, yellow, green &#125;;enum &#123; floatPrec = 6, doublePrec = 10 &#125;; decltypedecltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法： 1decltype ( expression ) decltype 使用 1234567891011121314// 尾置返回允许我们在参数列表之后声明返回类型template &lt;typename It&gt;auto fcn(It beg, It end) -&gt; decltype(*beg)&#123; // 处理序列 return *beg; // 返回序列中一个元素的引用&#125;// 为了使用模板参数成员，必须用 typenametemplate &lt;typename It&gt;auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type&#123; // 处理序列 return *beg; // 返回序列中一个元素的拷贝&#125; 引用左值引用常规引用，一般表示对象的身份。 右值引用右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。 右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面： 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 能够更简洁明确地定义泛型函数。 引用折叠 X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp; 可折叠成 X&amp; X&amp;&amp; &amp;&amp; 可折叠成 X&amp;&amp; 宏 宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。 成员初始化列表好处 更高效：少了一次调用默认构造函数的过程。 有些场合必须要用初始化列表： 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化 initializer_list 列表初始化用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 std::initializer_list 参数. initializer_list 使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;initializer_list&gt; template &lt;class T&gt;struct S &#123; std::vector&lt;T&gt; v; S(std::initializer_list&lt;T&gt; l) : v(l) &#123; std::cout &lt;&lt; \"constructed with a \" &lt;&lt; l.size() &lt;&lt; \"-element list\\n\"; &#125; void append(std::initializer_list&lt;T&gt; l) &#123; v.insert(v.end(), l.begin(), l.end()); &#125; std::pair&lt;const T*, std::size_t&gt; c_arr() const &#123; return &#123;&amp;v[0], v.size()&#125;; // 在 return 语句中复制列表初始化 // 这不使用 std::initializer_list &#125;&#125;; template &lt;typename T&gt;void templated_fn(T) &#123;&#125; int main()&#123; S&lt;int&gt; s = &#123;1, 2, 3, 4, 5&#125;; // 复制初始化 s.append(&#123;6, 7, 8&#125;); // 函数调用中的列表初始化 std::cout &lt;&lt; \"The vector size is now \" &lt;&lt; s.c_arr().second &lt;&lt; \" ints:\\n\"; for (auto n : s.v) std::cout &lt;&lt; n &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"Range-for over brace-init-list: \\n\"; for (int x : &#123;-1, -2, -3&#125;) // auto 的规则令此带范围 for 工作 std::cout &lt;&lt; x &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; auto al = &#123;10, 11, 12&#125;; // auto 的特殊规则 std::cout &lt;&lt; \"The list bound to auto has size() = \" &lt;&lt; al.size() &lt;&lt; '\\n'; // templated_fn(&#123;1, 2, 3&#125;); // 编译错误！“ &#123;1, 2, 3&#125; ”不是表达式， // 它无类型，故 T 无法推导 templated_fn&lt;std::initializer_list&lt;int&gt;&gt;(&#123;1, 2, 3&#125;); // OK templated_fn&lt;std::vector&lt;int&gt;&gt;(&#123;1, 2, 3&#125;); // 也 OK&#125; 面向对象面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。 面向对象三大特征 —— 封装、继承、多态 封装把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。 public 成员：可以被任意实体访问 protected 成员：只允许被子类及本类的成员函数访问 private 成员：只允许被本类的成员函数、友元类或友元函数访问 继承 基类（父类）——&gt; 派生类（子类） 多态 多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。 多态是以封装和继承为基础的。 C++ 多态分类及实现： 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载 子类型多态（Subtype Polymorphism，运行期）：虚函数 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换 The Four Polymorphisms in C++ 静态多态（编译期/早绑定）函数重载 123456class A&#123;public: void do(int a); void do(int a, int b);&#125;; 动态多态（运行期期/晚绑定） 虚函数：用 virtual 修饰成员函数，使其成为虚函数 注意： 普通函数（非类成员函数）不能是虚函数 静态函数（static）不能是虚函数 构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针） 内联函数不能是表现多态性时的虚函数，解释见：虚函数（virtual）可以是内联函数（inline）吗？ 动态多态使用 123456789101112131415161718192021222324252627282930313233class Shape // 形状类&#123;public: virtual double calcArea() &#123; ... &#125; virtual ~Shape();&#125;;class Circle : public Shape // 圆形类&#123;public: virtual double calcArea(); ...&#125;;class Rect : public Shape // 矩形类&#123;public: virtual double calcArea(); ...&#125;;int main()&#123; Shape * shape1 = new Circle(4.0); Shape * shape2 = new Rect(5.0, 6.0); shape1-&gt;calcArea(); // 调用圆形类里面的方法 shape2-&gt;calcArea(); // 调用矩形类里面的方法 delete shape1; shape1 = nullptr; delete shape2; shape2 = nullptr; return 0;&#125; 虚析构函数虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。 虚析构函数使用 123456789101112131415161718192021class Shape&#123;public: Shape(); // 构造函数不能是虚函数 virtual double calcArea(); virtual ~Shape(); // 虚析构函数&#125;;class Circle : public Shape // 圆形类&#123;public: virtual double calcArea(); ...&#125;;int main()&#123; Shape * shape1 = new Circle(4.0); shape1-&gt;calcArea(); delete shape1; // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。 shape1 = NULL; return 0；&#125; 纯虚函数纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。 1virtual int A() = 0; 虚函数、纯虚函数 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。 虚基类是虚继承中的基类，具体见下文虚继承。 CSDN . C++ 中的虚函数、纯虚函数区别和联系 虚函数指针、虚函数表 虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。 虚函数表：在程序只读数据段（.rodata section，见：目标文件存储结构），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。 C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现 虚继承虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。 底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。 实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。 虚继承、虚函数 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间） 不同之处： 虚继承 虚基类依旧存在继承类中，只占用存储空间 虚基类表存储的是虚基类相对直接继承类的偏移 虚函数 虚函数不占用存储空间 虚函数表存储的是虚函数地址 模板类、成员模板、虚函数 模板类中可以使用虚函数 一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数 抽象类、接口类、聚合类 抽象类：含有纯虚函数的类 接口类：仅含有纯虚函数的抽象类 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点： 所有成员都是 public 没有定义任何构造函数 没有类内初始化 没有基类，也没有 virtual 函数 内存分配和管理malloc、calloc、realloc、alloca malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。 calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。 realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。 alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。 malloc、free用于分配、释放内存 malloc、free 使用 申请内存，确认是否申请成功 12char *str = (char*) malloc(100);assert(str != nullptr); 释放内存后指针置空 12free(p); p = nullptr; new、delete new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。 delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。 new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。 new、delete 使用 申请内存，确认是否申请成功 123456int main()&#123; T* t = new T(); // 先内存分配 ，再构造函数 delete t; // 先析构函数，再内存释放 return 0;&#125; 定位 new定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。 1234new (place_address) typenew (place_address) type (initializers)new (place_address) type [size]new (place_address) type [size] &#123; braced initializer list &#125; place_address 是个指针 initializers 提供一个（可能为空的）以逗号分隔的初始值列表 delete this 合法吗？ Is it legal (and moral) for a member function to say delete this? 合法，但： 必须保证 this 对象是通过 new（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的 必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数 必须保证成员函数的 delete this 后面没有调用 this 了 必须保证 delete this 后没有人使用了 如何定义一个只能在堆上（栈上）生成对象的类？ 如何定义一个只能在堆上（栈上）生成对象的类? 只能在堆上方法：将析构函数设置为私有 原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。 只能在栈上方法：将 new 和 delete 重载为私有 原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。 智能指针C++ 标准库（STL）中头文件：#include &lt;memory&gt; C++ 981std::auto_ptr&lt;std::string&gt; ps (new std::string(str))； C++ 11 shared_ptr unique_ptr weak_ptr auto_ptr（被 C++11 弃用） Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。 Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。 shared_ptr多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁 weak_ptrweak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题 unique_ptrunique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。 unique_ptr 用于取代 auto_ptr auto_ptr被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。 auto_ptr 与 unique_ptr 比较 auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了move 语义； auto_ptr 对象不能管理数组（析构调用 delete），unique_ptr 可以管理数组（析构调用 delete[] ）； 强制类型转换运算符 MSDN . 强制转换运算符 static_cast 用于非多态类型的转换 不执行运行时类型检查（转换安全性不如 dynamic_cast） 通常用于转换数值数据类型（如 float -&gt; int） 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法） 向上转换是一种隐式转换。 dynamic_cast 用于多态类型的转换 执行行运行时类型检查 只适用于指针或引用 对不明确的指针的转换将失败（返回 nullptr），但不引发异常 可以在整个类层次结构中移动指针，包括向上转换、向下转换 const_cast 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ） reinterpret_cast 用于位的简单重新解释 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。 允许将任何指针转换为任何其他指针类型（如 char* 到 int* 或 One_class* 到 Unrelated_class* 之类的转换，但其本身并不安全） 也允许将任何整数类型转换为任何指针类型以及反向转换。 reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。 bad_cast 由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。 bad_cast 使用 123456try &#123; Circle&amp; ref_circle = dynamic_cast&lt;Circle&amp;&gt;(ref_shape); &#125; catch (bad_cast b) &#123; cout &lt;&lt; \"Caught: \" &lt;&lt; b.what(); &#125; 运行时类型信息 (RTTI)dynamic_cast 用于多态类型的转换 typeid typeid 运算符允许在运行时确定对象的类型 type_id 返回一个 type_info 对象的引用 如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数 只能获取对象的实际类型 type_info type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。 头文件：typeinfo typeid、type_info 使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;using namespace std;class Flyable // 能飞的&#123;public: virtual void takeoff() = 0; // 起飞 virtual void land() = 0; // 降落&#125;;class Bird : public Flyable // 鸟&#123;public: void foraging() &#123;...&#125; // 觅食 virtual void takeoff() &#123;...&#125; virtual void land() &#123;...&#125; virtual ~Bird()&#123;&#125;&#125;;class Plane : public Flyable // 飞机&#123;public: void carry() &#123;...&#125; // 运输 virtual void takeoff() &#123;...&#125; virtual void land() &#123;...&#125;&#125;;class type_info&#123;public: const char* name() const; bool operator == (const type_info &amp; rhs) const; bool operator != (const type_info &amp; rhs) const; int before(const type_info &amp; rhs) const; virtual ~type_info();private: ...&#125;;void doSomething(Flyable *obj) // 做些事情&#123; obj-&gt;takeoff(); cout &lt;&lt; typeid(*obj).name() &lt;&lt; endl; // 输出传入对象类型（\"class Bird\" or \"class Plane\"） if(typeid(*obj) == typeid(Bird)) // 判断对象类型 &#123; Bird *bird = dynamic_cast&lt;Bird *&gt;(obj); // 对象转化 bird-&gt;foraging(); &#125; obj-&gt;land();&#125;int main()&#123; Bird *b = new Bird(); doSomething(b); delete b; b = nullptr; return 0;&#125; ⭐️ EffectiveEffective C++ 视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL） 宁可以编译器替换预处理器（尽量以 const、enum、inline 替换 #define） 尽可能使用 const 确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高） 了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数） 若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现） 为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数） 别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理） 绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class） 令 operator= 返回一个 reference to *this （用于连锁赋值） 在 operator= 中处理 “自我赋值” 赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数） 以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII）） 在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr）） 在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便） 成对使用 new 和 delete 时要采取相同形式（new 中使用 [] 则 delete []，new 中不使用 [] 则 delete） 以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏） 让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任） 设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。 宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象） 必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。） 将成员变量声明为 private（为了封装、一致性、对其读写精确控制等） 宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性） 若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数 考虑写一个不抛异常的 swap 函数 尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率） 尽量少做转型动作（旧式：(T)expression、T(expression)；新式：const_cast&lt;T&gt;(expression)、dynamic_cast&lt;T&gt;(expression)、reinterpret_cast&lt;T&gt;(expression)、static_cast&lt;T&gt;(expression)、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型） 避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性） 为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型） 透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级） 将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件） 确定你的 public 继承塑模出 is-a（是一种）关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象） 避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日） 区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承） 考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 tr1::function 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数） 绝不重新定义继承而来的 non-virtual 函数 绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound） 通过复合塑模 has-a（有一个）或 “根据某物实现出”（在应用域（application domain），复合意味 has-a（有一个）；在实现域（implementation domain），复合意味着 is-implemented-in-terms-of（根据某物实现出）） 明智而审慎地使用 private 继承（private 继承意味着 is-implemented-in-terms-of（根据某物实现出），尽可能使用复合，当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的时候 virtual 函数，或需要 empty base 最优化时，才使用 private 继承） 明智而审慎地使用多重继承（多继承比单一继承复杂，可能导致新的歧义性，以及对 virtual 继承的需要，但确有正当用途，如 “public 继承某个 interface class” 和 “private 继承某个协助实现的 class”；virtual 继承可解决多继承下菱形继承的二义性问题，但会增加大小、速度、初始化及赋值的复杂度等等成本） 了解隐式接口和编译期多态（class 和 templates 都支持接口（interfaces）和多态（polymorphism）；class 的接口是以签名为中心的显式的（explicit），多态则是通过 virtual 函数发生于运行期；template 的接口是奠基于有效表达式的隐式的（implicit），多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期） 了解 typename 的双重意义（声明 template 类型参数是，前缀关键字 class 和 typename 的意义完全相同；请使用关键字 typename 标识嵌套从属类型名称，但不得在基类列（base class lists）或成员初值列（member initialization list）内以它作为 base class 修饰符） 学习处理模板化基类内的名称（可在 derived class templates 内通过 this-&gt; 指涉 base class templates 内的成员名称，或藉由一个明白写出的 “base class 资格修饰符” 完成） 将与参数无关的代码抽离 templates（因类型模板参数（non-type template parameters）而造成代码膨胀往往可以通过函数参数或 class 成员变量替换 template 参数来消除；因类型参数（type parameters）而造成的代码膨胀往往可以通过让带有完全相同二进制表述（binary representations）的实现类型（instantiation types）共享实现码） 运用成员函数模板接受所有兼容类型（请使用成员函数模板（member function templates）生成 “可接受所有兼容类型” 的函数；声明 member templates 用于 “泛化 copy 构造” 或 “泛化 assignment 操作” 时还需要声明正常的 copy 构造函数和 copy assignment 操作符） 需要类型转换时请为模板定义非成员函数（当我们编写一个 class template，而它所提供之 “与此 template 相关的” 函数支持 “所有参数之隐式类型转换” 时，请将那些函数定义为 “class template 内部的 friend 函数”） 请使用 traits classes 表现类型信息（traits classes 通过 templates 和 “templates 特化” 使得 “类型相关信息” 在编译期可用，通过重载技术（overloading）实现在编译期对类型执行 if…else 测试） 认识 template 元编程（模板元编程（TMP，template metaprogramming）可将工作由运行期移往编译期，因此得以实现早期错误侦测和更高的执行效率；TMP 可被用来生成 “给予政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码） 了解 new-handler 的行为（set_new_handler 允许客户指定一个在内存分配无法获得满足时被调用的函数；nothrow new 是一个颇具局限的工具，因为它只适用于内存分配（operator new），后继的构造函数调用还是可能抛出异常） 了解 new 和 delete 的合理替换时机（为了检测运用错误、收集动态分配内存之使用统计信息、增加分配和归还速度、降低缺省内存管理器带来的空间额外开销、弥补缺省分配器中的非最佳齐位、将相关对象成簇集中、获得非传统的行为） 编写 new 和 delete 时需固守常规（operator new 应该内涵一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用 new-handler，它也应该有能力处理 0 bytes 申请，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”；operator delete 应该在收到 null 指针时不做任何事，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”） 写了 placement new 也要写 placement delete（当你写一个 placement operator new，请确定也写出了对应的 placement operator delete，否则可能会发生隐微而时断时续的内存泄漏；当你声明 placement new 和 placement delete，请确定不要无意识（非故意）地遮掩了它们地正常版本） 不要轻忽编译器的警告 让自己熟悉包括 TR1 在内的标准程序库（TR1，C++ Technical Report 1，C++11 标准的草稿文件） 让自己熟悉 Boost（准标准库） More Effective c++ 仔细区别 pointers 和 references（当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references；任何其他时候，请采用 pointers） 最好使用 C++ 转型操作符（static_cast、const_cast、dynamic_cast、reinterpret_cast） 绝不要以多态（polymorphically）方式处理数组（多态（polymorphism）和指针算术不能混用；数组对象几乎总是会涉及指针的算术运算，所以数组和多态不要混用） 非必要不提供 default constructor（避免对象中的字段被无意义地初始化） 对定制的 “类型转换函数” 保持警觉（单自变量 constructors 可通过简易法（explicit 关键字）或代理类（proxy classes）来避免编译器误用；隐式类型转换操作符可改为显式的 member function 来避免非预期行为） 区别 increment/decrement 操作符的前置（prefix）和后置（postfix）形式（前置式累加后取出，返回一个 reference；后置式取出后累加，返回一个 const 对象；处理用户定制类型时，应该尽可能使用前置式 increment；后置式的实现应以其前置式兄弟为基础） 千万不要重载 &amp;&amp;，|| 和 , 操作符（&amp;&amp; 与 || 的重载会用 “函数调用语义” 取代 “骤死式语义”；, 的重载导致不能保证左侧表达式一定比右侧表达式更早被评估） 了解各种不同意义的 new 和 delete（new operator、operator new、placement new、operator new[]；delete operator、operator delete、destructor、operator delete[]） 利用 destructors 避免泄漏资源（在 destructors 释放资源可以避免异常时的资源泄漏） 在 constructors 内阻止资源泄漏（由于 C++ 只会析构已构造完成的对象，因此在构造函数可以使用 try…catch 或者 auto_ptr（以及与之相似的 classes） 处理异常时资源泄露问题） 禁止异常流出 destructors 之外（原因：一、避免 terminate 函数在 exception 传播过程的栈展开（stack-unwinding）机制种被调用；二、协助确保 destructors 完成其应该完成的所有事情） 了解 “抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异（第一，exception objects 总是会被复制（by pointer 除外），如果以 by value 方式捕捉甚至被复制两次，而传递给函数参数的对象则不一定得复制；第二，“被抛出成为 exceptions” 的对象，其被允许的类型转换动作比 “被传递到函数去” 的对象少；第三，catch 子句以其 “出现于源代码的顺序” 被编译器检验对比，其中第一个匹配成功者便执行，而调用一个虚函数，被选中执行的是那个 “与对象类型最佳吻合” 的函数） 以 by reference 方式捕获 exceptions（可避免对象删除问题、exception objects 的切割问题，可保留捕捉标准 exceptions 的能力，可约束 exception object 需要复制的次数） 明智运用 exception specifications（exception specifications 对 “函数希望抛出什么样的 exceptions” 提供了卓越的说明；也有一些缺点，包括编译器只对它们做局部性检验而很容易不经意地违反，与可能会妨碍更上层的 exception 处理函数处理未预期的 exceptions） 了解异常处理的成本（粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%-10%，执行速度亦大约下降这个数；因此请将你对 try 语句块和 exception specifications 的使用限制于非用不可的地点，并且在真正异常的情况下才抛出 exceptions） 谨记 80-20 法则（软件的整体性能几乎总是由其构成要素（代码）的一小部分决定的，可使用程序分析器（program profiler）识别出消耗资源的代码） 考虑使用 lazy evaluation（缓式评估）（可应用于：Reference Counting（引用计数）来避免非必要的对象复制、区分 operator[] 的读和写动作来做不同的事情、Lazy Fetching（缓式取出）来避免非必要的数据库读取动作、Lazy Expression Evaluation（表达式缓评估）来避免非必要的数值计算动作） 分期摊还预期的计算成本（当你必须支持某些运算而其结构几乎总是被需要，或其结果常常被多次需要的时候，over-eager evaluation（超急评估）可以改善程序效率） Google C++ Style Guide 英文：Google C++ Style Guide 中文：C++ 风格指南 其他 Bjarne Stroustrup 的常见问题 Bjarne Stroustrup 的 C++ 风格和技巧常见问题 📦 STLSTL 索引STL 方法含义索引 STL 容器 容器 底层数据结构 时间复杂度 有无序 可不可重复 其他 array 数组 随机读改 O(1) 无序 可重复 支持随机访问 vector 数组 随机读改、尾部插入、尾部删除 O(1)头部插入、头部删除 O(n) 无序 可重复 支持随机访问 deque 双端队列 头尾插入、头尾删除 O(1) 无序 可重复 一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问 forward_list 单向链表 插入、删除 O(1) 无序 可重复 不支持随机访问 list 双向链表 插入、删除 O(1) 无序 可重复 不支持随机访问 stack deque / list 顶部插入、顶部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 queue deque / list 尾部插入、头部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 priority_queue vector + max-heap 插入、删除 O(log2n) 有序 可重复 vector容器+heap处理规则 set 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multiset 红黑树 插入、删除、查找 O(log2n) 有序 可重复 map 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multimap 红黑树 插入、删除、查找 O(log2n) 有序 可重复 unordered_set 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 unordered_multiset 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 unordered_map 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 unordered_multimap 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 STL 算法 算法 底层算法 时间复杂度 可不可重复 find 顺序查找 O(n) 可重复 sort 内省排序 O(n*log2n) 可重复 〽️ 数据结构顺序结构顺序栈（Sequence Stack）SqStack.cpp 顺序栈数据结构和图片 123456typedef struct &#123; ElemType *elem; int top; int size; int increment;&#125; SqStack; 队列（Sequence Queue）队列数据结构 123456typedef struct &#123; ElemType * elem; int front; int rear; int maxSize;&#125;SqQueue; 非循环队列非循环队列图片 SqQueue.rear++ 循环队列循环队列图片 SqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize 顺序表（Sequence List）SqList.cpp 顺序表数据结构和图片 123456typedef struct &#123; ElemType *elem; int length; int size; int increment;&#125; SqList; 链式结构LinkList.cpp LinkList_with_head.cpp 链式数据结构 1234typedef struct LNode &#123; ElemType data; struct LNode *next;&#125; LNode, *LinkList; 链队列（Link Queue）链队列图片 线性表的链式表示单链表（Link List）单链表图片 双向链表（Du-Link-List）双向链表图片 循环链表（Cir-Link-List）循环链表图片 哈希表HashTable.cpp 概念哈希函数：H(key): K -&gt; D , key ∈ K 构造方法 直接定址法 除留余数法 数字分析法 折叠法 平方取中法 冲突处理方法 链地址法：key 相同的用单链表链接 开放定址法 线性探测法：key 相同 -&gt; 放到 key 的下一个位置，Hi = (H(key) + i) % m 二次探测法：key 相同 -&gt; 放到 Di = 1^2, -1^2, ..., ±（k)^2,(k&lt;=m/2） 随机探测法：H = (H(key) + 伪随机数) % m 线性探测的哈希表数据结构线性探测的哈希表数据结构和图片 123456789101112typedef char KeyType;typedef struct &#123; KeyType key;&#125;RcdType;typedef struct &#123; RcdType *rcd; int size; int count; bool *tag;&#125;HashTable; 递归概念函数直接或间接地调用自身 递归与分治 分治法 问题的分解 问题规模的分解 折半查找（递归） 归并排序（递归） 快速排序（递归） 递归与迭代 迭代：反复利用变量旧值推出新值 折半查找（迭代） 归并排序（迭代） 广义表头尾链表存储表示广义表的头尾链表存储表示和图片 12345678910111213141516// 广义表的头尾链表存储表示typedef enum &#123;ATOM, LIST&#125; ElemTag;// ATOM==0：原子，LIST==1：子表typedef struct GLNode &#123; ElemTag tag; // 公共部分，用于区分原子结点和表结点 union &#123; // 原子结点和表结点的联合部分 AtomType atom; // atom 是原子结点的值域，AtomType 由用户定义 struct &#123; struct GLNode *hp, *tp; &#125; ptr; // ptr 是表结点的指针域，prt.hp 和 ptr.tp 分别指向表头和表尾 &#125; a;&#125; *GList, GLNode; 扩展线性链表存储表示扩展线性链表存储表示和图片 1234567891011121314// 广义表的扩展线性链表存储表示typedef enum &#123;ATOM, LIST&#125; ElemTag;// ATOM==0：原子，LIST==1：子表typedef struct GLNode1 &#123; ElemTag tag; // 公共部分，用于区分原子结点和表结点 union &#123; // 原子结点和表结点的联合部分 AtomType atom; // 原子结点的值域 struct GLNode1 *hp; // 表结点的表头指针 &#125; a; struct GLNode1 *tp; // 相当于线性链表的 next，指向下一个元素结点&#125; *GList1, GLNode1; 二叉树BinaryTree.cpp 性质 非空二叉树第 i 层最多 2(i-1) 个结点 （i &gt;= 1） 深度为 k 的二叉树最多 2k - 1 个结点 （k &gt;= 1） 度为 0 的结点数为 n0，度为 2 的结点数为 n2，则 n0 = n2 + 1 有 n 个结点的完全二叉树深度 k = ⌊ log2(n) ⌋ + 1 对于含 n 个结点的完全二叉树中编号为 i （1 &lt;= i &lt;= n） 的结点 若 i = 1，为根，否则双亲为 ⌊ i / 2 ⌋ 若 2i &gt; n，则 i 结点没有左孩子，否则孩子编号为 2i 若 2i + 1 &gt; n，则 i 结点没有右孩子，否则孩子编号为 2i + 1 存储结构二叉树数据结构 12345typedef struct BiTNode&#123; TElemType data; struct BiTNode *lchild, *rchild;&#125;BiTNode, *BiTree; 顺序存储二叉树顺序存储图片 链式存储二叉树链式存储图片 遍历方式 先序遍历 中序遍历 后续遍历 层次遍历 分类 满二叉树 完全二叉树（堆） 大顶堆：根 &gt;= 左 &amp;&amp; 根 &gt;= 右 小顶堆：根 &lt;= 左 &amp;&amp; 根 &lt;= 右 二叉查找树（二叉排序树）：左 &lt; 根 &lt; 右 平衡二叉树（AVL树）：| 左子树树高 - 右子树树高 | &lt;= 1 最小失衡树：平衡二叉树插入新结点导致失衡的子树：调整： LL型：根的左孩子右旋 RR型：根的右孩子左旋 LR型：根的左孩子左旋，再右旋 RL型：右孩子的左子树，先右旋，再左旋 其他树及森林树的存储结构 双亲表示法 双亲孩子表示法 孩子兄弟表示法 并查集一种不相交的子集所构成的集合 S = {S1, S2, …, Sn} 平衡二叉树（AVL树）性质 | 左子树树高 - 右子树树高 | &lt;= 1 平衡二叉树必定是二叉搜索树，反之则不一定 最小二叉平衡树的节点的公式：F(n)=F(n-1)+F(n-2)+1 （1 是根节点，F(n-1) 是左子树的节点数量，F(n-2) 是右子树的节点数量） 平衡二叉树图片 最小失衡树平衡二叉树插入新结点导致失衡的子树 调整： LL 型：根的左孩子右旋 RR 型：根的右孩子左旋 LR 型：根的左孩子左旋，再右旋 RL 型：右孩子的左子树，先右旋，再左旋 红黑树RedBlackTree.cpp 红黑树的特征是什么？ 节点是红色或黑色。 根是黑色。 所有叶子都是黑色（叶子是 NIL 节点）。 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同） 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红） 调整 变色 左旋 右旋 应用 关联数组：如 STL 中的 map、set 红黑树、B 树、B+ 树的区别？ 红黑树的深度比较大，而 B 树和 B+ 树的深度则相对要小一些 B+ 树则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。 B 树（B-tree）、B+ 树（B+-tree）B 树、B+ 树图片 特点 一般化的二叉查找树（binary search tree） “矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好） 应用 大部分文件系统、数据库系统都采用B树、B+树作为索引结构 区别 B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。 B+树中所有叶子节点都是通过指针连接在一起，而B树不会。 B树的优点对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。 B+树的优点 非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。 B 树、B+ 树区别来自：differences-between-b-trees-and-b-trees、B树和B+树的区别 八叉树八叉树图片 八叉树（octree），或称八元树，是一种用于描述三维空间（划分空间）的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。 用途 三维计算机图形 最邻近搜索 ⚡️ 算法排序 排序算法 平均时间复杂度 最差时间复杂度 空间复杂度 数据对象稳定性 冒泡排序 O(n2) O(n2) O(1) 稳定 选择排序 O(n2) O(n2) O(1) 数组不稳定、链表稳定 插入排序 O(n2) O(n2) O(1) 稳定 快速排序 O(n*log2n) O(n2) O(log2n) 不稳定 堆排序 O(n*log2n) O(n*log2n) O(1) 不稳定 归并排序 O(n*log2n) O(n*log2n) O(n) 稳定 希尔排序 O(n*log2n) O(n2) O(1) 不稳定 计数排序 O(n+m) O(n+m) O(n+m) 稳定 桶排序 O(n) O(n) O(m) 稳定 基数排序 O(k*n) O(n2) 稳定 均按从小到大排列 k：代表数值中的 “数位” 个数 n：代表数据规模 m：代表数据的最大值减最小值 来自：wikipedia . 排序算法 查找 查找算法 平均时间复杂度 空间复杂度 查找条件 顺序查找 O(n) O(1) 无序或有序 二分查找（折半查找） O(log2n) O(1) 有序 插值查找 O(log2(log2n)) O(1) 有序 斐波那契查找 O(log2n) O(1) 有序 哈希查找 O(1) O(n) 无序或有序 二叉查找树（二叉搜索树查找） O(log2n) 红黑树 O(log2n) 2-3树 O(log2n - log3n) B树/B+树 O(log2n) 图搜索算法 图搜索算法 数据结构 遍历时间复杂度 空间复杂度 BFS广度优先搜索 邻接矩阵邻接链表 O(|v|2)O(|v|+|E|) O(|v|2)O(|v|+|E|) DFS深度优先搜索 邻接矩阵邻接链表 O(|v|2)O(|v|+|E|) O(|v|2)O(|v|+|E|) 其他算法 算法 思想 应用 分治法 把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并 循环赛日程安排问题、排序算法（快速排序、归并排序） 动态规划 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题 背包问题、斐波那契数列 贪心法 一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法 旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码 ❓ ProblemsSingle Problem Chessboard Coverage Problem（棋盘覆盖问题） Knapsack Problem（背包问题） Neumann Neighbor Problem（冯诺依曼邻居问题） Round Robin Problem（循环赛日程安排问题） Tubing Problem（输油管道问题） Leetcode Problems Github . haoel/leetcode Github . pezy/LeetCode 剑指 Offer Github . zhedahht/CodingInterviewChinese2 Github . gatieme/CodingInterviews Cracking the Coding Interview 程序员面试金典 Github . careercup/ctci 牛客网 . 程序员面试金典 牛客网 牛客网 . 在线编程专题 💻 操作系统进程与线程对于有线程系统： 进程是资源分配的独立单位 线程是资源调度的独立单位 对于无线程系统： 进程是资源调度、分配的独立单位 进程之间的通信方式以及优缺点 管道（PIPE） 有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信 优点：可以实现任意关系的进程间的通信 缺点： 长期存于系统中，使用不当容易出错 缓冲区有限 无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程） 优点：简单方便 缺点： 局限于单向通信 只能创建在它的进程以及其有亲缘关系的进程之间 缓冲区有限 信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问 优点：可以同步进程 缺点：信号量有限 信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生 消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识 优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合 共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问 优点：无须复制，快捷，信息量大 缺点： 通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信 套接字（Socket）：可用于不同计算机间的进程通信 优点： 传输数据为字节级，传输数据可自定义，数据量小效率高 传输数据时间短，性能高 适合于客户端和服务器端之间信息实时交互 可以加密,数据安全性强 缺点：需对传输的数据进行解析，转化成应用级的数据。 线程之间的通信方式 锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition） 互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。 读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。 自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。 条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。 信号量机制(Semaphore) 无名线程信号量 命名线程信号量 信号机制(Signal)：类似进程间的信号处理 屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。 线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制 进程之间的通信方式以及优缺点来源于：进程线程面试题总结 进程之间私有和共享的资源 私有：地址空间、堆、全局变量、栈、寄存器 共享：代码段，公共数据，进程目录，进程 ID 线程之间私有和共享的资源 私有：线程栈，寄存器，程序计数器 共享：堆，地址空间，全局变量，静态变量 多进程与多线程间的对比、优劣与选择对比 对比维度 多进程 多线程 总结 数据共享、同步 数据共享复杂，需要用 IPC；数据是分开的，同步简单 因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂 各有优势 内存、CPU 占用内存多，切换复杂，CPU 利用率低 占用内存少，切换简单，CPU 利用率高 线程占优 创建销毁、切换 创建销毁、切换复杂，速度慢 创建销毁、切换简单，速度很快 线程占优 编程、调试 编程简单，调试简单 编程复杂，调试复杂 进程占优 可靠性 进程间不会互相影响 一个线程挂掉将导致整个进程挂掉 进程占优 分布式 适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单 适应于多核分布式 进程占优 优劣 优劣 多进程 多线程 优点 编程、调试简单，可靠性较高 创建、销毁、切换速度快，内存、资源占用小 缺点 创建、销毁、切换速度慢，内存、资源占用大 编程、调试复杂，可靠性较差 选择 需要频繁创建销毁的优先用线程 需要进行大量计算的优先使用线程 强相关的处理用线程，弱相关的处理用进程 可能要扩展到多机分布的用进程，多核分布的用线程 都满足需求的情况下，用你最熟悉、最拿手的方式 多进程与多线程间的对比、优劣与选择来自：多线程还是多进程的选择及区别 Linux 内核的同步方式原因在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实像多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。 同步方式 原子操作 信号量（semaphore） 读写信号量（rw_semaphore） 自旋锁（spinlock） 大内核锁（BKL，Big Kernel Lock） 读写锁（rwlock） 大读者锁（brlock-Big Reader Lock） 读-拷贝修改(RCU，Read-Copy Update) 顺序锁（seqlock） 来自：Linux 内核的同步机制，第 1 部分、Linux 内核的同步机制，第 2 部分 死锁原因 系统资源不足 资源分配不当 进程运行推进顺序不合适 产生条件 互斥 请求和保持 不剥夺 环路 预防 打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。 打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。 打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。 打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。 有序资源分配法 银行家算法 文件系统 Windows：FCB 表 + FAT + 位图 Unix：inode + 混合索引 + 成组链接 主机字节序与网络字节序主机字节序（CPU 字节序）概念主机字节序又叫 CPU 字节序，其不是由操作系统决定的，而是由 CPU 指令集架构决定的。主机字节序分为两种： 大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址 小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址 存储方式32 位整数 0x12345678 是从起始位置为 0x00 的地址开始存放，则： 内存地址 0x00 0x01 0x02 0x03 大端 12 34 56 78 小端 78 56 34 12 大端小端图片 判断大端小端判断大端小端 可以这样判断自己 CPU 字节序是大端还是小端： 1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 0x12345678; if (*((char*)&amp;i) == 0x12) cout &lt;&lt; \"大端\" &lt;&lt; endl; else cout &lt;&lt; \"小端\" &lt;&lt; endl; return 0;&#125; 各架构处理器的字节序 x86（Intel、AMD）、MOS Technology 6502、Z80、VAX、PDP-11 等处理器为小端序； Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC（除 V9 外）等处理器为大端序； ARM（默认小端序）、PowerPC（除 PowerPC 970 外）、DEC Alpha、SPARC V9、MIPS、PA-RISC 及 IA64 的字节序是可配置的。 网络字节序网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。 网络字节顺序采用：大端（Big Endian）排列方式。 页面置换算法在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。 分类 全局置换：在整个内存空间置换 局部置换：在本进程中进行置换 算法全局： 工作集算法 缺页率置换算法 局部： 最佳置换算法（OPT） 先进先出置换算法（FIFO） 最近最久未使用（LRU）算法 时钟（Clock）置换算法 ☁️ 计算机网络 本节部分知识点来自《计算机网络（第 7 版）》 计算机网络体系结构： 各层作用及协议 分层 作用 协议 物理层 通过媒介传输比特，确定机械及电气规范（比特 Bit） RJ45、CLOCK、IEEE802.3（中继器，集线器） 数据链路层 将比特组装成帧和点到点的传递（帧 Frame） PPP、FR、HDLC、VLAN、MAC（网桥，交换机） 网络层 负责数据包从源到宿的传递和网际互连（包 Packet） IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器） 运输层 提供端到端的可靠报文传递和错误恢复（ 段Segment） TCP、UDP、SPX 会话层 建立、管理和终止会话（会话协议数据单元 SPDU） NFS、SQL、NETBIOS、RPC 表示层 对数据进行翻译、加密和压缩（表示协议数据单元 PPDU） JPEG、MPEG、ASII 应用层 允许访问OSI环境的手段（应用协议数据单元 APDU） FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 物理层 传输数据的单位：比特 数据传输系统：源系统（源点、发送器） –&gt; 传输系统 –&gt; 目的系统（接收器、终点） 通道： 单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播 双向交替通信（半双工通信）：通信双方都可发消息，但不能同时发送或接收 双向同时通信（全双工通信）：通信双方可以同时发送和接收信息 通道复用技术： 频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源 时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度 波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用 码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信 数据链路层主要信道： 点对点信道 广播信道 点对点信道 数据单元：帧 三个基本问题： 封装成帧：把网络层的 IP 数据报封装成帧，SOH - 数据部分 - EOT 透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符） 差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check） 点对点协议（Point-to-Point Protocol）： 点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议 广播信道广播通信： 硬件地址（物理地址、MAC 地址） 单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同 广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧 多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧 网络层 IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。 ARP（Address Resolution Protocol，地址解析协议） ICMP（Internet Control Message Protocol，网际控制报文协议） IGMP（Internet Group Management Protocol，网际组管理协议） IP 网际协议IP 地址分类： IP 地址 ::= {&lt;网络号&gt;,&lt;主机号&gt;} IP 地址类别 网络号 网络范围 主机号 IP 地址范围 A 类 8bit，第一位固定为 0 0 —— 127 24bit 1.0.0.0 —— 127.255.255.255 B 类 16bit，前两位固定为 10 128.0 —— 191.255 16bit 128.0.0.0 —— 191.255.255.255 C 类 24bit，前三位固定为 110 192.0.0 —— 223.255.255 8bit 192.0.0.0 —— 223.255.255.255 D 类 前四位固定为 1110，后面为多播地址 E 类 前五位固定为 11110，后面保留为今后所用 IP 数据报格式： ICMP 网际控制报文协议ICMP 报文格式： 应用： PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性 TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量 内部网关协议 RIP（Routing Information Protocol，路由信息协议） OSPF（Open Sortest Path First，开放最短路径优先） 外部网关协议 BGP（Border Gateway Protocol，边界网关协议） IP多播 IGMP（Internet Group Management Protocol，网际组管理协议） 多播路由选择协议 VPN 和 NAT VPN（Virtual Private Network，虚拟专用网） NAT（Network Address Translation，网络地址转换） 路由表包含什么？ 网络 ID（Network ID, Network number）：就是目标地址的网络 ID。 子网掩码（subnet mask）：用来判断 IP 所属网络 下一跳地址/接口（Next hop / interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface 指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route 应该包含区域内所有的子网络，而默认网关（Network id: 0.0.0.0, Netmask: 0.0.0.0）指向自治系统的出口。 根据应用和执行的不同，路由表可能含有如下附加信息： 花费（Cost）：就是数据发送过程中通过路径所需要的花费。 路由的服务质量 路由中需要过滤的出/入连接列表 运输层协议： TCP（Transmission Control Protocol，传输控制协议） UDP（User Datagram Protocol，用户数据报协议） 端口： 应用程序 FTP TELNET SMTP DNS TFTP HTTP HTTPS SNMP 端口号 21 23 25 53 69 80 443 161 TCP TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。 特征： 面向连接 只能点对点（一对一）通信 可靠交互 全双工通信 面向字节流 TCP 如何保证可靠传输： 确认和超时重传 数据合理分片和排序 流量控制 拥塞控制 数据校验 TCP 报文结构 TCP 首部 TCP：状态控制码（Code，Control Flag），占 6 比特，含义如下： URG：紧急比特（urgent），当 URG＝1 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。 ACK：确认比特（Acknowledge）。只有当 ACK＝1 时确认号字段才有效，代表这个封包为确认封包。当 ACK＝0 时，确认号无效。 PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。 RST：复位比特(Reset)，当 RST＝1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。 FIN：终止比特(Final)，用来释放一个连接。当 FIN＝1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 UDP UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。 特征： 无连接 尽最大努力交付 面向报文 没有拥塞控制 支持一对一、一对多、多对一、多对多的交互通信 首部开销小 UDP 报文结构 UDP 首部 TCP/UDP 图片来源于：https://github.com/JerryC8080/understand-tcp-udp TCP 与 UDP 的区别 TCP 面向连接，UDP 是无连接的； TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付 TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道 每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信 TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题） UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等） TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节 TCP 黏包问题原因TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。 解决 发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。 包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。 在数据包之间设置边界，如添加特殊符号 \\r\\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \\r\\n，则会误判为消息的边界。 使用更加复杂的应用层协议。 TCP 流量控制概念流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。 方法利用可变窗口进行流量控制 TCP 拥塞控制概念拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。 方法 慢开始( slow-start ) 拥塞避免( congestion avoidance ) 快重传( fast retransmit ) 快恢复( fast recovery ) TCP的拥塞控制图 TCP 传输连接管理 因为 TCP 三次握手建立连接、四次挥手释放连接很重要，所以附上《计算机网络（第 7 版）-谢希仁》书中对此章的详细描述：https://raw.githubusercontent.com/huihut/interview/master/images/TCP-transport-connection-management.png TCP 三次握手建立连接 【TCP 建立连接全过程解释】 客户端发送 SYN 给服务器，说明客户端请求建立连接； 服务端收到客户端发的 SYN，并回复 SYN+ACK 给客户端（同意建立连接）； 客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）； 服务端收到客户端的 ACK，连接已建立，可以数据传输。 TCP 为什么要进行三次握手？【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。） Google Groups . TCP 建立连接为什么是三次握手？{技术}{网络通信} 【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。 知乎 . TCP 为什么是三次握手，而不是两次或四次？ 【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 《计算机网络（第 7 版）-谢希仁》 TCP 四次挥手释放连接 【TCP 释放连接全过程解释】 客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）； 服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）； 客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）； 服务端继续发送之前没发完的数据给客户端； 服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）； 客户端收到服务端的 FIN+ACK，并回复 ACK 给客户端（同意释放从服务端到客户端的连接）； 服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。 TCP 为什么要进行四次挥手？【问题一】TCP 为什么要进行四次挥手？ / 为什么 TCP 建立连接需要三次，而释放连接则需要四次？ 【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。 【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手） 【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。 【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？ 【答案三】 为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。 防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。 TCP 有限状态机TCP 有限状态机图片 应用层DNS DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。 域名： 域名 ::= {&lt;三级域名&gt;.&lt;二级域名&gt;.&lt;顶级域名&gt;}，如：blog.huihut.com FTP FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。 TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定 TELNET TELNET 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。 HTTP（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW（World Wide Web，万维网）服务器传输超文本到本地浏览器的传送协议。 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。 Socket 建立网络通信连接至少要一对端口号（Socket）。Socket 本质是编程接口（API），对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。 WWW WWW（World Wide Web，环球信息网，万维网）是一个由许多互相链接的超文本组成的系统，通过互联网访问 URL URL（Uniform Resource Locator，统一资源定位符）是因特网上标准的资源的地址（Address） 标准格式： 协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID] 完整格式： 协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID] 其中【访问凭证信息@；:端口号；?查询；#片段ID】都属于选填项如：https://github.com/huihut/interview#cc HTTPHTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。 请求方法 方法 意义 OPTIONS 请求一些选项信息，允许客户端查看服务器的性能 GET 请求指定的页面信息，并返回实体主体 HEAD 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改 PUT 从客户端向服务器传送的数据取代指定的文档的内容 DELETE 请求服务器删除指定的页面 TRACE 回显服务器收到的请求，主要用于测试或诊断 状态码（Status-Code） 1xx：表示通知信息，如请求收到了或正在进行处理 100 Continue：继续，客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议 2xx：表示成功，如接收或知道了 200 OK: 请求成功 3xx：表示重定向，如要完成请求还必须采取进一步的行动 301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替 4xx：表示客户的差错，如请求中有错误的语法或不能完成 400 Bad Request: 客户端请求的语法错误，服务器无法理解 401 Unauthorized: 请求要求用户的身份认证 403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够） 404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面 408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时 5xx：表示服务器的差错，如服务器失效无法完成请求 500 Internal Server Error: 服务器内部错误，无法完成请求 503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中 504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求 更多状态码：菜鸟教程 . HTTP状态码 其他协议 SMTP（Simple Main Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器。SMTP 使用 TCP 端口 25。 DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途： 用于内部网络或网络服务供应商自动分配 IP 地址给用户 用于内部网络管理员作为对所有电脑作中央管理的手段 SNMP（Simple Network Management Protocol，简单网络管理协议）构成了互联网工程工作小组（IETF，Internet Engineering Task Force）定义的 Internet 协议族的一部分。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。 🌩 网络编程Socket Linux Socket 编程（不限 Linux） Socket 中的 read()、write() 函数12ssize_t read(int fd, void *buf, size_t count);ssize_t write(int fd, const void *buf, size_t count); read() read 函数是负责从 fd 中读取内容。 当读成功时，read 返回实际所读的字节数。 如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。 如果错误为 EINTR 说明读是由中断引起的；如果是 ECONNREST 表示网络连接出了问题。 write() write 函数将 buf 中的 nbytes 字节内容写入文件描述符 fd。 成功时返回写的字节数。失败时返回 -1，并设置 errno 变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。 （1）write 的返回值大于 0，表示写了部分或者是全部的数据。 （2）返回的值小于 0，此时出现了错误。 如果错误为 EINTR 表示在写的时候出现了中断错误；如果为 EPIPE 表示网络连接出现了问题（对方已经关闭了连接）。 Socket 中 TCP 的三次握手建立连接我们知道 TCP 建立连接要进行 “三次握手”，即交换三个分组。大致流程如下： 客户端向服务器发送一个 SYN J 服务器向客户端响应一个 SYN K，并对 SYN J 进行确认 ACK J+1 客户端再想服务器发一个确认 ACK K+1 只有就完了三次握手，但是这个三次握手发生在 Socket 的那几个函数中呢？请看下图： 从图中可以看出： 当客户端调用 connect 时，触发了连接请求，向服务器发送了 SYN J 包，这时 connect 进入阻塞状态； 服务器监听到连接请求，即收到 SYN J 包，调用 accept 函数接收请求向客户端发送 SYN K ，ACK J+1，这时 accept 进入阻塞状态； 客户端收到服务器的 SYN K ，ACK J+1 之后，这时 connect 返回，并对 SYN K 进行确认； 服务器收到 ACK K+1 时，accept 返回，至此三次握手完毕，连接建立。 Socket 中 TCP 的四次握手释放连接上面介绍了 socket 中 TCP 的三次握手建立过程，及其涉及的 socket 函数。现在我们介绍 socket 中的四次握手释放连接的过程，请看下图： 图示过程如下： 某个应用进程首先调用 close 主动关闭连接，这时 TCP 发送一个 FIN M； 另一端接收到 FIN M 之后，执行被动关闭，对这个 FIN 进行确认。它的接收也作为文件结束符传递给应用进程，因为 FIN 的接收意味着应用进程在相应的连接上再也接收不到额外数据； 一段时间之后，接收到文件结束符的应用进程调用 close 关闭它的 socket。这导致它的 TCP 也发送一个 FIN N； 接收到这个 FIN 的源发送端 TCP 对它进行确认。 这样每个方向上都有一个 FIN 和 ACK。 💾 数据库 本节部分知识点来自《数据库系统概论（第 5 版）》 基本概念 数据（data）：描述事物的符号记录称为数据。 数据库（DataBase，DB）：是长期存储在计算机内、有组织的、可共享的大量数据的集合，具有永久存储、有组织、可共享三个基本特点。 数据库管理系统（DataBase Management System，DBMS）：是位于用户与操作系统之间的一层数据管理软件。 数据库系统（DataBase System，DBS）：是有数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator DBA）组成的存储、管理、处理和维护数据的系统。 实体（entity）：客观存在并可相互区别的事物称为实体。 属性（attribute）：实体所具有的某一特性称为属性。 码（key）：唯一标识实体的属性集称为码。 实体型（entity type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。 实体集（entity set）：同一实体型的集合称为实体集。 联系（relationship）：实体之间的联系通常是指不同实体集之间的联系。 模式（schema）：模式也称逻辑模式，是数据库全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。 外模式（external schema）：外模式也称子模式（subschema）或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。 内模式（internal schema）：内模式也称为存储模式（storage schema），一个数据库只有一个内模式。他是数据物理结构和存储方式的描述，是数据库在数据库内部的组织方式。 常用数据模型 层次模型（hierarchical model） 网状模型（network model） 关系模型（relational model） 关系（relation）：一个关系对应通常说的一张表 元组（tuple）：表中的一行即为一个元组 属性（attribute）：表中的一列即为一个属性 码（key）：表中可以唯一确定一个元组的某个属性组 域（domain）：一组具有相同数据类型的值的集合 分量：元组中的一个属性值 关系模式：对关系的描述，一般表示为 关系名(属性1, 属性2, ..., 属性n) 面向对象数据模型（object oriented data model） 对象关系数据模型（object relational data model） 半结构化数据模型（semistructure data model） 常用 SQL 操作 对象类型 对象 操作类型 数据库模式 模式 CREATE SCHEMA 基本表 CREATE SCHEMA，ALTER TABLE 视图 CREATE VIEW 索引 CREATE INDEX 数据 基本表和视图 SELECT，INSERT，UPDATE，DELETE，REFERENCES，ALL PRIVILEGES 属性列 SELECT，INSERT，UPDATE，REFERENCES，ALL PRIVILEGES SQL 语法教程：runoob . SQL 教程 关系型数据库 基本关系操作：查询（选择、投影、连接（等值连接、自然连接、外连接（左外连接、右外连接））、除、并、差、交、笛卡尔积等）、插入、删除、修改 关系模型中的三类完整性约束：实体完整性、参照完整性、用户定义的完整性 索引 数据库索引：顺序索引、B+ 树索引、hash 索引 MySQL 索引背后的数据结构及算法原理 数据库完整性 数据库的完整性是指数据的正确性和相容性。 完整性：为了防止数据库中存在不符合语义（不正确）的数据。 安全性：为了保护数据库防止恶意破坏和非法存取。 触发器：是用户定义在关系表中的一类由事件驱动的特殊过程。 关系数据理论 数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相关联系。 最重要的数据依赖：函数依赖、多值依赖。 范式 第一范式（1NF）：属性（字段）是最小单位不可再分。 第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖）。 第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 非主属性对码的传递函数依赖）。 鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖）。 第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）。 数据库恢复 事务：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。 事物的 ACID 特性：原子性、一致性、隔离性、持续性。 恢复的实现技术：建立冗余数据 -&gt; 利用冗余数据实施数据库恢复。 建立冗余数据常用技术：数据转储（动态海量转储、动态增量转储、静态海量转储、静态增量转储）、登记日志文件。 并发控制 事务是并发控制的基本单位。 并发操作带来的数据不一致性包括：丢失修改、不可重复读、读 “脏” 数据。 并发控制主要技术：封锁、时间戳、乐观控制法、多版本并发控制等。 基本封锁类型：排他锁（X 锁 / 写锁）、共享锁（S 锁 / 读锁）。 活锁死锁： 活锁：事务永远处于等待状态，可通过先来先服务的策略避免。 死锁：事物永远不能结束 预防：一次封锁法、顺序封锁法； 诊断：超时法、等待图法； 解除：撤销处理死锁代价最小的事务，并释放此事务的所有的锁，使其他事务得以继续运行下去。 可串行化调度：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。可串行性时并发事务正确调度的准则。 📏 设计模式 各大设计模式例子参考：CSDN专栏 . C++ 设计模式 系列博文 设计模式工程目录 单例模式单例模式例子 抽象工厂模式抽象工厂模式例子 适配器模式适配器模式例子 桥接模式桥接模式例子 观察者模式观察者模式例子 设计模式的六大原则 单一职责原则（SRP，Single Responsibility Principle） 里氏替换原则（LSP，Liskov Substitution Principle） 依赖倒置原则（DIP，Dependence Inversion Principle） 接口隔离原则（ISP，Interface Segregation Principle） 迪米特法则（LoD，Law of Demeter） 开放封闭原则（OCP，Open Close Principle） ⚙️ 链接装载库 本节部分知识点来自《程序员的自我修养——链接装载库》 内存、栈、堆一般应用程序内存空间有如下区域： 栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文 堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域 可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里 保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据 栈栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面： 函数的返回地址和参数 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量 保存上下文：包括函数调用前后需要保持不变的寄存器 堆堆分配算法： 空闲链表（Free List） 位图（Bitmap） 对象池 “段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。 普遍原因： 将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针 没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针 编译链接各平台文件格式 平台 可执行文件 目标文件 动态库/共享对象 静态库 Windows exe obj dll lib Unix/Linux ELF、out o so a Mac Mach-O o dylib、tbd、framework a、framework 编译链接过程 预编译（预编译器处理如 #include、#define 等预编译指令，生成 .i 或 .ii 文件） 编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 .s 文件） 汇编（汇编器把汇编码翻译成机器码，生成 .o 文件） 链接（连接器进行地址和空间分配、符号决议、重定位，生成 .out 文件） 现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin 目标文件编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。 可执行文件（Windows 的 .exe 和 Linux 的 ELF）、动态链接库（Windows 的 .dll 和 Linux 的 .so）、静态链接库（Windows 的 .lib 和 Linux 的 .a）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF） 目标文件格式 Windows 的 PE（Portable Executable），或称为 PE-COFF，.obj 格式 Linux 的 ELF（Executable Linkable Format），.o 格式 Intel/Microsoft 的 OMF（Object Module Format） Unix 的 a.out 格式 MS-DOS 的 .COM 格式 PE 和 ELF 都是 COFF（Common File Format）的变种 目标文件存储结构 段 功能 File Header 文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等） .text section 代码段，执行语句编译成的机器代码 .data section 数据段，已初始化的全局变量和局部静态变量 .bss section BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间） .rodata section 只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量 .comment section 注释信息段，存放编译器版本信息 .note.GNU-stack section 堆栈提示段 其他段略 链接的接口————符号在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。 如下符号表（Symbol Table）： Symbol（符号名） Symbol Value （地址） main 0x100 Add 0x123 … … Linux 的共享库（Shared Library）Linux 下的共享库就是普通的 ELF 共享对象。 共享库版本更新应该保证二进制接口 ABI（Application Binary Interface）的兼容 命名libname.so.x.y.z x：主版本号，不同主版本号的库之间不兼容，需要重新编译 y：次版本号，高版本号向后兼容低版本号 z：发布版本号，不对接口进行更改，完全兼容 路径大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。 /lib：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等 /usr/lib：存放非系统运行时所需要的关键性的库，主要是开发库 /usr/local/lib：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库 动态链接器会在 /lib、/usr/lib 和由 /etc/ld.so.conf 配置文件指定的，目录中查找共享库 环境变量 LD_LIBRARY_PATH：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序 LD_PRELOAD：指定预先装载的一些共享库甚至是目标文件 LD_DEBUG：打开动态链接器的调试功能 so 共享库的编写使用 CLion 编写共享库 创建一个名为 MySharedLib 的共享库 CMakeLists.txt 123456cmake_minimum_required(VERSION 3.10)project(MySharedLib)set(CMAKE_CXX_STANDARD 11)add_library(MySharedLib SHARED library.cpp library.h) library.h 12345678910111213141516171819#ifndef MYSHAREDLIB_LIBRARY_H#define MYSHAREDLIB_LIBRARY_H// 打印 Hello World!void hello();// 使用可变模版参数求和template &lt;typename T&gt;T sum(T t)&#123; return t;&#125;template &lt;typename T, typename ...Types&gt;T sum(T first, Types ... rest)&#123; return first + sum&lt;T&gt;(rest...);&#125;#endif library.cpp 123456#include &lt;iostream&gt;#include \"library.h\"void hello() &#123; std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl;&#125; so 共享库的使用（被可执行项目调用）使用 CLion 调用共享库 创建一个名为 TestSharedLib 的可执行项目 CMakeLists.txt 12345678910111213141516171819cmake_minimum_required(VERSION 3.10)project(TestSharedLib)# C++11 编译set(CMAKE_CXX_STANDARD 11)# 头文件路径set(INC_DIR /home/xx/code/clion/MySharedLib)# 库文件路径set(LIB_DIR /home/xx/code/clion/MySharedLib/cmake-build-debug)include_directories($&#123;INC_DIR&#125;)link_directories($&#123;LIB_DIR&#125;)link_libraries(MySharedLib)add_executable(TestSharedLib main.cpp)# 链接 MySharedLib 库target_link_libraries(TestSharedLib MySharedLib) main.cpp 12345678910111213#include &lt;iostream&gt;#include \"library.h\"using std::cout;using std::endl;int main() &#123; hello(); cout &lt;&lt; \"1 + 2 = \" &lt;&lt; sum(1,2) &lt;&lt; endl; cout &lt;&lt; \"1 + 2 + 3 = \" &lt;&lt; sum(1,2,3) &lt;&lt; endl; return 0;&#125; 执行结果 123Hello, World!1 + 2 = 31 + 2 + 3 = 6 Windows 应用程序入口函数 GUI（Graphical User Interface）应用，链接器选项：/SUBSYSTEM:WINDOWS CUI（Console User Interface）应用，链接器选项：/SUBSYSTEM:CONSOLE _tWinMain 与 _tmain 函数声明 12345678910Int WINAPI _tWinMain( HINSTANCE hInstanceExe, HINSTANCE, PTSTR pszCmdLine, int nCmdShow);int _tmain( int argc, TCHAR *argv[], TCHAR *envp[]); 应用程序类型 入口点函数 嵌入可执行文件的启动函数 处理ANSI字符（串）的GUI应用程序 _tWinMain(WinMain) WinMainCRTSartup 处理Unicode字符（串）的GUI应用程序 _tWinMain(wWinMain) wWinMainCRTSartup 处理ANSI字符（串）的CUI应用程序 _tmain(Main) mainCRTSartup 处理Unicode字符（串）的CUI应用程序 _tmain(wMain) wmainCRTSartup 动态链接库（Dynamic-Link Library） DllMain _DllMainCRTStartup Windows 的动态链接库（Dynamic-Link Library） 部分知识点来自《Windows 核心编程（第五版）》 用处 扩展了应用程序的特性 简化了项目管理 有助于节省内存 促进了资源的共享 促进了本地化 有助于解决平台间的差异 可以用于特殊目的 注意 创建 DLL，事实上是在创建可供一个可执行模块调用的函数 当一个模块提供一个内存分配函数（malloc、new）的时候，它必须同时提供另一个内存释放函数（free、delete） 在使用 C 和 C++ 混编的时候，要使用 extern “C” 修饰符 一个 DLL 可以导出函数、变量（避免导出）、C++ 类（导出导入需要同编译器，否则避免导出） DLL 模块：cpp 文件中的 __declspec(dllexport) 写在 include 头文件之前 调用 DLL 的可执行模块：cpp 文件的 __declspec(dllimport) 之前不应该定义 MYLIBAPI 加载 Windows 程序的搜索顺序 包含可执行文件的目录 Windows 的系统目录，可以通过 GetSystemDirectory 得到 16 位的系统目录，即 Windows 目录中的 System 子目录 Windows 目录，可以通过 GetWindowsDirectory 得到 进程的当前目录 PATH 环境变量中所列出的目录 DLL 入口函数DllMain 函数 1234567891011121314151617181920212223BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123; switch(fdwReason) &#123; case DLL_PROCESS_ATTACH: // 第一次将一个DLL映射到进程地址空间时调用 // The DLL is being mapped into the process' address space. break; case DLL_THREAD_ATTACH: // 当进程创建一个线程的时候，用于告诉DLL执行与线程相关的初始化（非主线程执行） // A thread is bing created. break; case DLL_THREAD_DETACH: // 系统调用 ExitThread 线程退出前，即将终止的线程通过告诉DLL执行与线程相关的清理 // A thread is exiting cleanly. break; case DLL_PROCESS_DETACH: // 将一个DLL从进程的地址空间时调用 // The DLL is being unmapped from the process' address space. break; &#125; return (TRUE); // Used only for DLL_PROCESS_ATTACH&#125; 载入卸载库LoadLibrary、LoadLibraryExA、LoadPackagedLibrary、FreeLibrary、FreeLibraryAndExitThread 函数声明 123456789101112131415161718192021222324// 载入库HMODULE WINAPI LoadLibrary( _In_ LPCTSTR lpFileName);HMODULE LoadLibraryExA( LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);// 若要在通用 Windows 平台（UWP）应用中加载 Win32 DLL，需要调用 LoadPackagedLibrary，而不是 LoadLibrary 或 LoadLibraryExHMODULE LoadPackagedLibrary( LPCWSTR lpwLibFileName, DWORD Reserved);// 卸载库BOOL WINAPI FreeLibrary( _In_ HMODULE hModule);// 卸载库和退出线程VOID WINAPI FreeLibraryAndExitThread( _In_ HMODULE hModule, _In_ DWORD dwExitCode); 显示地链接到导出符号GetProcAddress 函数声明 1234FARPROC GetProcAddress( HMODULE hInstDll, PCSTR pszSymbolName // 只能接受 ANSI 字符串，不能是 Unicode); DumpBin.exe 查看 DLL 信息在 VS 的开发人员命令提示符 使用 DumpBin.exe 可查看 DLL 库的导出段（导出的变量、函数、类名的符号）、相对虚拟地址（RVA，relative virtual address）。如： 1DUMPBIN -exports D:\\mydll.dll LoadLibrary 与 FreeLibrary 流程图LoadLibrary 与 FreeLibrary 流程图 LoadLibrary FreeLibrary DLL 库的编写（导出一个 DLL 模块）DLL 库的编写（导出一个 DLL 模块）DLL 头文件 123456789101112131415161718192021// MyLib.h#ifdef MYLIBAPI// MYLIBAPI 应该在全部 DLL 源文件的 include \"Mylib.h\" 之前被定义// 全部函数/变量正在被导出#else// 这个头文件被一个exe源代码模块包含，意味着全部函数/变量被导入#define MYLIBAPI extern \"C\" __declspec(dllimport)#endif// 这里定义任何的数据结构和符号// 定义导出的变量（避免导出变量）MYLIBAPI int g_nResult;// 定义导出函数原型MYLIBAPI int Add(int nLeft, int nRight); DLL 源文件 12345678910111213141516171819// MyLibFile1.cpp// 包含标准Windows和C运行时头文件#include &lt;windows.h&gt;// DLL源码文件导出的函数和变量#define MYLIBAPI extern \"C\" __declspec(dllexport)// 包含导出的数据结构、符号、函数、变量#include \"MyLib.h\"// 将此DLL源代码文件的代码放在此处int g_nResult;int Add(int nLeft, int nRight)&#123; g_nResult = nLeft + nRight; return g_nResult;&#125; DLL 库的使用（运行时动态链接 DLL）DLL 库的使用（运行时动态链接 DLL） 123456789101112131415161718192021222324252627282930313233343536373839404142// A simple program that uses LoadLibrary and // GetProcAddress to access myPuts from Myputs.dll. #include &lt;windows.h&gt; #include &lt;stdio.h&gt; typedef int (__cdecl *MYPROC)(LPWSTR); int main( void ) &#123; HINSTANCE hinstLib; MYPROC ProcAdd; BOOL fFreeResult, fRunTimeLinkSuccess = FALSE; // Get a handle to the DLL module. hinstLib = LoadLibrary(TEXT(\"MyPuts.dll\")); // If the handle is valid, try to get the function address. if (hinstLib != NULL) &#123; ProcAdd = (MYPROC) GetProcAddress(hinstLib, \"myPuts\"); // If the function address is valid, call the function. if (NULL != ProcAdd) &#123; fRunTimeLinkSuccess = TRUE; (ProcAdd) (L\"Message sent to the DLL function\\n\"); &#125; // Free the DLL module. fFreeResult = FreeLibrary(hinstLib); &#125; // If unable to call the DLL function, use an alternative. if (! fRunTimeLinkSuccess) printf(\"Message printed from executable\\n\"); return 0;&#125; 运行库（Runtime Library）典型程序运行步骤 操作系统创建进程，把控制权交给程序的入口（往往是运行库中的某个入口函数） 入口函数对运行库和程序运行环境进行初始化（包括堆、I/O、线程、全局变量构造等等）。 入口函数初始化后，调用 main 函数，正式开始执行程序主体部分。 main 函数执行完毕后，返回到入口函数进行清理工作（包括全局变量析构、堆销毁、关闭I/O等），然后进行系统调用结束进程。 一个程序的 I/O 指代程序与外界的交互，包括文件、管程、网络、命令行、信号等。更广义地讲，I/O 指代操作系统理解为 “文件” 的事物。 glibc 入口_start -&gt; __libc_start_main -&gt; exit -&gt; _exit 其中 main(argc, argv, __environ) 函数在 __libc_start_main 里执行。 MSVC CRT 入口int mainCRTStartup(void) 执行如下操作： 初始化和 OS 版本有关的全局变量。 初始化堆。 初始化 I/O。 获取命令行参数和环境变量。 初始化 C 库的一些数据。 调用 main 并记录返回值。 检查错误并将 main 的返回值返回。 C 语言运行库（CRT）大致包含如下功能： 启动与退出：包括入口函数及入口函数所依赖的其他函数等。 标准函数：有 C 语言标准规定的C语言标准库所拥有的函数实现。 I/O：I/O 功能的封装和实现。 堆：堆的封装和实现。 语言实现：语言中一些特殊功能的实现。 调试：实现调试功能的代码。 C语言标准库（ANSI C）包含： 标准输入输出（stdio.h） 文件操作（stdio.h） 字符操作（ctype.h） 字符串操作（string.h） 数学函数（math.h） 资源管理（stdlib.h） 格式转换（stdlib.h） 时间/日期（time.h） 断言（assert.h） 各种类型上的常数（limits.h &amp; float.h） 变长参数（stdarg.h） 非局部跳转（setjmp.h） 📚 书籍 huihut/CS-Books：📚 Computer Science Books 计算机技术类书籍 PDF 语言 《C++ Primer》 《Effective C++》 《More Effective C++》 《深度探索 C++ 对象模型》 《深入理解 C++11》 《STL 源码剖析》 算法 《剑指 Offer》 《编程珠玑》 《程序员面试宝典》 系统 《深入理解计算机系统》 《Windows 核心编程》 《Unix 环境高级编程》 网络 《Unix 网络编程》 《TCP/IP 详解》 其他 《程序员的自我修养》 🔱 C/C++ 发展方向 C/C++ 发展方向甚广，包括不限于以下方向， 以下列举一些大厂校招岗位要求。 后台/服务器【后台开发】 编程基本功扎实，掌握 C/C++/JAVA 等开发语言、常用算法和数据结构； 熟悉 TCP/UDP 网络协议及相关编程、进程间通讯编程； 了解 Python、Shell、Perl 等脚本语言； 了解 MYSQL 及 SQL 语言、编程，了解 NoSQL, key-value 存储原理； 全面、扎实的软件知识结构，掌握操作系统、软件工程、设计模式、数据结构、数据库系统、网络安全等专业知识； 了解分布式系统设计与开发、负载均衡技术，系统容灾设计，高可用系统等知识。 桌面客户端【PC 客户端开发】 计算机软件相关专业本科或以上学历，热爱编程，基础扎实，理解算法和数据结构相关知识； 熟悉 windows 操作系统的内存管理、文件系统、进程线程调度； 熟悉 MFC/windows 界面实现机制，熟练使用 VC，精通 C/C++，熟练使用 STL，以及 Windows 下网络编程经验； 熟练掌握 Windows 客户端开发、调试，有 Windows 应用软件开发经验优先； 对于创新及解决具有挑战性的问题充满激情，具有良好的算法基础及系统分析能力。 图形学/游戏/VR/AR【游戏客户端开发】 计算机科学/工程相关专业本科或以上学历，热爱编程，基础扎实，理解算法、数据结构、软件设计相关知识； 至少掌握一种游戏开发常用的编程语言，具 C++/C# 编程经验优先； 具游戏引擎（如 Unity、Unreal）使用经验者优先； 了解某方面的游戏客户端技术（如图形、音频、动画、物理、人工智能、网络同步）者优先考虑； 对于创新及解决具有挑战性的问题充满激情，有较强的学习能力、分析及解决问题能力，具备良好的团队合作意识； 具阅读英文技术文档能力； 热爱游戏。 测试开发【测试开发】 计算机或相关专业本科及以上学历； 一至两年的 C/C++/Python 或其他计算机语言的编程经验； 具备撰写测试计划、测试用例、以及实现性能和安全等测试的能力； 具备实现自动化系统的能力； 具备定位调查产品缺陷能力、以及代码级别调试缺陷的能力； 工作主动积极，有责任心，具有良好的团队合作精神。 网络安全/逆向【安全技术】 热爱互联网，对操作系统和网络安全有狂热的追求，专业不限； 熟悉漏洞挖掘、网络安全攻防技术，了解常见黑客攻击手法； 掌握基本开发能力，熟练使用 C/C++ 语言； 对数据库、操作系统、网络原理有较好掌握； 具有软件逆向，网络安全攻防或安全系统开发经验者优先。 嵌入式/物联网【嵌入式应用开发】 有良好的编程基础，熟练掌握 C/C++ 语言； 掌握操作系统、数据结构等软件开发必备知识； 具备较强的沟通理解能力及良好的团队合作意识； 有 Linux/Android 系统平台的开发经验者优先。 音视频/流媒体/SDK【音视频编解码】 硕士及以上学历，计算机、信号处理、数学、信息类及相关专业和方向； 视频编解码基础扎实，熟常用的 HEVC 或 H264，有较好的数字信号处理基础； 掌握 C/C++，代码能力强, 熟悉一种汇编语言尤佳； 较强的英文文献阅读能力； 学习能力强，具有团队协作精神，有较强的抗压能力。 计算机视觉/机器学习【计算机视觉研究】 计算机、应用数学、模式识别、人工智能、自控、统计学、运筹学、生物信息、物理学/量子计算、神经科学、社会学/心理学等专业，图像处理、模式识别、机器学习相关研究方向，本科及以上，博士优先； 熟练掌握计算机视觉和图像处理相关的基本算法及应用； 较强的算法实现能力，熟练掌握 C/C++ 编程，熟悉 Shell/Python/Matlab 至少一种编程语言； 在计算机视觉、模式识别等学术会议或者期刊上发表论文、相关国际比赛获奖、及有相关专利者优先。 💯 复习刷题网站 cplusplus cppreference runoob leetcode | leetcode-cn lintcode nowcoder 📝 面试题目经验 牛客网 . 2020秋招面经大汇总！（岗位划分） 牛客网 . 【备战秋招】2020届秋招备战攻略 牛客网 . 2019校招面经大汇总！【每日更新中】 牛客网 . 2019校招技术类岗位面经汇总【技术类】 牛客网 . 2018校招笔试真题汇总 牛客网 . 2017秋季校园招聘笔经面经专题汇总 牛客网 . 史上最全2017春招面经大合集！！ 牛客网 . 面试题干货在此 知乎 . 互联网求职路上，你见过哪些写得很好、很用心的面经？最好能分享自己的面经、心路历程。 知乎 . 互联网公司最常见的面试算法题有哪些？ CSDN . 全面整理的C++面试题 CSDN . 百度研发类面试题（C++方向） CSDN . c++常见面试题30道 CSDN . 腾讯2016实习生面试经验（已经拿到offer) cnblogs . C++面试集锦( 面试被问到的问题 ) cnblogs . C/C++ 笔试、面试题目大汇总 cnblogs . 常见C++面试题及基本知识点总结（一） segmentfault . C++常见面试问题总结 📆 招聘时间岗位 牛客网 . 2020届校招 | 2020 IT名企校招日程 👍 内推 Github . CyC2018/Job-Recommend：🔎 互联网内推信息（社招、校招、实习） Github . amusi/AI-Job-Recommend：国内公司人工智能方向（含机器学习、深度学习、计算机视觉和自然语言处理）岗位的招聘信息（含全职、实习和校招） 👬 贡献者包括勘误的 Issue、PR，排序按照贡献时间。 tamarous、i0Ek3、sniper00、blackhorse001、houbaron、Qouan、2329408386、FlyingfishMORE、Ematrix163、ReturnZero23、kelvinkuo、henryace、xinghun、maokelong、easyYao、FengZiYjun、shangjiaxuan、kwongtailau、asky991、traviszeng、kele1997、hxdnshx、a74731248、qvjp、xindelvcheng、hbsun2113、linkwk7、foolishflyfox、zhjp0、Mrtj2016 🍭 支持赞助打赏我一包辣条~ 📜 License本仓库遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","categories":[],"tags":[]},{"title":"SPI","slug":"SPI","date":"2020-03-14T05:50:25.000Z","updated":"2020-03-14T05:50:42.909Z","comments":true,"path":"2020/03/14/SPI/","link":"","permalink":"http://yoursite.com/2020/03/14/SPI/","excerpt":"","text":"","categories":[{"name":"总线协议","slug":"总线协议","permalink":"http://yoursite.com/categories/%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"SPI","slug":"SPI","permalink":"http://yoursite.com/tags/SPI/"}]},{"title":"Lx Y","slug":"Lx Y","date":"2020-03-05T07:15:16.000Z","updated":"2020-03-05T14:13:03.909Z","comments":true,"path":"2020/03/05/Lx Y/","link":"","permalink":"http://yoursite.com/2020/03/05/Lx%20Y/","excerpt":"","text":"关于工作教师事业编： 滨江区教师招聘(中学，小学，幼儿园，有编制): 根据2020年杭州市滨江教育局所属事业单位面向毕业生和在职教师直接考核招聘教师公告，对于应届生的招聘要求如下：12345678910111213141516(一)全日制2020届毕业生 1.具有本科及以上学历、学士及以上学位，并且获得过国家奖学金、省级师范生技能大赛一等奖等奖项或省级及以上优秀毕业生、优秀学生(党员)、优秀学生(党、团)干部等荣誉称号的毕业生。 2.具有研究生学历、博士学位的毕业生。 3.具有研究生学历、硕士学位，符合下列五类条件之一： (1)国家“一流大学”建设高校毕业生。 (2)国家“一流学科”建设高校和浙江省重点建设师范类高校毕业生，并且本科毕业于国家“双一流”建设高校或浙江省重点建设高校。 (3)国家“一流学科”建设高校和浙江省重点建设师范类高校毕业生，并且大学期间获得过校级优秀毕业生、优秀学生(党员)、优秀学生(党、团)干部等荣誉称号，或综合(专业)成绩排名前50%。 (4)普通高校毕业生，并且大学期间获得过校级优秀毕业生、优秀学生(党员)、优秀学生(党、团)干部等荣誉称号，或综合(专业)成绩排名前20%。 (5)普通高校学前教育方向毕业生。 4.具有本科学历、学士学位，符合下列三类条件之一： (1)国家“一流大学”建设高校毕业生，并且获得校级优秀毕业生、优秀学生(党员)、优秀学生(党、团)干部等荣誉称号，或综合(专业)成绩排名前50%。 (2)国家“一流学科”建设高校和浙江省重点建设师范类高校毕业生，并且获得校级优秀毕业生、优秀学生(党员)、优秀学生(党、团)干部等荣誉称号，或综合(专业)成绩排名前20%。 (3)普通师范类高校或浙江省内高校毕业生，获得校级优秀毕业生、优秀学生(党员)、优秀学生(党、团)干部等荣誉称号，且综合(专业)成绩排名前10%。 5.教育部直属师范大学免(公)费师范生。 注：上述条件并没有包括海外研究生的要求，但是根据公示的录取名单里面是有海外研究生被录取。 报名时间：2019年5月10日至11日（上午8:30—11:00，下午13:00—16:00） 报名时间：2019年7月23日至8月5日（上午9：00-11：00，下午13：30-16：00，双休日除外） 报名时间：2019年12月17日至12月30日(上午9：00-11：00，下午13：30-16：00，双休日除外) 根据公告公示,总录取人数为20人(包括海外研究生),因为分三次招聘此次是12月份招聘的人数，一年总的招聘人数为67人。 统计过后报录比基本上1:5 萧山区教师招聘(中学，小学，幼儿园，有编制): 根据杭州市萧山区面向2020届研究生和优秀本科生招聘公告，对于应届生的招聘如下：12345678910111213一）对象：面向2020届全日制普通高校毕业生。“985”、“211”院校毕业生户籍不限，省级重点师范院校毕业生户籍或生源地（即参加高考时的户籍地）为浙江省。 下列第1至4种对象可同时报考一、二类岗位，第5种对象只能报考二类岗位。1. 具有研究生学历、硕士及以上学位的“985”、“211”院校毕业生；2. 具有研究生学历、硕士及以上学位的省级重点师范院校毕业生；3. 具有本科学历、学士学位的“985”、“211”院校毕业生；4. 具有本科学历、学士学位的省级重点师范院校重点批（即高考录取为一本）毕业生，并具备下列条件之一：校级及以上优秀毕业生或优秀学生（团）干部，综合（专业）成绩排名前20%，校级二等及以上奖学金，浙江师范大学初阳学院毕业生。5. 具有本科学历、学士学位的省级重点师范院校重点批（即高考录取为一本）毕业生，并具备下列条件之一：综合（专业）成绩排名前30%，校级三等及以上奖学金。2019年毕业并已获得教育部留学服务中心认证的研究生，且本科符合上述对象条件的人员也可报考。（二）身心健康：遵纪守法，热爱教育事业，有良好的社会公德和职业道德，具有适应岗位要求的身体条件。（三）年龄在28周岁以下（1992年7月1日后出生）。（四）学历、学位与专业：具体岗位要求详见《杭州市萧山区面向2020届研究生和优秀本科生招聘计划表》（附件），报考学历专业须与招聘学科相符，2020年7月底前须获得相应的学历、学位证书。注：跟滨江区的要求稍有差别，这边对于海外研究生的本科也有要求。 报名时间：11月4日9：00时至11月11日17:00。 初审地址：浙江师范大学，杭州师范大学 非事业编以及其他 滨江区高中教师招聘(一般通过各个部署师范高校以及省内师范院校校招得到，有无编制看学校)： 详情点击此链接，此链接为浙江师范大学2019秋招企业以及学校列表。 详情点击此链接，此链接为杭州师范大学2019年秋招企业以及学校列表。 其他培训机构(不建议,虽然工资很高) 民办学校 高校的辅导员(还没到招聘时间) 外企： 如brother等日企 欧美企业 公务员(三不限难度大) 家里安排一下(稳稳的幸福) 教师资格证考试 根据2019年下半年考试安排： 笔试报名时间：2019年9月3日-6日 笔试考试时间：2019年11月2日 笔试成绩查询：2019年12月10日左右 面试考试时间：2020年1月4日-5日 今年不出意外还是同样的时间 教师资格证分三门科目： 综合素质 教育知识与能力 学科知识与教学能力(你应该没有问题) 三门课可以分开考，也可以一次性通过，分开考的话之前考的课有效期2年，建议一次性考出，前两门主要都是需要记忆的东西，对你来说问题也不大。 总结建议尽快写论文，早做准备，做多手准备。以上只是我的建议。。。 End Powered by www.hhlai.xyz","categories":[],"tags":[]},{"title":"01-My bootloader","slug":"01-My bootloader","date":"2020-03-01T08:16:40.000Z","updated":"2020-03-13T08:51:48.031Z","comments":true,"path":"2020/03/01/01-My bootloader/","link":"","permalink":"http://yoursite.com/2020/03/01/01-My%20bootloader/","excerpt":"","text":"My bootloader最简单的bootloader的编写步骤 初始化硬件：关看门狗，设置时钟，设置SDRAM，初始化nand flash 如果bootloader比较大，要把它重定位到SDRAM 把内核从nand flash读到SDRAM 设置“要传给内核的参数” 跳转执行内核 创建start.S 关看门狗 123ldr r0, =0x53000000 ;伪汇编指令，0x53000000不能放到立即数中mov r1, #0;str r1, [r0] ;将r1的值存在r0的地址中 设置时钟 12345678910111213#define S3C2440_MPLL_200MHZ ((0x5c&lt;&lt;12)|(0x01&lt;&lt;4)|(0x02))ldr r0, =0x4c000014mov r1, #0x03 ;分频系数为3str r1, [r0];改变CPU的总线模式从\"fast bus mode\"到\"asynchronous\"mrc p15, 0, r1, c1, c0, 0 ;读出控制寄存器orr r1, r1, #0xc0000000 ;设置为\"asynchronous bus mode\"mcr p15, 0, r1, c1, c0, 0 ;写入控制寄存器ldr r0, =0x4c000004ldr r1, =S3c2440_NPLL_200MHZstr r1, [r0] 初始化SDRAM 12345678910111213141516171819202122#define MEN_CTL_BASE 0x48000000 ldr r0, =MEM_CTL_BASE adr r1, sdram_config ;伪汇编指令 得到当前地址 add r3, r0, #(13*4)1. ldr r2, [r1], #4 ;从r1所指地方取一个值存到r2，然后让r1+4 str r2, [r0], #4 cmp r0, r3 bne 1sdram_config: .long 0x22011110 .long 0x00000700 .long 0x00000700 .long 0x00000700 .long 0x00000700 .long 0x00000700 .long 0x00000700 .long 0x00018005 重定位：把bootloader本身的代码从flash复制到它的链接地址去 norflash： nandflash： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146ldr sp, =0x34000000 ;栈往下增长bl nand_init mov r0, #0ldr r1, =_start ;_start = 0x33f80000ldr r2, =__bss_startsub r2, r2, r1bl copy_code_to_sdram ;执行C语言函数，之前需要设置栈bl clean_bss#define NFCONF (*((volatile unsigned long *)0x4E000000))#define NFCONF (*((volatile unsigned long *)0x4E000004))#define NFCMMD (*((volatile unsigned char *)0x4E000008))#define NFADDR (*((volatile unsigned char *)0x4E00000C))#define NFDATA (*((volatile unsigned char *)0x4E000010))#define NFSTAT (*((volatile unsigned char *)0x4E000020)) //nandflash 寄存器int isBootFromNorFlash(void)&#123; volatile int *p = (volatile int *)0; int val; val = *p; *p = 0x12345678; //利用norflash不能写的特性 if(*p == 0x12345678) &#123; //写成功，是nand启动 *p = val; return 0; &#125; else &#123; return 1; &#125;&#125;void copy_code_to_sdram(unsigned char *src, unsigned char *dest, unsigned int length)&#123; int i = 0; //如果是NOR启动 if(isBootFromNorFlash()) &#123; while(i &lt; len) &#123; dest[i] = src[i]; i++; &#125; &#125; else &#123; //nand_init(); nand_read(src, dest, len); &#125;&#125;void clean_bss(void) &#123; extern int __bss_start, __bss_end; int *p = &amp;__bss_start; for(; p &lt; &amp;__bss_end; p++) *p = 0;&#125;void nand_init(void)&#123;//时间参数,见之后的时序图#define TACLS 0#define TWRPH0 1#define TWRPH1 0 //设置时序 s3c2440nand-&gt;NFCONF = (TACLS&lt;&lt;12) | (TWRPH0&lt;&lt;8) | (TWRPH1&lt;&lt;4); //使能nand flash控制器，初始化ECC，禁止片选 NFCONT = (1&lt;&lt;4) | (1&lt;&lt;1) | (1&lt;&lt;0);&#125;void nand_select(void)&#123; NFCONT &amp;= ~(1 &lt;&lt; 1);&#125;void nand_deselect(void)&#123; NFCONT |= (1 &lt;&lt; 1);&#125;void nand_cmd(unsigned char cmd)&#123; volatile int i; NFCMMD = cmd; for(i=0; i&lt;10; i++); //延时一小会&#125;void nand_addr(unsigned int addr)&#123; unsigned int col = addr % 2048; unsigned int page = add / 2048; volatile int i; NFADDR = col &amp; 0xff; for(i=0; i&lt;10; i++); NFADDR = (col &gt;&gt; 8) &amp; 0xff; for(i=0; i&lt;10; i++); NFADDR = page &amp; 0xff; for(i=0; i&lt;10; i++); NFADDR = (page &gt;&gt; 8) &amp; 0xff; for(i=0; i&lt;10; i++); NFADDR = (page &gt;&gt; 16) &amp; 0xff; for(i=0; i&lt;10; i++);&#125;void nand_wait_ready()&#123; while(!(NFSTAT &amp; 1));//如果等于0一直循环&#125;unsigned char nand_data(void)&#123; return NFDATA;&#125;void nand_read(unsigned int addr, unsigned char *buf,unsigned int len)&#123; //写：写页数据，生成ECC，ECC➡️OOB(out of bank) //读：读OOB，算出ECC，与之前的ECC比较 //将一整页读入页寄存器 int col = addr / 2048; int i = 0; //1.选中 nand_select(); while(i &lt; len) &#123; //2.发出读命令00h nand_cmd(0x00); //3.发出地址(分5步发出) nand_addr(addr); //4.发出读命令30h nand_cmd(0x30); //5.判断状态 nand_wait_ready(); //6.读数据 for(; col &lt; 2048 &amp;&amp; i &lt; len; col++) &#123; buf[i] = nand_data(); i++; addr++; &#125; col = 0; &#125; //取消选中&#125; 时序图：nandflash结构：读操作： 12345678910111213141516//u-boot的链接脚本：SECTION&#123; . = 0x33f80000; .text : &#123; *(.text) &#125; . = ALIGN(4); .rodata : (*(.rodata*)) . = ALIGN(4); .data : &#123; *(.data) &#125; . = ALIGN(4); __bss_start = .; .bss : &#123; *(.bss) *(COMMON) &#125; __bss_end = .;&#125; 执行main 12ldr lr, =haltldr pc, =main 创建main12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970setup_start_tag()&#123; params = (struct tag *) 0x30000100;//双方约定的存放参数的起始地址 params-&gt;hdr,tag = ATAG_CORE; params-&gt;hdr.size= tag_size(tag_core); params-&gt;u.core.flags = 0; params-&gt;u.core.pagesize = 0; params-&gt;u.core.rooedev = 0; params = tag_next (params);&#125;setup_memory_tags()&#123; params-&gt;hdr.tag = ATAG_MEM; params-&gt;hdr.size = tag_size(tag_mem32); params-&gt;u.mem.start = 0x30000000; params-&gt;u.mem.size = 64*1024*1024; params = tag_next(params);&#125;int strlen(char *str)&#123; int i = 0; while(str[i]) &#123; i++; &#125; return i;&#125;void strcpy(char *dest, char *src)&#123; char *tmp = dest; while((*dest++ = *src++) != '\\0')&#125;setup_commandline_tag()&#123; int len = strlen(cmdline) + 1; params-&gt;hdr.tag = ATAG_CMDLINE; params-&gt;hdr.size = (sizeof(struct tag_header) + len + 3) &gt;&gt; 2; //向4取整 strcpy(params-&gt;u.cmdline.cmdline,p); params = tag_next(params);&#125;setup_end_tag()&#123; params-&gt;hdr.tag = ATAG_NONE; params-&gt;hdr.size = 0;&#125;void main(void)&#123; void (*theKernel)(int zero, int arch, unsigned int params); //0.帮内核设置串口：内核启动时会从串口打印一些信息，但是内核一开始没有初始化串口 uart0_init(); //1.从nandflash把内核读入内存 puts(\"copy kernel\");//向串口发送调试信息 nand_read(0x60000+64, 0x30008000, 0x200000); //2m //2.设置参数 setup_start_tag(); setup_memory_tags(); setup_commandline_tag(\"noinitrd root=/dev/mtdblock3 init=/linuxrc console\"); setup_end_tag(); //3.跳转执行 theKernel = (void (*)(int,int,unsigned int))0x30008000; theKernel(0,362,0x30000100); // mov pc, #0x30008000 // ldr r1, =362 // ldr r2, =0x30000100 // mov pc, #0x30008000&#125; 提升读取内核速度 改变CPU主频 设置ICACHE","categories":[{"name":"My bootloader","slug":"My-bootloader","permalink":"http://yoursite.com/categories/My-bootloader/"}],"tags":[{"name":"bootloader","slug":"bootloader","permalink":"http://yoursite.com/tags/bootloader/"}]},{"title":"U-boot","slug":"U-boot","date":"2020-02-28T06:35:16.000Z","updated":"2020-03-05T14:14:47.637Z","comments":true,"path":"2020/02/28/U-boot/","link":"","permalink":"http://yoursite.com/2020/02/28/U-boot/","excerpt":"","text":"U-boot分析嵌入式系统的启动过程 运行bootloader — BIOS 加载linux内核 — windows 挂载根文件系统 — C盘D盘 运行应用程序 — 应用程序 事实上u-boot是一个单片机程序 U-boot编译过程 解压缩 打补丁 &emsp;patch -p &lt;补丁文件 配置 &emsp;make 100sk24x0_config 编译 &emsp;make 启动内核 从FLASH读出内核 放到SDRAM 启动内核 因此u-boot的功能必须有 读flash+写flash内核(为了开发方便) 写flash 网卡 usb 初始化SDRAM 初始化时钟 启动串口 启动内核 读出内核从flash 初始化SDRAM 初始化时钟 关看门狗 通过Makefile分析u-boot u-boot启动的第一个文件：cpu/arm920T/start.s 链接地址 board/你的板子的名字/u-boot.lds 通过设置TEXT_BASE的内容我们可以将代码段在不同的内存地址上运行 u-boot具体初始化过程 u-boot的第一阶段硬件初始化(注：硬件初始化只针对2440开发版) 将CPU模式设置为SVC32(管理模式) 1234mrs r0, cpsrbic r0, r0, #0x1forr r0, r0, #0xd3msr cpsr r0 关看门狗 1234#define pWTCON 0x15300000 ldr r0, =pWTCON mov r1, #0x0 str r1, [r0] 屏蔽中断 123456789#define INTMSK 0x4A000008#define INTSUBMSK 0x4A00001C mov r1, #0xffffffff ldr r0, =INTMSK str r1, [r0]#if defined(CONFIG_S3C2410) ldr r1, =0x3ff ldr r0, =INTSUBMSK str r1, [r0] 初始化时钟 1234#define CLKDIVN 0x4C000014 ldr r0, =CLKDIVN mov r1, #3 str r1, [r0] 初始化SDRAM 12345678910relocate: adr r0, _start ldr r1, _TEXT_BASE cmp r0, r1 beq stack_setup ldr r2, _armboot_start ldr r3, _bss_start sub r2, r3, r2 add r2, r0, r2 设置栈 123456789stack_setup: ldr r0, _TEXT_BASE sub r0, r0, #CONFIG_SYS_MALLOC_LEN sub r0, r0, #CONFIG_SYS_GBL_DATA_SIZE#ifdef CONFIG_USE_IRQ sub r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)#endif sub sp, r0, #12 vic sp, sp, #7 将flash拷到SDRAM 1234567分为从nor flash启动还是从nand flash启动从nor flash直接复制从nand flash启动要进行初始化如何判断是从nor还是nand flash启动？对于norflash 必须通过一定的命令序列才能写数据。所以可以根据这点差别来分辨是从nor还是nand启动向地址0写入一个数据，然后读出来，如果没有改变的话就是nor flash。 清空BSS段(初始值为0的静态变量或全局变量，或者未初始化的静态变量或全局变量) 1234clear_bss: ldr r0, _bss_start ldr r1, _bss_end mov r2, #0x00000000 //clear u-boot的第二阶段，启动内核(c语言实现) 从flash中读出内核 读flash flash_init()函数实现对norflash的初始化 nand_init()函数实现对nandflash的初始化 nand_read函数将kernel分区中的内容读到0x30007FC0地址中(分区由我们自己在flash中指定划分，分区名字不重要，分区名代表起始地址与分区大小)1nand read.jffs2 0x30007FC0 kernel; 启动内核 设置启动参数 跳到入口地址 s=getenv(&quot;bootcmd&quot;) run_command(s) flash上存在的内核：UImage(头部+真正的内核) UImage的头部有加载地址，当do_bootm后面跟的地址与头部的加载地址不同，将内核移到加载地址执行.因此do_bootm后面的地址不一定非要很准确，只要不破坏结构即可。do_bootm(地址);","categories":[{"name":"U-boot","slug":"U-boot","permalink":"http://yoursite.com/categories/U-boot/"}],"tags":[{"name":"bootloader","slug":"bootloader","permalink":"http://yoursite.com/tags/bootloader/"}]},{"title":"03-计算机网络","slug":"03-计算机网络","date":"2020-02-14T09:39:19.000Z","updated":"2020-02-14T09:40:41.765Z","comments":true,"path":"2020/02/14/03-计算机网络/","link":"","permalink":"http://yoursite.com/2020/02/14/03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"计算机网络TCP编程API socket()函数1234#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol) 参数： domin AF_INET AF_INET6 AF_UNIX AF_NETLINK AF_PACKET type SOCK_STREAM &emsp; 流式套接字，唯一对应于TCP SOCK_DGRAM &emsp; 数据报套接字，唯一对应着UDP SOCK_RAW:&emsp; 原始套接字 protocol 一般填0，原始套接字编程时需填充 返回值： 成功时返回文件描述符，出错时返回为-1 bind()函数 1234#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct socketaddr *addr, socklen_t addrlen); 参数 sockfd &emsp; 通过socket()函数拿到的fd addr &emsp; struct sockaddr的结构体变量的地址 如果是IPv6的编程，要使用struct sockaddr_in6结构体，通常更通用的方法可以通过struct sockarrd_storage来编程 addrlen &emsp; 地址长度 listen()函数 1234#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog); 参数 sockfd &emsp; 通过socket()函数拿到的fd backlog &emsp; 同时允许几路客户端进行正在连接的过程(正在三次握手)，一般位5，测试得知，ARM最大为8 内核中服务器的套接字fd会维护2个链表 正在三次握手的客户端链表(数量=2*backlog+1) 已经建立好连接的客户端链表(已经完成3次握手分配好了newfd) 返回值 成功时返回为0，出错时返回-1 accept()函数 阻塞等待客户端连接请求1234#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 参数 sockfd：经过前面socket()创建并通过bind()，listen()设置过的fd 返回值 成功时返回已经建立好连接的新的newfd.","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"02-计算机网络","slug":"02-计算机网络","date":"2020-02-14T09:39:14.000Z","updated":"2020-03-01T07:55:03.448Z","comments":true,"path":"2020/02/14/02-计算机网络/","link":"","permalink":"http://yoursite.com/2020/02/14/02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"计算机网络Socket 是一个编程借口：唯一应用层与传输层中间的接口 是一种特殊的文件描述符(对它执行IO的操作函数，比如read()，write()) 并不仅限于TCP/IP协议 面向连接(TCP/IP) 无连接(UDP和IPX) Socket类型 流式套接字(SOCK_STREAM)：唯一对应着TCP 提供了一个面向连接，可靠的数据传输服务，数据无差错，无重复的发送且按发送顺序接受，内设置流量控制，避免数据流淹没慢的接收方，数据被看作是字节流，无长度限制 数据报套接字(SOCK_DGRAM)：唯一对应着UDP 提供无链接服务。数据包以独立数据包的形式被发送，不提供无差错保证，数据可能丢失或重复，顺序发送，可能乱序接收。 原始套接字(SOCK_RAW)：跨过了传输层，直接到网络层 可以对较低层次协议如IP ICMP直接访问 IP地址 IP地址分为IPv4和IPv6 IPv4:采用32位的整数来表示 IPv6:采用128位的整数来表示 mobile IPv6:local IP(本地注册的IP)，roam IP(漫游IP) IPv4地址： 点分形式：192.168.2.43 特殊IP地址： 局域网IP：192.XXX.XXX.XXX 10.XXX.XXX.XXX 广播地址： XXX.XXX.XXX.255 255.255.255.255(全局广播) 组播IP：224.XXX.XXX.XXX~239.XXX.XXX.XXX 端口号 16位数字(1-65535) 众所周知端口：1～1023(FTP：21，SSH：22，HTTP：80，HTTPS：469) 保留端口：1024～5000(不建议使用) 可以使用的：5000～65535 为了区分一台主机接收到的数据包应该交给哪个任务来处理 TCP端口和UDP端口是相互独立的(都可以用1456) 网络里面的通信是由IP+端口号来决定的 字节序 字节序是指不同的CPU访问内存中的多字节数据时，存在大小端问题 如CPU访问的字符串，则不存在大小端问题 小端序(little-endian) &emsp;-低序字节存储在低字节低对低 大端序(big-endian) &emsp;-低序字节存储在高字节低对高 一般来说： X86/ARM：小端 PowerPc/MIPS，ARM作为路由器时，大端模式 ``网络传输的时候采用大端模式 本地字节序，网络字节序 把给定系统所采用的字节序称为主机字节序。 为了避免不同类别主机之间在数据交换时由于对于字节序不同而导致的差错，引入了网络字节序 主机字节序到网络字节序 u_long htonl (u_long hostlong); u_short htons (u_short short); 网络字节序到主机字节序 u_long ntohl (u_long hostlong); u_short ntohs (u_short short); IP地址转换函数 in_addr_t inet_addr(const char *cp); cp：点分形式的IP地址，结果是32位整数(内部包含了字节序的转换，默认是网络字节序的模式) 仅适用于IPv4 当出错时，返回-1 此函数不能用于255.255.255.255(全位1跟-1区分不开) inet_pton()/inet_ntop(int af, const char* src, void* dst); 适应于IPv4和IPv6 能正确的处理255.255.255.255的转换问题 参数： af：地址协议族(AF_INET或AF_INET^) src:是一个指针(填写点分形式的IP地址) dst:转换的结果给到dst","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"01-计算机网络","slug":"01-计算机网络","date":"2020-02-14T09:36:48.000Z","updated":"2020-02-14T09:39:34.714Z","comments":true,"path":"2020/02/14/01-计算机网络/","link":"","permalink":"http://yoursite.com/2020/02/14/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"计算机网络OSI七层模型 物理层 数据链路层 网络层 传输层 会话层 表示层 应用层网络采用分层的思想 每一层实现不同的功能，对上层的数据做透明传输 每一层向上层提供服务，同时使用下层提供的服务各层典型的协议 网络借口与物理层 MAC地址：48位全球唯一，网络设备的身份标识 ARP/RARP： ARP：IP地址–&gt;MAC地址 RARP：MAC地址–&gt;IP地址 PPP协议：拨号协议(GPRS/3G/4G) 网络层 IP：Internet protocol(分为IPv4和IPv6) ICMP：Internet控制管理协议，ping命令属于ICMP，端到端 IGMP：Internet分组管理协议，广播，组播 传输层 TCP(Transfer control protocol)提供面向连接的，一对一的可靠数据传输的协议即数据无误，数据无丢失，数据无失序，数据无重复到达的通信 UDP(user Datagram protocol)提供不可靠无链接的尽力传输协议是不可靠的无链接协议，在数据发送前，不需要连接，所以可以进行高效率的数据传输 SCTP：可靠传输，是TCP的增强版，它能实现多主机，多链路的通信 应用层 网页访问协议：HTTP/HTTPS 邮件发送接受协议：POP3(收)/SMTP(发)，IMAP(可接受邮件的一部分) FTP Talent/SSH：远程登陆 嵌入式相关： NTP：网络时钟协议 SNMP：简单网络管理协议 RTP/RTSP：用传输音视频的协议，用于安防监控，事实上这个协议是TCP+UDP来实现的","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"IIC协议时序分析","slug":"IIC","date":"2020-02-12T02:52:02.000Z","updated":"2020-02-12T06:28:09.343Z","comments":true,"path":"2020/02/12/IIC/","link":"","permalink":"http://yoursite.com/2020/02/12/IIC/","excerpt":"","text":"IIC协议时序分析IIC简介IIC（Inter-Integrated Circuit）其实是IICBus简称，所以中文应该叫集成电路总线，它是一种串行通信总线，使用多主从架构，由飞利浦公司在1980年代为了让主板、嵌入式系统或手机用以连接低速周边设备而发展。 IIC组成IIC串行总线一般有两根信号线，一根是双向的数据线SDA，另一根是时钟线SCL。所有接到IIC总线设备上的串行数据SDA都接到总线的SDA上，各设备的时钟线SCL接到总线的SCL上。空闲状态：SCL高电平 SDA高电平 IIC具体协议时序开始停止信号代码实现： 1234567891011121314151617181920212223242526272829303132333435363738void IIC_Start(void)&#123; I2C2_SDA_H; //拉高数据线 I2C2_SCL_H; //拉高时钟线 I2C2_delay();//现在延时为16us， 5 I2C2_SDA_L; //产生下降沿 I2C2_delay(); I2C2_SCL_L;//拉低时钟线，钳住I2C总线，准备发数据或者接受数据&#125;void IIC_Stop(void)&#123; I2C2_SCL_L; I2C2_delay(); I2C2_SDA_L; //停止，CLK上升沿 I2C2_delay(); I2C2_SCL_H; //拉高时钟线 I2C2_delay(); I2C2_SDA_H; //拉高数据线，结束信号 I2C2_delay();&#125; 数据传输 每一个字节必须保证是8位长度。数据传输时，先传送最高位(MSB)，每一个被传送的字节后面都必须跟随一位应答位，即一帧共有9位。 代码实现： 123456789101112131415161718192021222324252627282930313233void write_byte(unsigned char dat)&#123; unsigned char i = 0; for(i = 0; i &lt; 8; i++) &#123; dat = dat&lt;&lt;1; I2C2_SCL_L; delay(); SDA = CY; //类似于8086的PSW的CF位 即左移data溢出位进入CY delay(); I2C2_SCL_H; delay(); &#125; I2C2_SCL_L; delay(); I2C2_SDA_H; delay();&#125;unsigned char read_byte()&#123; unsigned char i = 0, dat; I2C2_SCL_L; delay(); I2C2_SDA_H; for(i = 0; i &lt; 8; i++) &#123; I2C2_SCL_H; delay(); dat = (dat&lt;&lt;1) | SDA; I2C2_SCL_L; delay(); &#125; return dat;&#125; 应答当IIC主机(不一定是发送端还是接收端)将8位数据或命令传出后，会将SDA信号设置为输入，等待从机应答(等待SDA由高电平拉为低电平)若从机正确应答，表示数据或命令传输成功，否则传输失败。注意：应答信号是数据接收方发送给数据发送方的。代码实现： 12345678910111213141516171819void Respons()&#123; I2C2_SDA_L; delay(); I2C2_SCL_H; delay(); I2C2_SCL_L; delay();&#125;void NoRespons()&#123; I2C2_SDA_H; delay(); I2C2_SCL_H; delay(); I2C2_SCL_L; delay();&#125;","categories":[{"name":"总线协议","slug":"总线协议","permalink":"http://yoursite.com/categories/%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"IIC","slug":"IIC","permalink":"http://yoursite.com/tags/IIC/"}]},{"title":"04-shell","slug":"04-shell","date":"2020-02-10T08:15:17.000Z","updated":"2020-02-10T08:18:50.901Z","comments":true,"path":"2020/02/10/04-shell/","link":"","permalink":"http://yoursite.com/2020/02/10/04-shell/","excerpt":"","text":"shell基础-函数hell函数调用 函数调用格式： 方式1：1value_name=`function_name [arg1 arg2...]` 方式2：12function_name [arg1 arg2...]echo $? 例子：1234567891011grep_user()&#123; R=`grep \"$1\" /etc/passwd | wc -l` echo $S return $R&#125;echo -n \"input username:\"read USERgrep_user $USERecho \"-$?-\" 函数变量的作用域 全局作用域：在脚本得其他任何地方都能够访问该变量 局部作用域：只能在声明变量得作用域内访问 声明局部变量得格式：1local variable_name=value 全部变量得声明 1variable_name=value","categories":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/categories/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"03-shell","slug":"03-shell","date":"2020-02-10T08:15:13.000Z","updated":"2020-02-10T08:18:24.763Z","comments":true,"path":"2020/02/10/03-shell/","link":"","permalink":"http://yoursite.com/2020/02/10/03-shell/","excerpt":"","text":"shell基础-循环语句循环语句for的用法 当循环次数已知或确定时，使用for循环语句来多次执行一条或一组命令。 1234for 变量名 in 单词表 do 命令表 done 也可以使用类语法来实现for循环 1234for ((I = 1; i &lt;= 10; I++))do echo \"I=$I\"done 循环语句while的用法 while语句先测试其后的命令或表达式的值，如果为真，就执行一次循环体中的命令，然后再测试该命令或表达式的值，执行循环体，知道该命令或表达式为假时退出循环. 1234while 命令或表达式 do 命令表 done 例子： 1234567891011121314151617181920#！/bin/bashI=0while [ $I -lt 5 ]do I=`expr $I + 1` echo -n \"input score:\" read S case `expr $S / 10` in 10|9) echo \"A\" ;; 6|7|8) echo \"B\" ;; *) echo \"C\" ;; esacdone 循环控制语句 break break n&#8195;则跳出n层 continue continue语句则马上转到最近一层循环语句的下一轮循环上 continue&#8195;n则转到最近n层循环语句的下一轮循环上","categories":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/categories/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"02-shell","slug":"02-shell","date":"2020-02-09T15:16:28.000Z","updated":"2020-02-10T08:12:06.562Z","comments":true,"path":"2020/02/09/02-shell/","link":"","permalink":"http://yoursite.com/2020/02/09/02-shell/","excerpt":"","text":"shell基础-分支语句条件语句 条件语句123if 表达式 then 命令表fi 如果表达式为真，则执行命令表中的命令；否则退出if语句，即执行`fi后面的语句 if和fi时条件语句的语句括号，`必须成对使用 命令表中的命令可以是一条，也可以时若干条1234567#！/bin/bashif[ $# -ne 1]then echo \"usage:$0 filename\" exitfi 1234if 表达式then 命令表1else 命令表2fi 如果表达式为真，则执行命令表1中的命令，再退出if语句，否则执行命令表2中的语句，再退出if语句12345678910111213#！/bin/bashif [ -d $1 ]then echo \"$1 is a directory\" exitelse if [ -f $1 ] then echo \"$1 is a common file\" else echo \"unknown\" fifi 多路分支语句 多路分支语句 多路分支语句case用于多重条件测试，语法结构清晰自然 12345678910case 字符串变量 in 模式1) 命令表1 ;; 模式2 | 模式3) 命令表2 ...... 模式n) 命令表nesac 双分号等同于c语言中的break","categories":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/categories/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"01-shell","slug":"01-shell","date":"2020-02-09T15:16:17.000Z","updated":"2020-02-10T08:12:23.010Z","comments":true,"path":"2020/02/09/01-shell/","link":"","permalink":"http://yoursite.com/2020/02/09/01-shell/","excerpt":"","text":"shell脚本基础echo命令： echo &quot;字符串&quot; echo -n “字符串”&#8195;表示不换行 echo $?&#8195; 表示上一条语句的执行结果，0表示真，非0表示假 expr命令：算术运算命令expr主要用于简单的整数运算，包括(+),(-),(*),(/)和求模(%)等操作： 123$ expr 12 + 5 \\* 3$ expr 3 - 8 / 2$ A=expr 12 + 5 \\* 3 注:算数运算两边必须加空格，赋值语句两边不能加空格 test命令：test语句可测试三种对象 字符串 整数 文件属性 字符串模式 s1 = s2&#8195;测试两个字符串的内容是否完全一样 s1 ！= s2&#8195; 测试两个字符串的内容是否有差异 -z s1&#8195; 测试s1字符串的长度是否为0 -n s1&#8195; 测试s1字符串的长度是否不为0 整数 a -eq b&#8195; 测试a与b是否相等 a -ne b&#8195; 测试a与b是否不相等 a -gt b&#8195; 测试a是否大于b a -ge b&#8195; 测试a是否大于等于b a -lt b&#8195; 测试a是否小于b a -le b&#8195; 测试a是否小于等于b 文件属性 -d name&#8195; 测试name是否为一个目录 -e name&#8195; 测试一个文件是否存在 -f name&#8195; 测试name是否为普通文件 -L name&#8195; 测试name是否为符号链接 -r name&#8195; 测试name文件是否存在且为可读 -w name&#8195; 测试name文件是否存在且为可写 -x name&#8195; 测试name文件是否存在且为可执行 -s name&#8195; 测试name文件是否存在且其长度不为0 f1 -nt f2&#8195; 测试文件f1是否比文件f2更新 f1 -ot f2&#8195; 测试文件f1是否比文件f2更旧","categories":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/categories/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"03-makefile","slug":"03-makefile","date":"2020-02-04T15:11:23.000Z","updated":"2020-02-12T05:53:08.649Z","comments":true,"path":"2020/02/04/03-makefile/","link":"","permalink":"http://yoursite.com/2020/02/04/03-makefile/","excerpt":"","text":"MakefileVPATH的用法 VPATH：虚路径 在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录里。所以，当make需要去寻找文件的依赖关系时，你可以在文件前加上路径，但最好的方法时把一个路径告诉make，让make自动去寻找。 Makefile文件中的特殊变量”VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件，到所指定的目录中去找寻文件了。 VPATH = src:../headers 上面的定义指定两个目录，&quot;src&quot;和&quot;../headers&quot;, make会按照这个顺序进行搜索，目录由”冒号”分隔。(当然，当前目录永远是最高优先搜索的地方)","categories":[{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/categories/makefile/"}],"tags":[{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/tags/makefile/"}]},{"title":"02-makefile","slug":"02-makefile","date":"2020-02-04T13:31:22.000Z","updated":"2020-02-10T15:26:32.485Z","comments":true,"path":"2020/02/04/02-makefile/","link":"","permalink":"http://yoursite.com/2020/02/04/02-makefile/","excerpt":"","text":"Makefilemake使用 直接运行make 选项 -C &#8195; dir读入指定目录下的Makefile -f &#8195; file读入 -i &#8195; 忽略所有的命令执行错误 -I &#8195; dir指定被包含的Makefile所在目录 -n &#8195; 只打印要执行的命令，但不执行这些命令 -p &#8195; 显示make变量数据库和隐含规则 -s &#8195; 在执行命令时不显示命令 -w &#8195; 如果make在执行过程中改变目录，打印当前目录名 makefile可以include + 文件名来引用其他文件中的内容Makefile的隐含规则 隐含规则1：编译c程序的隐含规则 “&lt;n&gt;.o”的目标的依赖目标会自动推导为”&lt;n&gt;.c”，并且其生成命令是”$(CC) -c $(CPPFLAGS) $(CFLAGS)” 隐含规则2：链接Object文件的隐含规则 “&lt;n&gt;”目标依赖于”&lt;n&gt;.o”，通过运行c的编译器来运行连接程序生成(一般是”ld”)，其生成命令是：”$(CC) $(LDFLAGS) &lt;n&gt;.o” $(LOADLIBES) $(LDLIBS)。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件(由不同的源文件生成)的也有效","categories":[{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/categories/makefile/"}],"tags":[{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/tags/makefile/"}]},{"title":"01-makefile","slug":"01-makefile","date":"2020-02-04T10:27:54.000Z","updated":"2020-02-10T15:26:30.415Z","comments":true,"path":"2020/02/04/01-makefile/","link":"","permalink":"http://yoursite.com/2020/02/04/01-makefile/","excerpt":"","text":"MakefileMake简介 工程管理器，顾名思义，是指管理较多得文件 Make工程管理器也就是个自动编译管理器，这里得自动是指它能够根据文件时间戳自动发现更新过得文件而减少编译得工作量，同时，它通过读入Makefile文件得内容来执行大量得编译工作。 Make将只编译改动的代码文件，而不用完全编译Makefile基本结构 Makefile是Make读入的唯一配置文件 由make工具创建的目标体(target)，通常是目标文件或可执行文件 要创建的目标体所依赖的文件(dependency_file) 创建每个目标体时需要运行的命令(command) 注意：命令行前面必须是一个”TAB键”，否则编译错误 Makefile格式 12target : dependency_files&lt;TAB&gt; command 例子 12hello : hello.c hello.h gcc -c hello.c -o hello.o 更复杂的例子 123456sunq : kang.o yul.o gcc kang.o yul.o -o sunqkang.o : kang.c kang.h gcc -Wall -O -g -c kang.c -o kang.oyul : yul.c gcc -Wall -O -g -c yul.c -o yul.o 注释： -WALL表示允许发出gcc所有有用的报警信息 -c只是编译不链接，生成目标文件”.o” -o file:表示把输出文件输出到file里创建和使用变量 创建变量的目的： 用来代替一个文本字符串： 系列文件的名字 传递给编译器的参数 需要运行的程序 需要查找源代码的目录 你需要输出信息的目录 你想做的其他事情 变量定义的两种方式 递归展开方式VAR=var 简单方式VAR:=var 变量使用$(VAR) 用$则用$$来表示 类似于编程语言中的宏定义 刚才的例子： 12345foo=$(bar)bar=$(ugh)ugh=Huh?$(foo)的值为?echo $(foo)来进行查看 优点：它可以向后引用变量 缺点：不能对该变量进行任何扩展 用?=定义变量&#8195;dir:=/foo/bar&#8195;FOO?=bar&#8195;FOO是? FOO之前没被定义过则被定义为bar 预定义变量 AR &#8195; 库文件维护程序的名称，默认值为ar CC &#8195; C编译器的名称，默认值为cc。CPP&#8195;C预编译器的名称，默认值为$(CC) -E CXX &#8195; C++编译器的名称，默认值为g++ FC &#8195; FORTRAN编译器的名称，默认值为f77 RM &#8195; 文件删除程序的名称，默认值为rm -f 自动变量 $* &#8195; 不包含扩展名的目标文件名称 $+ &#8195; 所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件 $&lt; &#8195; 第一个依赖文件的名称 $? &#8195; 所有时间戳比目标文件晚的依赖文件，并以空格分开 $@ &#8195; 目标文件的完整名称 $^ &#8195; 所有不重复的目标依赖文件，以空格分开 $% &#8195; 如果目标是归档成员，则改变量表示目标的归档成员名称 刚才的例子： 123456789OBJS = kang.o yul.oCC = gccCFLAGS = -Wall -O -gsunq : $(OBJS) $(CC) $^ -o $@kang.o : kang.c kang.h $(CC) $(CFLAGS) -c $&lt; -o $@yul.o : yul.c yul.h $(CC) $(CFLAGS) -c $&lt; -o $@ 环境变量 make在启动时会自动读取系统当前已经定义了的环境变量，而且会创建与之具有相同名称和数值的变量 如果用户在Makefile中定义了相同名称的变量，那么用户自定义变量将会覆盖同名的环境变量","categories":[{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/categories/makefile/"}],"tags":[{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/tags/makefile/"}]}]}