<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Lx Y</title>
      <link href="/2020/03/05/Lx%20Y/"/>
      <url>/2020/03/05/Lx%20Y/</url>
      
        <content type="html"><![CDATA[<h1 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h1><h2 id="教师事业编："><a href="#教师事业编：" class="headerlink" title="教师事业编："></a>教师事业编：</h2><ul><li>滨江区教师招聘(中学，小学，幼儿园，<code>有编制</code>):<ul><li>根据<a href="http://www.shiyebian.net/xinxi/325325.html" target="_blank" rel="noopener">2020年杭州市滨江教育局所属事业单位面向毕业生和在职教师直接考核招聘教师公告</a>，对于应届生的招聘要求如下：<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(一)</span>全日制<span class="number">2020</span>届毕业生</span><br><span class="line">  <span class="number">1.</span>具有本科及以上学历、学士及以上学位，并且获得过国家奖学金、省级师范生技能大赛一等奖等奖项或省级及以上优秀毕业生、优秀学生<span class="comment">(党员)</span>、优秀学生<span class="comment">(党、团)</span>干部等荣誉称号的毕业生。</span><br><span class="line">  <span class="number">2.</span>具有研究生学历、博士学位的毕业生。</span><br><span class="line">  <span class="number">3.</span>具有研究生学历、硕士学位，符合下列五类条件之一：</span><br><span class="line">  <span class="comment">(1)</span>国家“一流大学”建设高校毕业生。</span><br><span class="line">  <span class="comment">(2)</span>国家“一流学科”建设高校和浙江省重点建设师范类高校毕业生，并且本科毕业于国家“双一流”建设高校或浙江省重点建设高校。</span><br><span class="line">  <span class="comment">(3)</span>国家“一流学科”建设高校和浙江省重点建设师范类高校毕业生，并且大学期间获得过校级优秀毕业生、优秀学生<span class="comment">(党员)</span>、优秀学生<span class="comment">(党、团)</span>干部等荣誉称号，或综合<span class="comment">(专业)</span>成绩排名前<span class="number">50</span><span class="meta">%</span>。</span><br><span class="line">  <span class="comment">(4)</span>普通高校毕业生，并且大学期间获得过校级优秀毕业生、优秀学生<span class="comment">(党员)</span>、优秀学生<span class="comment">(党、团)</span>干部等荣誉称号，或综合<span class="comment">(专业)</span>成绩排名前<span class="number">20</span><span class="meta">%</span>。</span><br><span class="line">  <span class="comment">(5)</span>普通高校学前教育方向毕业生。</span><br><span class="line">  <span class="number">4.</span>具有本科学历、学士学位，符合下列三类条件之一：</span><br><span class="line">  <span class="comment">(1)</span>国家“一流大学”建设高校毕业生，并且获得校级优秀毕业生、优秀学生<span class="comment">(党员)</span>、优秀学生<span class="comment">(党、团)</span>干部等荣誉称号，或综合<span class="comment">(专业)</span>成绩排名前<span class="number">50</span><span class="meta">%</span>。</span><br><span class="line">  <span class="comment">(2)</span>国家“一流学科”建设高校和浙江省重点建设师范类高校毕业生，并且获得校级优秀毕业生、优秀学生<span class="comment">(党员)</span>、优秀学生<span class="comment">(党、团)</span>干部等荣誉称号，或综合<span class="comment">(专业)</span>成绩排名前<span class="number">20</span><span class="meta">%</span>。</span><br><span class="line">  <span class="comment">(3)</span>普通师范类高校或浙江省内高校毕业生，获得校级优秀毕业生、优秀学生<span class="comment">(党员)</span>、优秀学生<span class="comment">(党、团)</span>干部等荣誉称号，且综合<span class="comment">(专业)</span>成绩排名前<span class="number">10</span><span class="meta">%</span>。</span><br><span class="line">  <span class="number">5.</span>教育部直属师范大学免<span class="comment">(公)</span>费师范生。</span><br><span class="line"></span><br><span class="line">  注：上述条件并没有包括海外研究生的要求，但是根据公示的录取名单里面是有海外研究生被录取。</span><br></pre></td></tr></table></figure><ul><li>报名时间：2019年5月10日至11日（上午8:30—11:00，下午13:00—16:00）</li><li>报名时间：2019年7月23日至8月5日（上午9：00-11：00，下午13：30-16：00，双休日除外）</li><li>报名时间：2019年12月17日至12月30日(上午9：00-11：00，下午13：30-16：00，双休日除外)</li><li>根据<a href="http://www.hhtz.gov.cn/art/2020/1/10/art_1485978_41588136.html" target="_blank" rel="noopener">公告公示</a>,总录取人数为20人(包括海外研究生),因为分三次招聘此次是12月份招聘的人数，一年总的招聘人数为67人。<br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcj3d8ranzj30yq01ua9z.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcj3eaz9l7j30yo01odft.jpg" alt=""></li><li>统计过后报录比基本上1:5</li></ul></li></ul></li><li>萧山区教师招聘(中学，小学，幼儿园，<code>有编制</code>):<ul><li>根据<a href="http://www.xiaoshan.gov.cn/art/2019/11/16/art_1228964830_40311619.html" target="_blank" rel="noopener">杭州市萧山区面向2020届研究生和优秀本科生招聘公告</a>，对于应届生的招聘如下：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">一）对象：面向<span class="number">2020</span>届全日制普通高校毕业生。“<span class="number">985</span>”、“<span class="number">211</span>”院校毕业生户籍不限，省级重点师范院校毕业生户籍或生源地（即参加高考时的户籍地）为浙江省。</span><br><span class="line">  下列第<span class="number">1</span>至<span class="number">4</span>种对象可同时报考一、二类岗位，第<span class="number">5</span>种对象只能报考二类岗位。</span><br><span class="line"><span class="number">1.</span> 具有研究生学历、硕士及以上学位的“<span class="number">985</span>”、“<span class="number">211</span>”院校毕业生；</span><br><span class="line"><span class="number">2.</span> 具有研究生学历、硕士及以上学位的省级重点师范院校毕业生；</span><br><span class="line"><span class="number">3.</span> 具有本科学历、学士学位的“<span class="number">985</span>”、“<span class="number">211</span>”院校毕业生；</span><br><span class="line"><span class="number">4.</span> 具有本科学历、学士学位的省级重点师范院校重点批（即高考录取为一本）毕业生，并具备下列条件之一：校级及以上优秀毕业生或优秀学生（团）干部，综合（专业）成绩排名前<span class="number">20</span>%，校级二等及以上奖学金，浙江师范大学初阳学院毕业生。</span><br><span class="line"><span class="number">5.</span> 具有本科学历、学士学位的省级重点师范院校重点批（即高考录取为一本）毕业生，并具备下列条件之一：综合（专业）成绩排名前<span class="number">30</span>%，校级三等及以上奖学金。</span><br><span class="line"><span class="number">2019</span>年毕业并已获得教育部留学服务中心认证的研究生，且本科符合上述对象条件的人员也可报考。</span><br><span class="line">（二）身心健康：遵纪守法，热爱教育事业，有良好的社会公德和职业道德，具有适应岗位要求的身体条件。</span><br><span class="line">（三）年龄在<span class="number">28</span>周岁以下（<span class="number">1992</span>年<span class="number">7</span>月<span class="number">1</span>日后出生）。</span><br><span class="line">（四）学历、学位与专业：具体岗位要求详见《杭州市萧山区面向<span class="number">2020</span>届研究生和优秀本科生招聘计划表》（附件），报考学历专业须与招聘学科相符，<span class="number">2020</span>年<span class="number">7</span>月底前须获得相应的学历、学位证书。</span><br><span class="line"></span><br><span class="line">注：跟滨江区的要求稍有差别，这边对于海外研究生的本科也有要求。</span><br></pre></td></tr></table></figure></li><li>报名时间：11月4日9：00时至11月11日17:00。</li><li>初审地址：浙江师范大学，杭州师范大学</li></ul></li></ul><h2 id="非事业编以及其他"><a href="#非事业编以及其他" class="headerlink" title="非事业编以及其他"></a>非事业编以及其他</h2><ul><li><p>滨江区高中教师招聘(一般通过各个部署师范高校以及省内师范院校校招得到，<code>有无编制看学校</code>)：</p><ol><li>详情点击<a href="http://zjnu.jysd.com/largefairs/view/id/1228/domain/zjnu?tab=1" target="_blank" rel="noopener">此链接</a>，此链接为浙江师范大学2019秋招企业以及学校列表。</li><li>详情点击<a href="http://career.hznu.edu.cn/campus/index?keyword=&city=330100&time=&page=3" target="_blank" rel="noopener">此链接</a>，此链接为杭州师范大学2019年秋招企业以及学校列表。</li></ol></li><li><p>其他培训机构(<code>不建议</code>,虽然工资很高)</p></li><li><p>民办学校</p></li><li><p>高校的辅导员(还没到招聘时间)</p></li><li><p>外企：</p><ol><li>如brother等日企</li><li>欧美企业</li></ol></li><li><p>公务员(<code>三不限难度大</code>)</p></li><li><p>家里安排一下(<code>稳稳的幸福</code>)</p></li></ul><h2 id="教师资格证考试"><a href="#教师资格证考试" class="headerlink" title="教师资格证考试"></a>教师资格证考试</h2><ul><li>根据2019年下半年考试安排：<ul><li>笔试报名时间：2019年9月3日-6日</li><li>笔试考试时间：2019年11月2日</li><li>笔试成绩查询：2019年12月10日左右</li><li>面试考试时间：2020年1月4日-5日</li><li>今年不出意外还是同样的时间</li></ul></li><li>教师资格证分三门科目：<ol><li>综合素质 </li><li>教育知识与能力</li><li>学科知识与教学能力(<code>你应该没有问题</code>)</li></ol></li><li>三门课可以分开考，也可以一次性通过，分开考的话之前考的课有效期2年，<code>建议一次性考出</code>，前两门主要都是需要记忆的东西，对你来说问题也不大。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>建议尽快写论文，早做准备，做多手准备。以上只是我的建议。。。</p><center>End</center><center>Powered by www.hhlai.xyz</center>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>01-My bootloader</title>
      <link href="/2020/03/01/01-My%20bootloader/"/>
      <url>/2020/03/01/01-My%20bootloader/</url>
      
        <content type="html"><![CDATA[<h1 id="My-bootloader"><a href="#My-bootloader" class="headerlink" title="My bootloader"></a>My bootloader</h1><h2 id="最简单的bootloader的编写步骤"><a href="#最简单的bootloader的编写步骤" class="headerlink" title="最简单的bootloader的编写步骤"></a>最简单的bootloader的编写步骤</h2><ul><li>初始化硬件：关看门狗，设置时钟，设置SDRAM，初始化nand flash</li><li>如果bootloader比较大，要把它重定位到SDRAM</li><li>把内核从nand flash读到SDRAM</li><li>设置“要传给内核的参数”</li><li>跳转执行内核</li></ul><h2 id="创建start-S"><a href="#创建start-S" class="headerlink" title="创建start.S"></a>创建start.S</h2><ul><li><p>关看门狗</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldr </span><span class="built_in">r0</span>, <span class="number">=0x53000000</span> <span class="comment">;伪汇编指令，0x53000000不能放到立即数中</span></span><br><span class="line"><span class="keyword">mov </span><span class="built_in">r1</span>, <span class="number">#0</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">str </span><span class="built_in">r1</span>, [<span class="built_in">r0</span>]  <span class="comment">;将r1的值存在r0的地址中</span></span><br></pre></td></tr></table></figure></li><li><p>设置时钟</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">#define</span> S3C2440_MPLL_200MHZ  ((<span class="number">0x5c</span>&lt;&lt;<span class="number">12</span>)<span class="title">|(0x01&lt;&lt;4)|</span>(<span class="number">0x02</span>))</span><br><span class="line"><span class="keyword">ldr </span><span class="built_in">r0</span>, <span class="number">=0x4c000014</span></span><br><span class="line"><span class="keyword">mov </span><span class="built_in">r1</span>, <span class="number">#0x03</span> <span class="comment">;分频系数为3</span></span><br><span class="line"><span class="keyword">str </span><span class="built_in">r1</span>, [<span class="built_in">r0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">;改变CPU的总线模式从"fast bus mode"到"asynchronous"</span></span><br><span class="line"><span class="keyword">mrc </span><span class="built_in">p15</span>, <span class="number">0</span>, <span class="built_in">r1</span>, <span class="built_in">c1</span>, <span class="built_in">c0</span>, <span class="number">0</span> <span class="comment">;读出控制寄存器</span></span><br><span class="line"><span class="keyword">orr </span><span class="built_in">r1</span>, <span class="built_in">r1</span>, <span class="number">#0xc0000000</span>   <span class="comment">;设置为"asynchronous bus mode"</span></span><br><span class="line"><span class="symbol">mcr</span> <span class="built_in">p15</span>, <span class="number">0</span>, <span class="built_in">r1</span>, <span class="built_in">c1</span>, <span class="built_in">c0</span>, <span class="number">0</span> <span class="comment">;写入控制寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ldr </span><span class="built_in">r0</span>, <span class="number">=0x4c000004</span></span><br><span class="line"><span class="keyword">ldr </span><span class="built_in">r1</span>, <span class="symbol">=S3c2440_NPLL_200MHZ</span></span><br><span class="line"><span class="keyword">str </span><span class="built_in">r1</span>, [<span class="built_in">r0</span>]</span><br></pre></td></tr></table></figure></li><li><p>初始化SDRAM</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">#define</span> MEN_CTL_BASE <span class="number">0x48000000</span></span><br><span class="line">  <span class="keyword">ldr </span><span class="built_in">r0</span>, <span class="symbol">=MEM_CTL_BASE</span></span><br><span class="line">  <span class="keyword">adr </span><span class="built_in">r1</span>, sdram_config <span class="comment">;伪汇编指令 得到当前地址</span></span><br><span class="line">  <span class="keyword">add </span><span class="built_in">r3</span>, <span class="built_in">r0</span>, #(<span class="number">13</span>*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.</span><br><span class="line">  <span class="keyword">ldr </span><span class="built_in">r2</span>, [<span class="built_in">r1</span>], <span class="number">#4</span> <span class="comment">;从r1所指地方取一个值存到r2，然后让r1+4</span></span><br><span class="line">  <span class="keyword">str </span><span class="built_in">r2</span>, [<span class="built_in">r0</span>], <span class="number">#4</span></span><br><span class="line">  <span class="keyword">cmp </span><span class="built_in">r0</span>, <span class="built_in">r3</span></span><br><span class="line">  <span class="keyword">bne </span><span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">sdram_config</span>:</span><br><span class="line">      <span class="meta">.long</span> <span class="number">0x22011110</span></span><br><span class="line">      <span class="meta">.long</span> <span class="number">0x00000700</span></span><br><span class="line">      <span class="meta">.long</span> <span class="number">0x00000700</span></span><br><span class="line">      <span class="meta">.long</span> <span class="number">0x00000700</span></span><br><span class="line">      <span class="meta">.long</span> <span class="number">0x00000700</span></span><br><span class="line">      <span class="meta">.long</span> <span class="number">0x00000700</span></span><br><span class="line">      <span class="meta">.long</span> <span class="number">0x00000700</span></span><br><span class="line">      <span class="meta">.long</span> <span class="number">0x00018005</span></span><br></pre></td></tr></table></figure></li><li><p>重定位：把bootloader本身的代码从flash复制到它的链接地址去</p><p>norflash：<img src="https://tva1.sinaimg.cn/large/00831rSTly1gcj7fskqjaj30vy0be75r.jpg" alt=""></p><p>nandflash：<img src="https://tva1.sinaimg.cn/large/00831rSTly1gcj7hk093kj313w0eedit.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">ldr sp, =<span class="number">0x34000000</span> ;栈往下增长</span><br><span class="line"></span><br><span class="line">bl nand_init</span><br><span class="line"> </span><br><span class="line">mov r0, #<span class="number">0</span></span><br><span class="line">ldr r1, =_start  ;_start = <span class="number">0x33f80000</span></span><br><span class="line">ldr r2, =__bss_start</span><br><span class="line">sub r2, r2, r1</span><br><span class="line"></span><br><span class="line">bl copy_code_to_sdram  ;执行C语言函数，之前需要设置栈</span><br><span class="line">bl clean_bss</span><br><span class="line"></span><br><span class="line">#define NFCONF (*((volatile unsigned long *)<span class="number">0x4E000000</span>))</span><br><span class="line">#define NFCONF (*((volatile unsigned long *)<span class="number">0x4E000004</span>))</span><br><span class="line">#define NFCMMD (*((volatile unsigned char *)<span class="number">0x4E000008</span>))</span><br><span class="line">#define NFADDR (*((volatile unsigned char *)<span class="number">0x4E00000C</span>))</span><br><span class="line">#define NFDATA (*((volatile unsigned char *)<span class="number">0x4E000010</span>))</span><br><span class="line">#define NFSTAT (*((volatile unsigned char *)<span class="number">0x4E000020</span>)) <span class="comment">//nandflash 寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> isBootFromNorFlash(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    volatile <span class="built_in">int</span> *p = (volatile <span class="built_in">int</span> *)<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> val;</span><br><span class="line">    val = *p;</span><br><span class="line">    *p = <span class="number">0x12345678</span>; <span class="comment">//利用norflash不能写的特性</span></span><br><span class="line">    <span class="keyword">if</span>(*p == <span class="number">0x12345678</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//写成功，是nand启动</span></span><br><span class="line">        *p = val;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> copy_code_to_sdram(unsigned char *src, unsigned char *dest, unsigned <span class="built_in">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果是NOR启动</span></span><br><span class="line">    <span class="keyword">if</span>(isBootFromNorFlash())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            dest[i] = src[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//nand_init(); </span></span><br><span class="line">        nand_read(src, dest, len); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> clean_bss(<span class="built_in">void</span>) </span><br><span class="line">&#123;</span><br><span class="line">    extern <span class="built_in">int</span> __bss_start, __bss_end;</span><br><span class="line">    <span class="built_in">int</span> *p = &amp;__bss_start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; p &lt; &amp;__bss_end; p++)</span><br><span class="line">      *p = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> nand_init(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//时间参数,见之后的时序图</span></span><br><span class="line">#define TACLS <span class="number">0</span></span><br><span class="line">#define TWRPH0 <span class="number">1</span></span><br><span class="line">#define TWRPH1 <span class="number">0</span></span><br><span class="line">  <span class="comment">//设置时序</span></span><br><span class="line">  s3c2440nand-&gt;NFCONF = (TACLS&lt;&lt;<span class="number">12</span>) | (TWRPH0&lt;&lt;<span class="number">8</span>) | (TWRPH1&lt;&lt;<span class="number">4</span>);  </span><br><span class="line">  <span class="comment">//使能nand flash控制器，初始化ECC，禁止片选</span></span><br><span class="line">  NFCONT = (<span class="number">1</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">1</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> nand_select(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    NFCONT &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> nand_deselect(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    NFCONT |= (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> nand_cmd(unsigned char cmd)</span><br><span class="line">&#123;</span><br><span class="line">    volatile <span class="built_in">int</span> i;</span><br><span class="line">    NFCMMD = cmd;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++); <span class="comment">//延时一小会</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> nand_addr(unsigned <span class="built_in">int</span> addr)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned <span class="built_in">int</span> col = addr / <span class="number">2048</span>;</span><br><span class="line">    unsigned <span class="built_in">int</span> page = add % <span class="number">2048</span>;</span><br><span class="line">    volatile <span class="built_in">int</span> i;</span><br><span class="line"></span><br><span class="line">    NFADDR = col &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++);</span><br><span class="line">    NFADDR = (col &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++);</span><br><span class="line"></span><br><span class="line">    NFADDR = page &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++);</span><br><span class="line">    NFADDR = (page &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++);</span><br><span class="line">    NFADDR = (page &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> nand_wait_ready()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(!(NFSTAT &amp; <span class="number">1</span>));<span class="comment">//如果等于0一直循环</span></span><br><span class="line">&#125;</span><br><span class="line">unsigned char nand_data(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> NFDATA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> nand_read(unsigned <span class="built_in">int</span> addr, unsigned char *buf,unsigned <span class="built_in">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//写：写页数据，生成ECC，ECC➡️OOB(out of bank)</span></span><br><span class="line">    <span class="comment">//读：读OOB，算出ECC，与之前的ECC比较</span></span><br><span class="line">    <span class="comment">//将一整页读入页寄存器</span></span><br><span class="line">    <span class="built_in">int</span> col = addr / <span class="number">2048</span>;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.选中</span></span><br><span class="line">    nand_select();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//2.发出读命令00h</span></span><br><span class="line">        nand_cmd(<span class="number">0x00</span>);</span><br><span class="line">        <span class="comment">//3.发出地址(分5步发出)</span></span><br><span class="line">        nand_cmd(addr);</span><br><span class="line">        <span class="comment">//4.发出读命令30h</span></span><br><span class="line">        nand_cmd(<span class="number">0x30</span>);</span><br><span class="line">        <span class="comment">//5.判断状态</span></span><br><span class="line">        nand_wait_ready();</span><br><span class="line">        <span class="comment">//6.读数据</span></span><br><span class="line">        <span class="keyword">for</span>(; col &lt; <span class="number">2048</span> &amp;&amp; i &lt; len; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[i] = nand_data();</span><br><span class="line">            i++;</span><br><span class="line">            addr++;</span><br><span class="line">        &#125;</span><br><span class="line">        col = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取消选中</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时序图：<img src="https://tva1.sinaimg.cn/large/00831rSTly1gcjdgyfqnwj318w0p043m.jpg" alt=""><br>nandflash结构：<img src="https://tva1.sinaimg.cn/large/00831rSTly1gcjdrrtt9ij30l00g03z2.jpg" alt=""><br>读操作：<img src="https://tva1.sinaimg.cn/large/00831rSTly1gcjdyk0fecj310k0hkabc.jpg" alt=""></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//u-<span class="keyword">boot的链接脚本：</span></span><br><span class="line"><span class="keyword">SECTION&#123;</span></span><br><span class="line"><span class="keyword"> </span>   . = <span class="number">0x33f80000</span><span class="comment">;</span></span><br><span class="line">    <span class="meta">.text</span> : &#123; *(<span class="meta">.text</span>) &#125;</span><br><span class="line"></span><br><span class="line">    . = <span class="meta">ALIGN</span>(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line">    .rodata : (*(.rodata*))</span><br><span class="line"></span><br><span class="line">    . = <span class="meta">ALIGN</span>(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line">    <span class="meta">.data</span> &#123; *(<span class="meta">.data</span>) &#125;</span><br><span class="line"></span><br><span class="line">    . = <span class="meta">ALIGN</span>(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line">    __bss_start = .<span class="comment">;</span></span><br><span class="line">    .<span class="keyword">bss </span>: &#123; *(.<span class="keyword">bss) </span>*(<span class="meta">COMMON</span>) &#125;</span><br><span class="line">    __bss_end = .<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行main</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldr </span><span class="built_in">lr</span>, <span class="symbol">=halt</span></span><br><span class="line"><span class="keyword">ldr </span><span class="built_in">pc</span>, <span class="symbol">=main</span></span><br></pre></td></tr></table></figure><h2 id="创建main"><a href="#创建main" class="headerlink" title="创建main"></a>创建main</h2></li></ul>]]></content>
      
      
      <categories>
          
          <category> My bootloader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-boot</title>
      <link href="/2020/02/28/U-boot/"/>
      <url>/2020/02/28/U-boot/</url>
      
        <content type="html"><![CDATA[<h1 id="U-boot分析"><a href="#U-boot分析" class="headerlink" title="U-boot分析"></a>U-boot分析</h1><h2 id="嵌入式系统的启动过程"><a href="#嵌入式系统的启动过程" class="headerlink" title="嵌入式系统的启动过程"></a>嵌入式系统的启动过程</h2><ol><li>运行bootloader — BIOS</li><li>加载linux内核   — windows</li><li>挂载根文件系统   — C盘D盘</li><li>运行应用程序     — 应用程序</li><li>事实上u-boot是一个<code>单片机程序</code></li></ol><h2 id="U-boot编译过程"><a href="#U-boot编译过程" class="headerlink" title="U-boot编译过程"></a>U-boot编译过程</h2><ol><li>解压缩</li><li>打补丁 &emsp;<code>patch -p &lt;补丁文件</code></li><li>配置 &emsp;<code>make 100sk24x0_config</code></li><li>编译 &emsp;<code>make</code></li></ol><h2 id="启动内核"><a href="#启动内核" class="headerlink" title="启动内核"></a>启动内核</h2><ul><li>从FLASH读出内核</li><li>放到SDRAM</li><li>启动内核</li><li><code>因此u-boot的功能必须有</code><ol><li>读flash+写flash内核(为了开发方便)<ol><li>写flash</li><li>网卡</li><li>usb</li></ol></li><li>初始化SDRAM<ol><li>初始化时钟</li><li>启动串口</li></ol></li><li>启动内核<ol><li>读出内核<code>从flash</code><ol><li>初始化SDRAM</li><li>初始化时钟</li><li>关看门狗</li></ol></li></ol></li></ol></li></ul><h2 id="通过Makefile分析u-boot"><a href="#通过Makefile分析u-boot" class="headerlink" title="通过Makefile分析u-boot"></a>通过Makefile分析u-boot</h2><ul><li>u-boot启动的第一个文件：<code>cpu/arm920T/start.s</code></li><li>链接地址 <code>board/你的板子的名字/u-boot.lds</code><ul><li>通过设置<code>TEXT_BASE</code>的内容我们可以将代码段在不同的内存地址上运行</li></ul></li></ul><h2 id="u-boot具体初始化过程"><a href="#u-boot具体初始化过程" class="headerlink" title="u-boot具体初始化过程"></a>u-boot具体初始化过程</h2><ul><li><p>u-boot的第一阶段<code>硬件初始化</code>(注：硬件初始化只针对2440开发版)</p><ul><li><p>将CPU模式设置为SVC32<code>(管理模式)</code></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mrs </span><span class="built_in">r0</span>, <span class="keyword">cpsr</span></span><br><span class="line"><span class="keyword">bic </span><span class="built_in">r0</span>, <span class="built_in">r0</span>, <span class="number">#0x1f</span></span><br><span class="line"><span class="keyword">orr </span><span class="built_in">r0</span>, <span class="built_in">r0</span>, <span class="number">#0xd3</span></span><br><span class="line"><span class="keyword">msr </span><span class="keyword">cpsr </span><span class="built_in">r0</span></span><br></pre></td></tr></table></figure></li><li><p>关看门狗</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">#define</span> pWTCON <span class="number">0x15300000</span></span><br><span class="line">    <span class="keyword">ldr </span><span class="built_in">r0</span>, <span class="symbol">=pWTCON</span></span><br><span class="line">    <span class="keyword">mov </span><span class="built_in">r1</span>, <span class="number">#0x0</span></span><br><span class="line">    <span class="keyword">str </span><span class="built_in">r1</span>, [<span class="built_in">r0</span>]</span><br></pre></td></tr></table></figure></li><li><p>屏蔽中断</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define INTMSK <span class="number">0x4A000008</span></span><br><span class="line">#define INTSUBMSK <span class="number">0x4A00001C</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">r1</span>, #<span class="number">0xffffffff</span></span><br><span class="line">    ldr <span class="built_in">r0</span>, =INTMSK</span><br><span class="line">    <span class="keyword">str</span> <span class="built_in">r1</span>, [<span class="built_in">r0</span>]</span><br><span class="line">#if defined(CONFIG_S3C2410)</span><br><span class="line">    ldr <span class="built_in">r1</span>, =<span class="number">0x3ff</span></span><br><span class="line">    ldr <span class="built_in">r0</span>, =INTSUBMSK</span><br><span class="line">    <span class="keyword">str</span> <span class="built_in">r1</span>, [<span class="built_in">r0</span>]</span><br></pre></td></tr></table></figure></li><li><p>初始化时钟</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">#define</span> CLKDIVN <span class="number">0x4C000014</span></span><br><span class="line">    <span class="keyword">ldr </span><span class="built_in">r0</span>, <span class="symbol">=CLKDIVN</span></span><br><span class="line">    <span class="keyword">mov </span><span class="built_in">r1</span>, <span class="number">#3</span></span><br><span class="line">    <span class="keyword">str </span><span class="built_in">r1</span>, [<span class="built_in">r0</span>]</span><br></pre></td></tr></table></figure></li><li><p>初始化SDRAM</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">relocate</span>:</span><br><span class="line">    <span class="keyword">adr </span><span class="built_in">r0</span>, _start</span><br><span class="line">    <span class="keyword">ldr </span><span class="built_in">r1</span>, _TEXT_BASE</span><br><span class="line">    <span class="keyword">cmp </span><span class="built_in">r0</span>, <span class="built_in">r1</span></span><br><span class="line">    <span class="keyword">beq </span>stack_setup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ldr </span><span class="built_in">r2</span>, _armboot_start</span><br><span class="line">    <span class="keyword">ldr </span><span class="built_in">r3</span>, _bss_start</span><br><span class="line">    <span class="keyword">sub </span><span class="built_in">r2</span>, <span class="built_in">r3</span>, <span class="built_in">r2</span></span><br><span class="line">    <span class="keyword">add </span><span class="built_in">r2</span>, <span class="built_in">r0</span>, <span class="built_in">r2</span></span><br></pre></td></tr></table></figure></li><li><p>设置栈</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">stack_setup:</span></span><br><span class="line">    ldr <span class="built_in">r0</span>, _TEXT_BASE</span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">r0</span>, <span class="built_in">r0</span>, <span class="meta">#CONFIG_SYS_MALLOC_LEN</span></span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">r0</span>, <span class="built_in">r0</span>, <span class="meta">#CONFIG_SYS_GBL_DATA_SIZE</span></span><br><span class="line"><span class="meta">#ifdef CONFIG_USE_IRQ</span></span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">r0</span>, <span class="built_in">r0</span>, <span class="meta">#(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="keyword">sub</span> sp, <span class="built_in">r0</span>, <span class="meta">#12</span></span><br><span class="line">    vic sp, sp, <span class="meta">#7</span></span><br></pre></td></tr></table></figure></li><li><p>将flash拷到SDRAM</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">分为从<span class="keyword">nor</span> flash启动还是从<span class="keyword">nand</span> flash启动</span><br><span class="line">从<span class="keyword">nor</span> flash直接复制</span><br><span class="line">从<span class="keyword">nand</span> flash启动要进行初始化</span><br><span class="line">如何判断是从<span class="keyword">nor</span>还是<span class="keyword">nand</span> flash启动？</span><br><span class="line">对于norflash 必须通过一定的命令序列才能写数据。</span><br><span class="line">所以可以根据这点差别来分辨是从<span class="keyword">nor</span>还是<span class="keyword">nand</span>启动</span><br><span class="line">向地址<span class="number">0</span>写入一个数据，然后读出来，如果没有改变的话就是<span class="keyword">nor</span> flash。</span><br></pre></td></tr></table></figure></li><li><p>清空BSS段(初始值为0的静态变量或全局变量，或者未初始化的静态变量或全局变量)</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">clear_bss</span>:</span><br><span class="line">    <span class="keyword">ldr </span><span class="built_in">r0</span>, _bss_start</span><br><span class="line">    <span class="keyword">ldr </span><span class="built_in">r1</span>, _bss_end</span><br><span class="line">    <span class="keyword">mov </span><span class="built_in">r2</span>, <span class="number">#0x00000000</span> //clear</span><br></pre></td></tr></table></figure></li></ul></li><li><p>u-boot的第二阶段，启动内核(c语言实现)</p><ul><li><p>从flash中读出内核</p><ul><li>读flash<ul><li><code>flash_init()</code>函数实现对norflash的初始化</li><li><code>nand_init()</code>函数实现对nandflash的初始化</li><li><code>nand_read</code>函数将<code>kernel分区</code>中的内容读到0x30007FC0地址中(分区由我们自己在flash中指定划分，分区名字不重要，分区名代表<code>起始地址</code>与<code>分区大小</code>)<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nand read.jffs2 <span class="number">0</span>x30007FC0 kernel<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>启动内核</p><ul><li><p>设置启动参数</p></li><li><p>跳到入口地址</p></li><li><p><code>s=getenv(&quot;bootcmd&quot;)</code></p></li><li><p><code>run_command(s)</code></p></li><li><p>flash上存在的内核：UImage(头部+真正的内核)</p><p>UImage的头部有加载地址，当do_bootm后面跟的地址与头部的加载地址不同，将内核移到加载地址执行.<br>因此do_bootm后面的地址不一定非要很准确，只要不破坏结构即可。<br>do_bootm(地址);</p></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> U-boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-计算机网络</title>
      <link href="/2020/02/14/03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/02/14/03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="TCP编程API"><a href="#TCP编程API" class="headerlink" title="TCP编程API"></a>TCP编程API</h2><ol><li><code>socket()函数</code><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> socket(<span class="built_in">int</span> domain, <span class="built_in">int</span> type, <span class="built_in">int</span> protocol)</span><br></pre></td></tr></table></figure><ul><li>参数：<ol><li><code>domin</code></li></ol><ul><li>AF_INET</li><li>AF_INET6</li><li>AF_UNIX</li><li>AF_NETLINK</li><li>AF_PACKET</li></ul><ol><li><code>type</code><ul><li>SOCK_STREAM &emsp; 流式套接字，唯一对应于TCP</li><li>SOCK_DGRAM &emsp; 数据报套接字，唯一对应着UDP</li><li>SOCK_RAW:&emsp; 原始套接字</li></ul></li><li><code>protocol</code><ul><li>一般填0，原始套接字编程时需填充</li></ul></li></ol></li><li>返回值：<ul><li>成功时返回文件描述符，出错时返回为-1</li></ul></li></ul></li><li><code>bind()函数</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct socketaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数<ol><li>sockfd &emsp; 通过socket()函数拿到的fd</li><li>addr &emsp; struct sockaddr的结构体变量的地址 <code>如果是IPv6的编程，要使用struct sockaddr_in6结构体，通常更通用的方法可以通过struct sockarrd_storage来编程</code></li><li>addrlen &emsp; 地址长度</li></ol></li></ul></li><li><code>listen()函数</code> <figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> listen(<span class="built_in">int</span> sockfd, <span class="built_in">int</span> backlog)<span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li>参数<ol><li>sockfd &emsp; 通过socket()函数拿到的fd</li><li>backlog &emsp; 同时允许几路客户端进行正在连接的过程(正在三次握手)，一般位<code>5</code>，<code>测试得知，ARM最大为8</code></li></ol></li><li>内核中服务器的套接字fd会维护2个链表<ol><li>正在三次握手的客户端链表(数量=2*backlog+1)</li><li>已经建立好连接的客户端链表(已经完成3次握手分配好了newfd)</li></ol></li><li>返回值<ul><li>成功时返回为0，出错时返回-1</li></ul></li></ul></li><li><code>accept()函数</code><ul><li>阻塞等待客户端连接请求<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure></li><li>参数<ol><li>sockfd：经过前面socket()创建并通过bind()，listen()设置过的fd</li></ol></li><li>返回值<ul><li>成功时返回已经建立好连接的新的newfd.</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-计算机网络</title>
      <link href="/2020/02/14/02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/02/14/02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><ul><li>是一个编程借口：<code>唯一应用层与传输层中间的接口</code></li><li>是一种特殊的文件描述符<code>(对它执行IO的操作函数，比如read()，write())</code></li><li>并不仅限于TCP/IP协议</li><li>面向连接(TCP/IP)</li><li>无连接<code>(UDP和IPX)</code></li></ul><h2 id="Socket类型"><a href="#Socket类型" class="headerlink" title="Socket类型"></a>Socket类型</h2><ul><li>流式套接字(SOCK_STREAM)：<code>唯一对应着TCP</code><ul><li>提供了一个面向连接，可靠的数据传输服务，数据无差错，无重复的发送且按发送顺序接受，内设置流量控制，避免数据流淹没慢的接收方，数据被看作是字节流，无长度限制</li></ul></li><li>数据报套接字(SOCK_DGRAM)：<code>唯一对应着UDP</code><ul><li>提供无链接服务。数据包以独立数据包的形式被发送，不提供无差错保证，数据可能丢失或重复，顺序发送，可能乱序接收。</li></ul></li><li>原始套接字(SOCK_RAW)：<code>跨过了传输层，直接到网络层</code><ul><li>可以对较低层次协议如IP ICMP直接访问</li></ul></li></ul><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><ul><li>IP地址分为IPv4和IPv6<ul><li>IPv4:采用32位的整数来表示</li><li>IPv6:采用128位的整数来表示</li><li>mobile IPv6:local IP(本地注册的IP)，roam IP(漫游IP)</li></ul></li><li>IPv4地址：<ul><li>点分形式：192.168.2.43</li><li>特殊IP地址：<ul><li>局域网IP：192.XXX.XXX.XXX 10.XXX.XXX.XXX</li><li>广播地址： XXX.XXX.XXX.255 255.255.255.255(全局广播)</li><li>组播IP：224.XXX.XXX.XXX~239.XXX.XXX.XXX</li></ul></li></ul></li></ul><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><ul><li>16位数字(1-65535)<ul><li>众所周知端口：1～1023(FTP：21，SSH：22，HTTP：80，HTTPS：469)</li><li>保留端口：1024～5000(不建议使用)</li><li>可以使用的：5000～65535</li></ul></li><li>为了区分一台主机接收到的数据包应该交给哪个任务来处理</li><li>TCP端口和UDP端口是相互独立的(都可以用1456)</li><li>网络里面的通信是由IP+端口号来决定的</li></ul><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><ul><li>字节序是指不同的CPU访问内存中的<code>多字节数据</code>时，存在大小端问题</li><li>如CPU访问的<code>字符串</code>，则不存在大小端问题<ul><li>小端序(little-endian) &emsp;-低序字节存储在低字节<code>低对低</code></li><li>大端序(big-endian) &emsp;-低序字节存储在高字节<code>低对高</code></li><li>一般来说：<ul><li>X86/ARM：小端</li><li>PowerPc/MIPS，ARM作为路由器时，大端模式</li><li>``网络传输的时候采用大端模式</li></ul></li></ul></li><li>本地字节序，网络字节序<ul><li>把给定系统所采用的字节序称为主机字节序。</li><li>为了避免不同类别主机之间在数据交换时由于对于字节序不同而导致的差错，引入了网络字节序</li><li>主机字节序到网络字节序<ul><li>u_long htonl (u_long hostlong);</li><li>u_short htons (u_short short);</li></ul></li><li>网络字节序到主机字节序<ul><li>u_long ntohl (u_long hostlong);</li><li>u_short ntohs (u_short short);</li></ul></li></ul></li><li>IP地址转换函数<ul><li>in_addr_t inet_addr(const char *cp);<ul><li><code>cp：点分形式的IP地址，结果是32位整数(内部包含了字节序的转换，默认是网络字节序的模式)</code></li><li><code>仅适用于IPv4</code></li><li><code>当出错时，返回-1</code></li><li><code>此函数不能用于255.255.255.255(全位1跟-1区分不开)</code></li></ul></li><li>inet_pton()/inet_ntop(int af, const char* src, void* dst);<ul><li><code>适应于IPv4和IPv6</code></li><li><code>能正确的处理255.255.255.255的转换问题</code></li><li><code>参数</code>：<ol><li>af：地址协议族(AF_INET或AF_INET^)</li><li>src:是一个指针(填写点分形式的IP地址)</li><li>dst:转换的结果给到dst</li></ol></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-计算机网络</title>
      <link href="/2020/02/14/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/02/14/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><ul><li>物理层</li><li>数据链路层</li><li>网络层</li><li>传输层</li><li>会话层</li><li>表示层</li><li>应用层<h2 id="网络采用分层的思想"><a href="#网络采用分层的思想" class="headerlink" title="网络采用分层的思想"></a>网络采用分层的思想</h2></li></ul><ol><li>每一层实现不同的功能，对上层的数据做透明传输</li><li>每一层向上层提供服务，同时使用下层提供的服务<h2 id="各层典型的协议"><a href="#各层典型的协议" class="headerlink" title="各层典型的协议"></a>各层典型的协议</h2></li></ol><ul><li>网络借口与物理层<ul><li>MAC地址：48位全球唯一，网络设备的身份标识</li><li>ARP/RARP：<ul><li>ARP：IP地址–&gt;MAC地址</li><li>RARP：MAC地址–&gt;IP地址</li></ul></li><li>PPP协议：拨号协议(GPRS/3G/4G)  </li></ul></li><li>网络层<ul><li>IP：Internet protocol(分为IPv4和IPv6)</li><li><code>ICMP：Internet控制管理协议</code>，ping命令属于ICMP，端到端</li><li><code>IGMP：Internet分组管理协议</code>，广播，组播  </li></ul></li><li>传输层<ul><li>TCP(Transfer control protocol)提供面向连接的，一对一的可靠数据传输的协议<code>即数据无误，数据无丢失，数据无失序，数据无重复到达的通信</code></li><li>UDP(user Datagram protocol)提供不可靠无链接的尽力传输协议<code>是不可靠的无链接协议，在数据发送前，不需要连接，所以可以进行高效率的数据传输</code></li><li>SCTP：可靠传输，是TCP的增强版，它能实现多主机，多链路的通信</li></ul></li><li>应用层<ul><li>网页访问协议：HTTP/HTTPS</li><li>邮件发送接受协议：POP3(收)/SMTP(发)，IMAP(可接受邮件的一部分)</li><li>FTP</li><li>Talent/SSH：远程登陆</li><li>嵌入式相关：<ul><li>NTP：网络时钟协议</li><li><code>SNMP</code>：简单网络管理协议</li><li>RTP/RTSP：用传输音视频的协议，用于安防监控，<code>事实上这个协议是TCP+UDP来实现的</code></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIC协议时序分析</title>
      <link href="/2020/02/12/IIC/"/>
      <url>/2020/02/12/IIC/</url>
      
        <content type="html"><![CDATA[<h1 id="IIC协议时序分析"><a href="#IIC协议时序分析" class="headerlink" title="IIC协议时序分析"></a>IIC协议时序分析</h1><h2 id="IIC简介"><a href="#IIC简介" class="headerlink" title="IIC简介"></a>IIC简介</h2><p>IIC（Inter-Integrated Circuit）其实是IICBus简称，所以中文应该叫集成电路总线，它是一种串行通信总线，使用多主从架构，由飞利浦公司在1980年代为了让主板、嵌入式系统或手机用以连接低速周边设备而发展。</p><h2 id="IIC组成"><a href="#IIC组成" class="headerlink" title="IIC组成"></a>IIC组成</h2><p>IIC串行总线一般有两根信号线，一根是<code>双向</code>的数据线SDA，另一根是时钟线SCL。所有接到IIC总线设备上的串行数据SDA都接到总线的SDA上，各设备的时钟线SCL接到总线的SCL上。<br>空闲状态：SCL高电平   SDA高电平</p><h2 id="IIC具体协议时序"><a href="#IIC具体协议时序" class="headerlink" title="IIC具体协议时序"></a>IIC具体协议时序</h2><h3 id="开始停止信号"><a href="#开始停止信号" class="headerlink" title="开始停止信号"></a>开始停止信号</h3><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtlofog3uj30nf064jre.jpg" alt="start"><br>代码实现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">void <span class="constructor">IIC_Start(<span class="params">void</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    I2C2_SDA_H;  <span class="comment">//拉高数据线</span></span><br><span class="line"></span><br><span class="line">    I2C2_SCL_H;  <span class="comment">//拉高时钟线</span></span><br><span class="line"></span><br><span class="line">    <span class="constructor">I2C2_delay()</span>;<span class="comment">//现在延时为16us， 5</span></span><br><span class="line"></span><br><span class="line">    I2C2_SDA_L; <span class="comment">//产生下降沿</span></span><br><span class="line"></span><br><span class="line">    <span class="constructor">I2C2_delay()</span>;</span><br><span class="line"></span><br><span class="line">    I2C2_SCL_L;<span class="comment">//拉低时钟线，钳住I2C总线，准备发数据或者接受数据</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void <span class="constructor">IIC_Stop(<span class="params">void</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    I2C2_SCL_L;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">I2C2_delay()</span>;</span><br><span class="line"></span><br><span class="line">    I2C2_SDA_L;  <span class="comment">//停止，CLK上升沿</span></span><br><span class="line"></span><br><span class="line">    <span class="constructor">I2C2_delay()</span>;</span><br><span class="line"></span><br><span class="line">    I2C2_SCL_H;  <span class="comment">//拉高时钟线</span></span><br><span class="line"></span><br><span class="line">    <span class="constructor">I2C2_delay()</span>;</span><br><span class="line"></span><br><span class="line">    I2C2_SDA_H;  <span class="comment">//拉高数据线，结束信号</span></span><br><span class="line"></span><br><span class="line">    <span class="constructor">I2C2_delay()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p><img src="https://img-blog.csdnimg.cn/2019060815381722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyODI4,size_16,color_FFFFFF,t_70" alt="tranmform"></p><p>每一个字节必须保证是<code>8位长度</code>。数据传输时，<code>先传送最高位(MSB)</code>，每一个被传送的字节后面都必须<code>跟随一位应答位</code>，即一帧共有9位。</p><p>代码实现：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_byte</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> dat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        dat = dat&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        I2C2_SCL_L;</span><br><span class="line">        <span class="built_in">delay</span>();</span><br><span class="line">        SDA = CY;    <span class="comment">//类似于8086的PSW的CF位 即左移data溢出位进入CY</span></span><br><span class="line">        <span class="built_in">delay</span>();</span><br><span class="line">        I2C2_SCL_H;</span><br><span class="line">        <span class="built_in">delay</span>();    </span><br><span class="line">    &#125;</span><br><span class="line">    I2C2_SCL_L;</span><br><span class="line">    <span class="built_in">delay</span>();</span><br><span class="line">    I2C2_SDA_H;</span><br><span class="line">    <span class="built_in">delay</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">read_byte</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> i = <span class="number">0</span>, dat;</span><br><span class="line">    I2C2_SCL_L;</span><br><span class="line">    <span class="built_in">delay</span>();</span><br><span class="line">    I2C2_SDA_H;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        I2C2_SCL_H;</span><br><span class="line">        <span class="built_in">delay</span>();</span><br><span class="line">        dat = (dat&lt;&lt;<span class="number">1</span>) | SDA;</span><br><span class="line">        I2C2_SCL_L;</span><br><span class="line">        <span class="built_in">delay</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应答"><a href="#应答" class="headerlink" title="应答"></a>应答</h3><p>当IIC主机(不一定是发送端还是接收端)将8位数据或命令传出后，会将SDA信号设置为输入，等待从机应答(等待SDA由高电平拉为低电平)若从机正确应答，表示数据或命令传输成功，否则传输失败。<code>注意：应答信号是数据接收方发送给数据发送方的。</code><br><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtlmfamm4j30ny09oaab.jpg" alt="reponse"><br>代码实现：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void Respons()</span><br><span class="line">&#123;</span><br><span class="line">    I2C2_SDA_L<span class="comment">;</span></span><br><span class="line">    delay()<span class="comment">;</span></span><br><span class="line">    I2C2_SCL_H<span class="comment">;</span></span><br><span class="line">    delay()<span class="comment">;</span></span><br><span class="line">    I2C2_SCL_L<span class="comment">;</span></span><br><span class="line">    delay()<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void NoRespons()</span><br><span class="line">&#123;</span><br><span class="line">    I2C2_SDA_H<span class="comment">;</span></span><br><span class="line">    delay()<span class="comment">;</span></span><br><span class="line">    I2C2_SCL_H<span class="comment">;</span></span><br><span class="line">    delay()<span class="comment">;</span></span><br><span class="line">    I2C2_SCL_L<span class="comment">;</span></span><br><span class="line">    delay()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总线协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-shell</title>
      <link href="/2020/02/10/04-shell/"/>
      <url>/2020/02/10/04-shell/</url>
      
        <content type="html"><![CDATA[<h1 id="shell基础-函数"><a href="#shell基础-函数" class="headerlink" title="shell基础-函数"></a>shell基础-函数</h1><h2 id="hell函数调用"><a href="#hell函数调用" class="headerlink" title="hell函数调用"></a>hell函数调用</h2><ul><li>函数调用格式：<ul><li>方式1：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">value_name</span>=`function_name [arg1 arg2<span class="built_in">..</span>.]`</span><br></pre></td></tr></table></figure></li><li>方式2：<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function_name [arg1 arg2.<span class="string">..</span>]</span><br><span class="line"><span class="keyword">echo</span> $?</span><br></pre></td></tr></table></figure></li><li>例子：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">grep_user()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">R</span>=`grep <span class="string">"<span class="variable">$1</span>"</span> /etc/passwd | wc -l`</span><br><span class="line">    echo <span class="variable">$S</span></span><br><span class="line">    return <span class="variable">$R</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo -n <span class="string">"input username:"</span></span><br><span class="line">read USER</span><br><span class="line">grep_user <span class="variable">$USER</span></span><br><span class="line">echo <span class="string">"-$?-"</span></span><br></pre></td></tr></table></figure><h2 id="函数变量的作用域"><a href="#函数变量的作用域" class="headerlink" title="函数变量的作用域"></a>函数变量的作用域</h2></li></ul></li><li>全局作用域：在脚本得其他任何地方都能够访问该变量</li><li>局部作用域：只能在声明变量得作用域内访问</li><li>声明局部变量得格式：<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local <span class="keyword">variable</span><span class="number">_n</span>ame=<span class="keyword">value</span></span><br></pre></td></tr></table></figure></li><li>全部变量得声明  <figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">variable</span><span class="number">_n</span>ame=<span class="keyword">value</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-shell</title>
      <link href="/2020/02/10/03-shell/"/>
      <url>/2020/02/10/03-shell/</url>
      
        <content type="html"><![CDATA[<h1 id="shell基础-循环语句"><a href="#shell基础-循环语句" class="headerlink" title="shell基础-循环语句"></a>shell基础-循环语句</h1><h2 id="循环语句for的用法"><a href="#循环语句for的用法" class="headerlink" title="循环语句for的用法"></a>循环语句for的用法</h2><ul><li>当循环次数<code>已知或确定</code>时，使用for循环语句来多次执行一条或一组命令。  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量名 <span class="keyword">in</span> 单词表</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        命令表</span><br><span class="line">    <span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li>也可以使用类语法来实现for循环  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((I = 1; i &lt;= 10; I++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"I=<span class="variable">$I</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="循环语句while的用法"><a href="#循环语句while的用法" class="headerlink" title="循环语句while的用法"></a>循环语句while的用法</h2></li><li>while语句先测试其后的命令或表达式的值，如果为真，就执行一次循环体中的命令，然后再测试该命令或表达式的值，执行循环体，知道该命令或表达式为假时退出循环.  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 命令或表达式</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        命令表</span><br><span class="line">    <span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li>例子：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#！/bin/bash</span></span><br><span class="line">I=0</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$I</span> -lt 5 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    I=`expr <span class="variable">$I</span> + 1`</span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"input score:"</span></span><br><span class="line">    <span class="built_in">read</span> S</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> `expr <span class="variable">$S</span> / 10` <span class="keyword">in</span></span><br><span class="line">        10|9)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"A"</span></span><br><span class="line">            ;;</span><br><span class="line">        6|7|8)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"B"</span></span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"C"</span></span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2></li><li>break<ul><li>break n&#8195;则跳出n层</li></ul></li><li>continue<ul><li>continue语句则马上转到最近一层循环语句的下一轮循环上</li><li>continue&#8195;n则转到最近n层循环语句的下一轮循环上</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-shell</title>
      <link href="/2020/02/09/02-shell/"/>
      <url>/2020/02/09/02-shell/</url>
      
        <content type="html"><![CDATA[<h1 id="shell基础-分支语句"><a href="#shell基础-分支语句" class="headerlink" title="shell基础-分支语句"></a>shell基础-分支语句</h1><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><ul><li>条件语句<pre><code><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">if</span>  <span class="string">表达式</span></span><br><span class="line">    <span class="attr">then</span> <span class="string">命令表</span></span><br><span class="line"><span class="attr">fi</span></span><br></pre></td></tr></table></figure></code></pre><ul><li>如果表达式为<code>真</code>，则执行命令表中的命令；否则<code>退出if语句</code>，即执行`fi后面的语句</li><li>if和fi时条件语句的语句括号，`必须成对使用</li><li>命令表中的命令可以是一条，也可以时若干条<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#！/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>[ <span class="variable">$#</span> -ne <span class="number">1</span>]</span><br><span class="line">then</span><br><span class="line">    echo <span class="string">"usage:$0 filename"</span></span><br><span class="line">    <span class="keyword">exit</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式</span><br><span class="line">then 命令表<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span> 命令表<span class="number">2</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li>如果表达式为<code>真</code>，则执行<code>命令表1</code>中的命令，再退出if语句，否则执行<code>命令表2</code>中的语句，再退出if语句<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#！/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$1</span> ]</span><br><span class="line">then</span><br><span class="line">    echo <span class="string">"$1 is a directory"</span></span><br><span class="line">    <span class="keyword">exit</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="variable">$1</span> ]</span><br><span class="line">    then</span><br><span class="line">        echo <span class="string">"$1 is a common file"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        echo <span class="string">"unknown"</span></span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="多路分支语句"><a href="#多路分支语句" class="headerlink" title="多路分支语句"></a>多路分支语句</h2><ul><li>多路分支语句<ul><li>多路分支语句case用于多重条件测试，语法结构清晰自然   <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> 字符串变量 <span class="keyword">in</span></span><br><span class="line">    模式<span class="number">1</span>)</span><br><span class="line">            命令表<span class="number">1</span></span><br><span class="line">            ;;</span><br><span class="line">    模式<span class="number">2</span> | 模式<span class="number">3</span>)</span><br><span class="line">            命令表<span class="number">2</span></span><br><span class="line">    ......</span><br><span class="line">    模式n)</span><br><span class="line">            命令表n</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li></ul></li><li><code>双分号</code>等同于c语言中的break</li></ul>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-shell</title>
      <link href="/2020/02/09/01-shell/"/>
      <url>/2020/02/09/01-shell/</url>
      
        <content type="html"><![CDATA[<h1 id="shell脚本基础"><a href="#shell脚本基础" class="headerlink" title="shell脚本基础"></a>shell脚本基础</h1><h2 id="echo命令："><a href="#echo命令：" class="headerlink" title="echo命令："></a>echo命令：</h2><ul><li><code>echo &quot;字符串&quot;</code></li><li><code>echo -n “字符串”</code>&#8195;表示不换行</li><li><code>echo $?</code>&#8195; 表示上一条语句的执行结果，<code>0</code>表示<code>真</code>，<code>非0</code>表示<code>假</code></li></ul><h2 id="expr命令："><a href="#expr命令：" class="headerlink" title="expr命令："></a>expr命令：</h2><p>算术运算命令<code>expr</code>主要用于简单的整数运算，包括<code>(+)</code>,<code>(-)</code>,<code>(*)</code>,<code>(/)</code>和求模<code>(%)</code>等操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ expr 12 + 5 \* 3</span><br><span class="line">$ expr 3 - 8 / 2</span><br><span class="line">$ A=expr 12 + 5 \* 3</span><br></pre></td></tr></table></figure><p>注:算数运算两边必须加空格，赋值语句两边不能加空格</p><h2 id="test命令："><a href="#test命令：" class="headerlink" title="test命令："></a>test命令：</h2><p><code>test语句</code>可测试三种对象  </p><p><code>字符串</code> <code>整数</code> <code>文件属性</code></p><ul><li>字符串模式<ul><li><code>s1 = s2</code>&#8195;测试两个字符串的内容是否完全一样</li><li><code>s1 ！= s2</code>&#8195; 测试两个字符串的内容是否有差异</li><li><code>-z s1</code>&#8195; 测试s1字符串的长度是否为0</li><li><code>-n s1</code>&#8195; 测试s1字符串的长度是否不为0</li></ul></li><li>整数<ul><li><code>a -eq b</code>&#8195; 测试a与b是否<code>相等</code></li><li><code>a -ne b</code>&#8195; 测试a与b是否<code>不相等</code></li><li><code>a -gt b</code>&#8195; 测试a是否<code>大于</code>b</li><li><code>a -ge b</code>&#8195; 测试a是否<code>大于等于</code>b</li><li><code>a -lt b</code>&#8195; 测试a是否<code>小于</code>b</li><li><code>a -le b</code>&#8195; 测试a是否<code>小于等于</code>b</li></ul></li><li>文件属性<ul><li><code>-d name</code>&#8195; 测试name是否为一个<code>目录</code></li><li><code>-e name</code>&#8195; 测试一个文件<code>是否存在</code></li><li><code>-f name</code>&#8195; 测试name是否为<code>普通文件</code></li><li><code>-L name</code>&#8195; 测试name是否为<code>符号链接</code></li><li><code>-r name</code>&#8195; 测试name文件是否<code>存在</code>且为<code>可读</code></li><li><code>-w name</code>&#8195; 测试name文件是否<code>存在</code>且为<code>可写</code></li><li><code>-x name</code>&#8195; 测试name文件是否<code>存在</code>且为<code>可执行</code></li><li><code>-s name</code>&#8195; 测试name文件是否<code>存在</code>且其长度<code>不为0</code></li><li><code>f1 -nt f2</code>&#8195; 测试文件f1是否比文件f2<code>更新</code></li><li><code>f1 -ot f2</code>&#8195; 测试文件f1是否比文件f2<code>更旧</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-makefile</title>
      <link href="/2020/02/04/03-makefile/"/>
      <url>/2020/02/04/03-makefile/</url>
      
        <content type="html"><![CDATA[<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><h2 id="VPATH的用法"><a href="#VPATH的用法" class="headerlink" title="VPATH的用法"></a>VPATH的用法</h2><ul><li>VPATH：虚路径<ul><li>在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录里。所以，当make需要去寻找文件的依赖关系时，你可以在文件前加上路径，但<code>最好的方法时把一个路径告诉make，让make自动去寻找</code>。</li><li>Makefile文件中的特殊变量”VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件，到所指定的目录中去找寻文件了。</li><li><code>VPATH = src:../headers</code></li><li>上面的定义<code>指定两个目录</code>，<code>&quot;src&quot;</code>和<code>&quot;../headers&quot;</code>, make会按照这个顺序进行搜索，目录由”冒号”分隔。(当然，当前目录永远是最高优先搜索的地方)</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-makefile</title>
      <link href="/2020/02/04/02-makefile/"/>
      <url>/2020/02/04/02-makefile/</url>
      
        <content type="html"><![CDATA[<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><h2 id="make使用"><a href="#make使用" class="headerlink" title="make使用"></a>make使用</h2><ul><li>直接运行make</li><li>选项<ul><li>-C &#8195; dir读入指定目录下的Makefile</li><li>-f &#8195; file读入</li><li>-i &#8195; 忽略所有的命令执行错误</li><li>-I &#8195; dir指定被包含的Makefile所在目录</li><li>-n &#8195; 只打印要执行的命令，但不执行这些命令</li><li>-p &#8195; 显示make变量数据库和隐含规则</li><li>-s &#8195; 在执行命令时不显示命令</li><li>-w &#8195; 如果make在执行过程中改变目录，打印当前目录名</li></ul></li><li>makefile可以include + 文件名来引用其他文件中的内容<h2 id="Makefile的隐含规则"><a href="#Makefile的隐含规则" class="headerlink" title="Makefile的隐含规则"></a>Makefile的隐含规则</h2></li><li>隐含规则1：编译c程序的隐含规则<ul><li>“&lt;n&gt;.o”的目标的依赖目标会自动推导为”&lt;n&gt;.c”，并且其生成命令是”$(CC) -c $(CPPFLAGS) $(CFLAGS)”</li></ul></li><li>隐含规则2：链接Object文件的隐含规则<ul><li>“&lt;n&gt;”目标依赖于”&lt;n&gt;.o”，通过运行c的编译器来运行连接程序生成(一般是”ld”)，其生成命令是：”$(CC) $(LDFLAGS) &lt;n&gt;.o”</li><li>$(LOADLIBES) $(LDLIBS)。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件(由不同的源文件生成)的也有效</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-makefile</title>
      <link href="/2020/02/04/01-makefile/"/>
      <url>/2020/02/04/01-makefile/</url>
      
        <content type="html"><![CDATA[<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><h2 id="Make简介"><a href="#Make简介" class="headerlink" title="Make简介"></a>Make简介</h2><ul><li>工程管理器，顾名思义，是指管理较多得文件</li><li>Make工程管理器也就是个<code>自动编译管理器</code>，这里得<code>自动</code>是指它能够根据文件时间戳<code>自动发现</code>更新过得文件而减少编译得工作量，同时，它通过读入Makefile文件得内容来执行大量得编译工作。</li><li><code>Make将只编译改动的代码文件，而不用完全编译</code><h2 id="Makefile基本结构"><a href="#Makefile基本结构" class="headerlink" title="Makefile基本结构"></a>Makefile基本结构</h2></li><li><code>Makefile</code>是Make读入的唯一配置文件<ul><li>由make工具创建的目标体(<code>target</code>)，通常是目标文件或可执行文件</li><li>要创建的目标体所依赖的文件(<code>dependency_file</code>)</li><li>创建每个目标体时需要运行的命令(<code>command</code>)</li><li><code>注意：</code>命令行前面必须是一个”<code>TAB</code>键”，否则编译错误</li></ul></li><li>Makefile格式  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target : dependency_files</span><br><span class="line">&lt;<span class="literal">TAB</span>&gt; <span class="keyword">command</span></span><br></pre></td></tr></table></figure></li><li>例子  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">hello</span> : <span class="selector-tag">hello</span><span class="selector-class">.c</span> <span class="selector-tag">hello</span><span class="selector-class">.h</span></span><br><span class="line">    <span class="selector-tag">gcc</span> <span class="selector-tag">-c</span> <span class="selector-tag">hello</span><span class="selector-class">.c</span> <span class="selector-tag">-o</span> <span class="selector-tag">hello</span><span class="selector-class">.o</span></span><br></pre></td></tr></table></figure></li><li>更复杂的例子  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sunq</span> : <span class="selector-tag">kang</span><span class="selector-class">.o</span> <span class="selector-tag">yul</span><span class="selector-class">.o</span></span><br><span class="line">    <span class="selector-tag">gcc</span> <span class="selector-tag">kang</span><span class="selector-class">.o</span> <span class="selector-tag">yul</span><span class="selector-class">.o</span> <span class="selector-tag">-o</span> <span class="selector-tag">sunq</span></span><br><span class="line"><span class="selector-tag">kang</span><span class="selector-class">.o</span> : <span class="selector-tag">kang</span><span class="selector-class">.c</span> <span class="selector-tag">kang</span><span class="selector-class">.h</span></span><br><span class="line">    <span class="selector-tag">gcc</span> <span class="selector-tag">-Wall</span> <span class="selector-tag">-O</span> <span class="selector-tag">-g</span> <span class="selector-tag">-c</span> <span class="selector-tag">kang</span><span class="selector-class">.c</span> <span class="selector-tag">-o</span> <span class="selector-tag">kang</span><span class="selector-class">.o</span></span><br><span class="line"><span class="selector-tag">yul</span> : <span class="selector-tag">yul</span><span class="selector-class">.c</span></span><br><span class="line">    <span class="selector-tag">gcc</span> <span class="selector-tag">-Wall</span> <span class="selector-tag">-O</span> <span class="selector-tag">-g</span> <span class="selector-tag">-c</span> <span class="selector-tag">yul</span><span class="selector-class">.c</span> <span class="selector-tag">-o</span> <span class="selector-tag">yul</span><span class="selector-class">.o</span></span><br></pre></td></tr></table></figure></li><li>注释：<ul><li>-WALL表示允许发出gcc所有有用的报警信息</li><li>-c只是编译不链接，生成目标文件”.o”</li><li>-o file:表示把输出文件输出到file里<h2 id="创建和使用变量"><a href="#创建和使用变量" class="headerlink" title="创建和使用变量"></a>创建和使用变量</h2></li></ul></li><li>创建变量的目的：</li><li>用来代替一个文本字符串：  <ol><li>系列<code>文件的名字</code></li><li>传递给编译器的<code>参数</code></li><li>需要<code>运行的程序</code></li><li>需要查找<code>源代码的目录</code></li><li>你需要输出<code>信息的目录</code></li><li>你想做的其他事情</li></ol></li><li>变量定义的两种方式<ul><li>递归展开方式<code>VAR=var</code></li><li>简单方式<code>VAR:=var</code></li></ul></li><li>变量使用<code>$(VAR)</code></li><li>用<code>$</code>则用<code>$$</code>来表示</li><li>类似于编程语言中的宏定义</li><li>刚才的例子：  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo=<span class="constructor">$(<span class="params">bar</span>)</span></span><br><span class="line">bar=<span class="constructor">$(<span class="params">ugh</span>)</span></span><br><span class="line">ugh=Huh?</span><br><span class="line"><span class="constructor">$(<span class="params">foo</span>)</span>的值为?</span><br><span class="line">echo <span class="constructor">$(<span class="params">foo</span>)</span>来进行查看</span><br></pre></td></tr></table></figure><ul><li>优点：它可以向后引用变量</li><li>缺点：不能对该变量进行任何扩展</li></ul></li><li>用?=定义变量<br>&#8195;dir:=/foo/bar<br>&#8195;FOO?=bar<br>&#8195;FOO是?  <code>FOO之前没被定义过则被定义为bar</code></li><li>预定义变量<ul><li>AR &#8195; 库文件维护程序的名称，默认值为ar</li><li>CC &#8195; <code>C编译器</code>的名称，默认值为cc。CPP&#8195;C预编译器的名称，默认值为$(CC) -E</li><li>CXX &#8195; <code>C++编译器</code>的名称，默认值为g++</li><li>FC &#8195; <code>FORTRAN编译器</code>的名称，默认值为f77</li><li>RM &#8195; <code>文件删除</code>程序的名称，默认值为rm -f</li></ul></li><li>自动变量<ul><li>$* &#8195; <code>不包含扩展名</code>的目标文件名称</li><li>$+ &#8195; <code>所有的依赖文件</code>，以空格分开，并以出现的先后为序，可能包含重复的依赖文件</li><li>$&lt; &#8195; <code>第一个依赖文件</code>的名称</li><li>$? &#8195; <code>所有时间戳比目标文件晚的依赖文件</code>，并以空格分开</li><li>$@ &#8195; 目标文件的<code>完整名称</code></li><li>$^ &#8195; 所有<code>不重复的目标依赖文件</code>，以空格分开</li><li>$% &#8195; 如果目标是归档成员，则改变量表示目标的归档成员名称</li></ul></li><li>刚才的例子：  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OBJS = kang.o yul.o</span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall -O -g</span><br><span class="line">sunq : <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line">kang.o : kang.c kang.h</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">yul.o : yul.c yul.h</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure></li><li>环境变量<ul><li>make在启动时会自动读取系统当前已经定义了的环境变量，而且会创建与之具有相同名称和数值的变量</li><li>如果用户在Makefile中定义了相同名称的变量，那么用户自定义变量将会覆盖同名的环境变量</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
